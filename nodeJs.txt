#todo
#async #await


#TODO
Создание API https://metanit.com/web/nodejs/4.11.php










#JS

new #Error("Ошибка выполнения. randInt больше 5")



#string
#replace  data.replace("{header}", "header")
#substring #TODO
#toString()


let data = `${hour}:${minutes}:${seconds} ${request.method} ${request.url} ${request.get("user-agent")}`;


#Date
let now = new Date();
    let hour = now.getHours();
    let minutes = now.getMinutes();
    let seconds = now.getSeconds();




#node



#директория #direct
глобальная константа __dirname












поднять сервак  -->#server   создать такой файл и в консоли cd путь -> filename
node app.js

исполняемые файлы должны называться name.js






документация по модулям
https://nodejs.org/api/



#module
require("http");
require("os");   // предоставляет информацию об окружении и операционной системе
fs- работа с файлами
zlib - работа с архивами


//подключенные модули кешируются!!
//объект module представляет ссылку(именно ссылку в привычном понимании, если подключить модуль 2 раза и сохранить в разных переменных, они будут ссылаться на 1 и тот же объект) на текущий модуль, 



можно создать и подключить свой модуль, просто создать файл и 
//в данном случае файл находится в том же каталоге, относительный путь с именем файла (расширение файла необязательно)
const greeting = require("./greeting");

//в данном случае welcome-каталог в котором есть файл index.js  , при таком подключении будет вызываться именно он
const welcome = require("./welcome");







создание своего файла модуля
//переменная будет доступна только в данном модуле
let currentDate = new Date();

//вот так можно сделать переменную видимой вне модуля (Объект module.exports - это то, что возвращает функция require() при получении модуля)
//а его свойство exports определяет все свойства и методы модуля, 
//которые могут быть экспортированы и использованы в других модулях
module.exports.date = currentDate;
 
module.exports.getMessage = function(name){
    return currentDate.getHours();
}

//можно и так, в таком случае просто вернет строку
module.exports = "Доброе утро";



















#class
создание класса в модуле

function User(name){
     
    this.name = name;
    this.displayInfo = function(){
        console.log("Имя: ${this.name}");
    }
}
//устанавливаем функцию вне класса
User.prototype.sayHi = function() {
    console.log(`Привет, меня зовут ${this.name}`);
};
 
module.exports = User;




module.exports= class User{
 
    constructor(name, age){
        this.name = name;
        this.age = age;
    }
    save(){
        users.push(this);
    }
    static getAll(){
        return users;
    }
}



let SiteGuest = class User {
  sayHi() { alert('Привет!'); }
};

new SiteGuest().sayHi(); // Привет
new User(); // ошибка






function Machine() {//функция конструктор класса, если нужны параметры то закидывать
  var enabled = false;//private свойство, 

function asd(){//private функция, не будет наследоваться, если  надо наседовать то объявлять через this._asd  ,  _- указывает что функция прайват

}
  this.enable = function() {//public функция будет наследоваться
    enabled = true;
  };

  this.disable = function() {
    enabled = false;
  };
}

var sdf=new Machine();// или(но лучше со скобками) var sdf=new Machine;


2 способ с 2015 года
'use strict';//указывает о том что новые стандарты используются

class User {
//нельзя указывать поля(var a)
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }
static createGuest() {
    return new User("Гость", "Сайта");
  }

}

let user = new User("Вася");











//#get #set 
 // геттер
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  // сеттер
  set fullName(newValue) {
    [this.firstName, this.lastName] = newValue.split(' ');
  }

  // вычисляемое название метода #TODO
  ["test".toUpperCase()]() {
    alert("PASSED!");
  }



//#static
static createGuest() {
    return new User("Гость", "Сайта");
  }



//#наследование  #extends  #:
class Rabbit extends Animal {
  walk() {
    super.walk();
    alert("...and jump!");
  }
constructor() {
    // вызвать конструктор Animal с аргументом "Кроль"
//super() можно вызвать только в конструкторе, и перед этим вызовом не может быть обращения к this
    super("Кроль"); // то же, что и Animal.call(this, "Кроль")
  }
}






---
const User = require("./user.js");
 
let eugene = new User("Eugene", 32);
eugene.sayHi();











наследование 
function CoffeeMachine(power) {
  Machine.call(this); // унаследовать то что через this. задано(public свойства)
//или так
//Machine.apply(this, arguments)

// переопределить this.enable
  this.enable = function() {
    /* enable для кофеварки */
  };


//если хотим дополнить метод то так
var parentEnable = this.enable; 
  this.enable = function() { 
      parentEnable.call(this);
      this.run(); 
}
}




наследование при class

'use strict';

class Animal {
  constructor(name) {
    this.name = name;
  }

  walk() {
    alert("I walk: " + this.name);
  }
}

class Rabbit extends Animal {
  walk() {
    super.walk();//метод родителя будет вызываться
    alert("...and jump!");
  }

constructor() {

//Вызвать конструктор родителя можно только изнутри конструктора потомка. В частности, super() нельзя вызвать из произвольного метода.
//В конструкторе потомка мы обязаны вызвать super() до обращения к this. До вызова super не существует this, так как по спецификации в этом случае именно super инициализирует this.
    // вызвать конструктор Animal с аргументом "Кроль"
    super("Кроль"); // то же, что и Animal.call(this, "Кроль")
  }
}




















#global
#window или document недоступны тк работает на серваке
но есть другие global переменные
доступные #глобальные объекты https://nodejs.org/api/globals.html

для получения установки глобальной переменной
global.date = currentDate;
получить можно без global, просто через date

global.console.log(), и просто console.log()

//также доступ в любом месте приложения с помощью express
app.locals.collection














#process.argv
передать параметры в приложение
1 параметр всегда указывает на путь к файлу node.exe  который вызывает приложение
2 параметр всегда указывает на путь к файлу приложения, который выполняется

для передачи параметров вызывается так, все аргументы приводятся к строкам
node app.js Tom 23

let nodePath = process.argv[0];
let appPath = process.argv[1];
let name = process.argv[2];




можно создать команды по умолчанию
в package.json добавить
"scripts" : {
    "start" : "node app.js",
    "dev" : "node app.js Tom 26"
  }
}

//для активации данных команд если имя зарезервировано(start)
npm start
//если свое имя то
npm run [название_команды]
//в обоих случаях будет запущен файл app и при DEV будут переданы параметры














#npm #install
Node Package Manager
//если его необходимо обновить
npm install npm@latest -g
//узнать текущую версию 
npm -v

//установка модулей
перейти в папку проекта
npm install express

//флаг #global
//позволяет установить зависимость nodemon глобально для всех проектов на данной локальной машине
npm install nodemon -g


#package.json  #зависимости #конфиг
файл для управления модулями
name-название приложения
дополнительные секции --- https://docs.npmjs.com/creating-a-package-json-file
{
  "name": "modulesapp",
  "version": "1.0.0"
}

в таком случае(при наличии файла)
устанавливать надо так #install
флаг --save  - указывает что сохранить надо в файле package
npm install express --save


в файле изменения будут записываться так
{
  "name": "modulesapp",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.14.0"
  }
}


если мы определили все необходимые пакеты(или они сами добавили при установке) в файле конфигурации то
мы можем их удалить, а при необходимости докачать все сразу такой командой
npm install


#devDependencies 
зависимости которые добавляются только на этап разработки #save-dev
устанавливать так
npm install jasmine-node --save-dev

и так сохранится в файл
},
  "devDependencies": {
    "jasmine-node": "^1.14.5"
  }


#uninstall
//удаление пакетов
//просто сам пакет
npm uninstall express
//пакет+ информация из файла конфигурации
npm uninstall express --save



ТЕОРИЯ
правила названий версий пакетов
При определении версии пакета применяется семантическое версионирование. Номер версии, как правило, задается в следующем формате "major.minor.patch". Если в приложении или пакете обнаружен какой-то баг и он исправляется, то увеличивается на единицу число "patch". Если в пакет добавляется какая-то новая функциональность, которая совместима с предыдущей версией пакета, то это небольшое изменение, и увеличивается число "minor". Если же в пакет вносятся какие-то большие изменения, которые несовместимы с предыдущей версией, то увеличивается число "major".








#nodemon
если необходимо внести изменения в проект без явной перезагрузки проекта(при изменении кода, перезагрузится сам)
npm install nodemon -g

запускать приложение так
nodemon app.js






#callback
#throw
//такая структура
function (err, data){
    if(err) throw err;
}








#async #асинхронность  #Promise
//достигается с помощью #setTimeout  (функция которую туда передаем станосится в очередь и выполняется асинхронно)
// структура функции желательно должна быть именно такой(данные, колбэк).. структура колбэка (ошибка, данные)
function display(data, callback){
    setTimeout(function(){
        callback(err, data);
    }, 0);
}
display("Обработка данных...", function (err, data){
 
    if(err) throw err;
    console.log(data);
});


////--#await

async function add1(x) {
  const a = await resolveAfter2Seconds(20);
  const b = await resolveAfter2Seconds(30);
  return x + a + b;
}


async function resolveAfter2Seconds(x) {
  return new Promise(resolve => {//для этого объекта можно применять await
    setTimeout(() => {
//асинхронный код
      resolve(x);//функция которая вернет данные(она передается параметром самой системой)
    }, 0);
  });
}










#fs #file
необходимо подключить модуль "fs"
//что бы считать в синхронном варианте
let fileContent = fs.#readFileSync("hello.txt", "utf8");
//путь файла относительно файла приложения app.js ... функция вернет текст

//в асинхронном.. колбек выполнится после завершения считывания
fs.#readFile("hello.txt", "utf8", function(error,data){ });



запись в файл
//данные функции перезаписывают файл
//синхронный вариант
fs.#writeFileSync("hello.txt", "Привет ми ми ми!")
//асинхронный вариант, сюда тоже можно засунуть колбэк 3 параметром
fs.#writeFile("hello.txt", "Привет МИГ-29!")



ДОзапись в файл

fs.#appendFile()/fs.#appendFileSync():

удаление файла
//синхронное
fs.unlinkSync("hello.txt")

//асинхронное
fs.unlink("hello.txt", (err) => {
  if (err) console.log(err); // если возникла ошибка    
  else console.log("hello.txt was deleted");
});
















#stream #потоки 
#createWriteStream #write #createReadStream

const fs = require("fs");
 
//открывает файл, если файла нет то создает
let writeableStream = fs.createWriteStream("hello.txt");
writeableStream.write("Привет мир!");
writeableStream.write("Продолжение записи \n");
writeableStream.end("Завершение записи");
let readableStream = fs.createReadStream("hello.txt", "utf8");
 
//Сам поток разбивается на ряд кусков или чанков (chunk). И при считывании каждого такого куска, возникает событие data. С помощью метода on() мы можем подписаться на это событие и вывести каждый кусок данных на консоль
readableStream.on("data", function(chunk){ 
    console.log(chunk);
});





проверить существование файла #exist
//2 параметр-проверяем права на чтение из файла
fs.access(filePath, fs.constants.R_OK, err => {
       
        if(err){
             // если произошла ошибка - файла нет
        }
        else{
        }
      });









#Pipe
 это канал, который связывает поток для чтения и поток для записи и позволяет сразу считать из потока чтения в поток записи


let readableStream = fs.createReadStream("hello.txt", "utf8");
let writeableStream = fs.createWriteStream("some.txt");

//это можно переписать 
readableStream.on("data", function(chunk){
    writeableStream.write(chunk);
});
//так
readableStream.pipe(writeableStream);

const zlib = require("zlib");//#zlib #zip #gz
let gzip = zlib.createGzip();
Каждый метод pipe() в цепочке вызовов возвращает поток для чтения, к которому опять же можно применить метод pipe() для записи в другой поток
readableStream.pipe(gzip).pipe(writeableStream);









для отправки файла клиенту(#html страницы например)
response.setHeader("Content-Type", "text/html");
//response.writeHead(200,{"Content-Type":"application/msword"});
//можно через пайп и потоки
fs.createReadStream(filePath).pipe(response);
//можно просто считать все что в файле и закинуть в поток обычной записью(write)



если надо отправлять не статичные файлы то

//сам файл
<body>
    <h1>{header}</h1>
    <p>{message}</p>
</body>

fs.readFile("index.html", "utf8", function(error, data){
                 
        let message = "Изучаем Node.js"; 
        data = data.replace("{header}", header).replace("{message}", message);
        response.end(data);
    })
















#EventEmitter #Emitter #Event 



const Emitter = require("events");
let emitter = new Emitter();
let eventName = "greet";
//связываем функцию и обработчик, можно привязать несколько обработчиков
emitter.on(eventName, function(){
    console.log("Hello all!");
});
 
emitter.on(eventName, function(){
    console.log("Привет!");
});
 
//вызываем событие
emitter.emit(eventName);
//передадим параметр в обработчик, в данном случае обработчик надо переписать так что бы он принимал параметр
emitter.emit(eventName, "Привет пир!");




#наследование от класса события #util

const util = require("util");
const EventEmitter = require("events");
 
//---
//класс наследник от EventEmitter
function User(){
}
//"наследуем"
util.inherits(User, EventEmitter);


//добавляем в класс метод который будет вызывать событие( emit-наследуется)
User.prototype.sayHi = function(data){
    this.emit(eventName, data);
}
//---
let eventName = "greet";
let user = new User();
// добавляем к объекту user обработку события "greet"
user.on(eventName, function(data){
    console.log(data);
});
 
user.sayHi("Мне нужна твоя одежда...");


то что выше находится между //---, можно переписать проще благодаря ES6, тогда строку можно убрать require("util");

class User extends EventEmitter {
    sayHi(data) {
        this.emit(eventName, data);
    }
}









#server
//получаем модуль http, который необходим для создания сервера.
const http = require("http");
//создается новый сервер для прослушивания входящих подключений и обработки запросов
http.createServer(
//request-поток который хранит всю информацию о запросе, 
//response-поток который используется для отправки ответа
function(request,response){

//поддержка русских букв #utf
response.writeHead(200, {"Content-type": "text/plain; charset=utf-8;"})

     //отправляется ответ
    response.end("Hello NodeJS!");
     
//Чтобы сервер начал прослушивать входящие подключения -listen
}).listen(3000, "127.0.0.1",function(){
    console.log("Сервер начал прослушивание запросов на порту 3000");
});//но вроде можно и так .listen(3000);



#Request
//request-поток который хранит всю информацию о запросе,
//объект класса http.#IncomingMessage
основные свойства
#headers: возвращает заголовки запроса... request.headers["user-agent"]
#method: тип запроса (GET, POST, DELETE, PUT)
#url: представляет запрошенный адрес



#Response
//поток который используется для отправки ответа
//объект класса http.#ServerResponse

основные методы
#statusCode: устанавливает статусный код ответа #404
#statusMessage: устанавливает сообщение, отправляемое вместе со статусным кодом
#setHeader(name, value): добавляет в ответ один заголовок
#write: пишет в поток ответа некоторое содержимое
#writeHead: добавляет в ответ статусный код и набор заголовков
#end: сигнализирует серверу, что заголовки и тело ответа установлены, в итоге ответ отсылается клиента. Данный метод должен вызываться в каждом запросе.








#Переадресация #redirect


response.statusCode = 302; // временная переадресация
        // на адрес localhost:3000/newpage
        response.setHeader("Location", "/newpage");
response.end();















#Express



файл должен выглядеть так

// подключение express
const express = require("express");
// создаем объект приложения
const app = express();
// определяем обработчик для маршрута "/"
app.get("/", function(request, response){
     
    // отправляем ответ #send
//В качестве параметра эта функция может принимать объект Buffer, строку, в том числе с html-кодом, объект javascript или массив
    response.send("<h2>Привет Express!</h2>");

//отправка #файла #file #sendFile, в данную функцию необходимо передать абсолютный путь
response.sendFile(__dirname + "/index.html");
});

//определяем такое в самом конце, тк сработает если ни 1 обработчик не подойдет
app.use(function (req, res, next) {
    res.status(404).send("Not Found")
});
// начинаем прослушивать подключения на 3000 порту
//вот так(закомментил) была ошибка и пофикшена была, app.listen(3000);
app.set('port', "3000");
module.exports = app;




для обработки определенных типов запросов
должны от более частных к общим
В качестве первого параметра эти функции могут принимать шаблон адреса, запрос по которому будет обрабатываться. Второй параметр функций представляет функцию, которая будет обрабатывать запрос по совпавшему с шаблоном адресу
#use
#get
#post
#put
#delete
app.get("/", function(request, response){});

указать параметры маршрута можно через :
app.get("/categories/:categoryId/products/:productId"

можно использовать регулярки
? указывает, что предыдущий символ может встречаться 1 раз или отсутствовать
+ указывает, что предыдущий символ может встречаться 1 и более раз
* указывает, что на месте данного символа может находиться любое количество символов
группировка - "/book(.html)?"

можно напрямою указать регулярку
app.get(/.*(\.)html$/,



#Переадресация #redirect

response.redirect("https://site.com")//тоже самое что и
response.redirect(302,"https://site.com")


//с ресурса "/home" на ресурс "/about" -- на http://localhost:3000/about
app.use("/home",function (request, response) {
  response.redirect("about")
//на http://localhost:3000/home/about
app.use("/home/bar",function (request, response) {
  response.redirect("about")
//если нужна переадресация относительно корня то нужно добавить \
 response.redirect("/about")
//с http://localhost:3000/home/foo/bar на http://localhost:3000/home/foo/about
response.redirect("./about")
//с http://localhost:3000/home/foo/bar на http://localhost:3000/home/about
response.redirect("../about")
//с http://localhost:3000/home/foo/bar на http://localhost:3000/home/foo
response.redirect(".")
//с http://localhost:3000/home/foo/bar на http://localhost:3000/home
 response.redirect("..")















#middleware #use




const app = express();
//next: следующая в конвейере обработки функция
app.use(function(request, response, next){  
    console.log("Middleware 1");
    next();
});
app.use(function(request, response, next){
//если вызвать send то дальше вызова следующиего next не будет, и сама обработка запроса закончится(это и будет финальный результат независимо от того что и где еще определено)
 response.send("Middleware 2");
});
app.use("/about", function(request, response, next){});//устанавливаем обработчик для определенного маршрута
app.get("/", function(request, response){     
    console.log("Route /");
    response.send("Hello");
});





#status #404

response.sendStatus(404)
//если надо отправть свой текст
response.status(404).send("Ресурс не найден");




#static #file
//express.static()

необходимо поместить до остальных midleware
app.use(express.static(__dirname + "/public"));
//при таком подключении, доступ к файлу по запросу http://localhost:3000/static/about.html
app.use("/static", express.static(__dirname + "/public"));







#params #request

то что после & это параметры строки запроса, то что до это параметры маршрута req.query.name
localhost:3000/about/user?id=3&name=Tome
let userName = request.query.name;//если name-массив то получить его точно также, строка запроса такая же как в c#

#get #query
получаем параметры из строки запроса
let id = request.query.id;//id-название параметра
    let userName = request.params.name;

получить сложный объект точно также, а передать его через ?user[id]=7&user[name]=nms


если из боди(пост запрос например)
req.body.name;



получение параметров маршрута
задаются через :
app.get("/products/:productId", function (request, response) {
  response.send("productId: " + request.params["productId"])
});
app.get("/categories/:categoryId/products/:productId"







#form #post #get
для того что бы получать значения из формы нужен #body-parser
npm install body-parser --save



const bodyParser = require("body-parser");
  
const app = express();
  
// создаем парсер для данных application/x-www-form-urlencoded
//extended: false указывает, что объект - результат парсинга будет представлять набор пар ключ-значение, а каждое значение может быть представлено в виде строки или массива
const urlencodedParser = bodyParser.urlencoded({extended: false});
 
app.get("/register", urlencodedParser, function (request, response) {
    response.sendFile(__dirname + "/register.html");
});
app.post("/register", urlencodedParser, function (request, response) {
//проверяем передана ли форма
    if(!request.body) return response.sendStatus(400);
    console.log(request.body);
    response.send("${request.body.userName} - ${request.body.userAge}");
});







#json #form

// создаем парсер для данных в формате json
const jsonParser = express.json();
  
app.post("/user", jsonParser, function (request, response) {
    console.log(request.body);
    if(!request.body) return response.sendStatus(400);
//работа также как если бы просто форму принимали, тоесть
request.body.userName;

     //устанавливает для заголовка "Content-Type" значение "application/json", серилизует данные в json с помощью функции JSON.stringify() и затем отправляет данные с помощью response.send()
    response.json(request.body); // отправляем пришедший ответ обратно
});













#Router #routing

//вот такую штуку, можно переписать
app.use("/products/create",function (request, response) {
  response.send("Добавление товара");
});
app.use("/products/:id",function (request, response) {
  response.send(`Товар ${request.params.id}`);
});

//вот так

// определяем Router
const productRouter = express.Router();
 
// определяем маршруты и их обработчики внутри роутера
productRouter.use("/create", function(request, response){
  response.send("Добавление товара");
});
productRouter.use("/:id", function(request, response){
  response.send(`Товар ${request.params.id}`);
});
// сопотавляем роутер с конечной точкой "/products"
app.use("/products", productRouter);





const swaggerJSDoc = require('swagger-jsdoc');
router.get('/', require ('./example/main_example').get);
router.post('/add-example', require ('./example/add_example').post);

//и файл должен выглядеть как то так
const Example = require('../../models/example');
exports.post = function (req, res) {
        res.status(200).send('');
}









#views 


---------------------#hbs #Handlebars ---------------------------------------
npm install hbs --save
Для хранения представлений определим в проекте папку views. Затем в нее добавим новый файл contact.hbs. hbs - это расширение по умолчанию для представлений, которые обрабатываются движком Handlebars
//#render

в файле так помечаем динамические куски
<title>{{title}}</title>
{{#if emailsVisible}}
        <h3>Электронные адреса</h3>
        <ul>
            {{#each emails}}
                <li>{{this}}</li>
            {{/each}}
        </ul>
    {{/if}}





//устанавливаем движок представлений
app.set("view engine", "hbs");
//устанавливаем путь, это не обязательно, стандартно используется папка views
app.set("views", "templates"); // установка пути к представлениям 


app.use("/contact", function(request, response){
     //страница без параметров
    response.render("contact.hbs");
//с параметрами
response.render("contact.hbs", {
        title: "Мои контакты",
        });
});








#partial

views/partials новый файл menu.hbs

вот так рендерится частичное представление которое находится в файле menu.hbs
<body>{{> menu}}</body>

const hbs = require("hbs");
hbs.registerPartials(__dirname + "/views/partials");






#Layout #лаяут

Создадим в проекте в папке views новый каталог layouts и определим в нем файл layout.hbs


<!DOCTYPE html>
<html>
<head>
    <title>{{title}}</title>
    <meta charset="utf-8" />
</head>
<body>
    {{> menu}}
      
    {{{body}}}
      
    {{> footer}}
</body>
<html>


const express = require("express");
const expressHbs = require("express-handlebars");
const hbs = require("hbs");
const app = express();
  
// устанавливаем настройки для файлов layout
app.engine("hbs", expressHbs(
    {
        layoutsDir: "views/layouts", //относительный путь
        defaultLayout: "layout",//название файла
        extname: "hbs"
    }
))










#Хелперы  #helpers #registerHelper


hbs.registerHelper("getTime", function(){
     
    var myDate = new Date();
    var hour = myDate.getHours();
    return "Текущее время: " + hour;
});


hbs.registerHelper("createStringList", function(array){
     
    var result="";
    for(var i=0; i<array.length; i++){
        result +="<li>" + array[i] + "</li>";
    }
    return new hbs.SafeString("<ul>" + result + "</ul>");
});




вызов хэлпера
<div>{{getTime}}</div>
вызов с параметрами
 <div>{{createStringList fruit}}</div>




------------------КОНЕЦ---#hbs #Handlebars ---------------------------------------

------------------#EJS---------------------------------------

npm install ejs --save



app.set("view engine", "ejs");
 
app.use("/contact", function(request, response){
     //для файла contact.ejs
    response.render("contact", {
        title: "Мои контакты"
    });
});


в html
<title><%=title %></title>
<% if(emailsVisible) {%>
        <h3>Электронные адреса</h3>
        <ul>
            <% for(var i=0; i<emails.length;i++) {%>
                <li><%=emails[i] %></li>
            <%} %>
        </ul>
    <% }else {%>
        <h3>Электронный адрес отсутствует</h3>
    <%} %>






#Частичные представления #partial
определим в папке views каталог partials
#include

подключение частичного представления
<%- include("partials/menu.ejs") %>
<%- include('user/show', {user: user}); %>



------------------КОНЕЦ---#EJS---------------------------------------




---------------------#Pug---------------------------------------
файлы назваются так footer.pug

npm install pug --save



app.set("view engine", "pug");

в html
<title>#{title}</title>
//тут роляют только отступы как в питоне
if emailsVisible
        <h3>Электронные адреса</h3>
	h3 Электронные адреса ТАК ТОЖЕ МОЖНО
        <ul>
            each email in emails
                <li>#{email}</li>
		li=email
        </ul>
    else
        <h3>Электроннный адрес отсутствует</h3>


- var n = 0;
ul
  while n < 4
    li= n++

ul
  each val, index in {1:'one',2:'two',3:'three'}
    li= index + ': ' + val








#partial #частичные

   include footer.pug




#layout 

layout.pug

<body>
    block content   //определяем блок в который будут вставляться некоторые данные - указываем название блока
    include footer.pug
</body>



для применения мастер страницы, на другой странице пишем (путь к файлу)
extends layout.pug

и определяем блоки
block title
    <title>#{title}</title>
 
block content
      
    <h1>#{title} в Pug</h1>


------------------КОНЕЦ---#Pug---------------------------------------







#test #testing  #тест #тестирование #unittest


#Mocha
https://mochajs.org/
npm install mocha --save-dev



файл который нужно тестировать operations.js
файл который тестирует operations.test.js

var operations = require("./operations");
 
it("name of test", function(){
     
    var expectedResult = 15;
    var result = operations.multiply(3, 5);
    if(result!==expectedResult){
        throw new Error("Expected ${expectedResult}, but got ${result}");
    }
});
it("name of test2", function(){});


//для тестирования асинхронного кода
it("shoud async multiply two numbers", function(done){
    var expectedResult = 12;
    operations.multiplyAsync(4, 3, function(result){
        if(result!==expectedResult){
            throw new Error(`Expected ${expectedResult}, but got ${result}`);
        }
        done();
    });
});




для автоматического запуска тестирования всех файлов сразу
package.json
"version": "1.0.0",
  "scripts":{
    "test" : "mocha *.test.js"
  },


и для начала тестирования
в командной строке перейдем к папке проекта и выполним команду: npm test






#Assert #Assertions 

#equal


var assert = require("assert");
var operations = require("./operations");
 
it("should multiply two numbers", function(){
     
    var expected = 15;
    var result = operations.multiply(3, 5);
//сгенерит ошибку если значения не равны
    assert.equal(result, expected);
//сгенерит ошибку если значения равны
 assert.notEqual(result, expected);
//
assert.deepEqual(response.body, {name:"Tom", age:22});}
});


#describe
метод для группировки тестов
//в файле тестирования
describe("Operation Tests", function(){
    it("should multiply two numbers", function(){});
it("should multiply two numbers", function(){});});










#Express #supertest 
npm install supertest --save-dev



const express = require("express");
var app = express();
app.get("/", function (request, response){
    response.send("Hello Test");
});
app.listen(3000);
 //это важно
module.exports.app = app;




const request = require("supertest");
const assert = require("assert");
var app = require("./app").app;
it("should return Hello Test", function(done){
    request(app)
        .get("/")
        .expect("Hello Test")//ожидаемый результат
//.expect(404).expect("NotFound") // ---- если результат должен возвращаться так response.status(404).send("NotFound");
//.expect(function(response){assert.deepEqual(response.body, {name:"Tom", age:22});})  // ---- если результат должен возвращаться так response.send({name:"Tom", age: 22});
        .end(done);//выполняем тест
});

















#MongoDB #db 
установка и использование #TODO
https://metanit.com/nosql/mongodb/1.2.php
драйвер https://www.npmjs.com/package/mongodb


{
  "name": "mongoapp",
  "version": "1.0.0",
  "dependencies": {
      "express": "^4.16.0",
      "body-parser": "^1.18.0",
      "mongodb": "^3.1.0"
    }
}
//далее
npm install


#MongoClient - ключевой класс

const MongoClient = require("mongodb").MongoClient;

// создаем объект MongoClient и передаем ему строку подключения
const mongoClient = new MongoClient("mongodb://localhost:27017/", { useNewUrlParser: true });
// err (возникшая ошибка при установке соединения) и client (ссылка на подключенный к серверу клиент)
mongoClient.connect(function(err, client){
 
    if(err){
        return console.log(err);
    }
    // взаимодействие с базой данных, закрываем подключение
    client.close();
});



пример взаимодействия
//обращаемся к бд, если такой нет, то она будет создана
const db = client.db("usersdb");
//также создается при первом обращении
    const collection = db.collection("users");
    let user = {name: "Tom", age: 23};
//err (ошибка, которая может возникнуть при операции) и result (результат операции - добавленный объект).
    collection.insertOne(user, function(err, result){
          
        if(err){ 
            return console.log(err);
        }
//result.ops- результат вставки-- это уже не просто объект user, а объект, который получен обратно из базы данных и который содержит идентификатор, установленный при добавлении
        console.log(result.ops);
        client.close();
    });




#insertOne - добавить 1 объект
#insertMany - добавить набор объектов, использование такое же только передать коллекцию
#findAndModify #TODO
//#find
//#findOne - тоже самое но вернет 1 объект
collection.find().// вернет специальный объект #cursor ---- если надо фильтровать то find({name: "Tom",age:23})
toArray(function(err, results){
                 //result - все записи в "таблице"
        console.log(results);
        client.close();
    });

collection.find({}).toArray(function(err, users){
collection.findOne({_id: id}, function(err, user){



#deleteMany(): удаляет все документы, которые соответствуют определенному критерию, в данном улчае result это не коллекция удаленных элементов, а сложный объект
db.collection("users").deleteMany({name: "Tom"}, function(err, result){
#deleteOne(): удаляет один документ, который соответствует определенному критерию
#findOneAndDelete(): получает и удаляет один документ, который соответствует определенному критерию, result-удаленный элемент
#drop(): удаляет всю коллекцию
 db.collection("users").drop(function(err, result){


#updateOne: обновляет один документ, который соответствует критерию фильтрации, и возвращает информацию об операции обновления
#updateMany: обновляет все документы, которые соответствуют критерию фильтрации, и возвращает информацию об операции обновления
#findOneAndUpdate: обновляет один документ, который соответствует критерию фильтрации, и возвращает обновленный документ

db.collection("users").findOneAndUpdate(
            {age: 21}, // критерий выборки
            { $set: {age: 25}}, // параметр обновления
	{// доп. опции обновления, этот объект можно просто пропустить и тогда он будет по умолчанию null    
            returnOriginal: false//результатом будет новое значение
        },
            function(err, result){

db.collection("users").updateMany(
        {name: "Sam"},              // критерий фильтрации
        { $set: {name: "Bob"}},     // параметр обновления
        function(err, result){




при использовании с express, можно написать так
mongoClient.connect(function(err, client){
    if(err) return console.log(err);
    dbClient = client;
    app.locals.collection = client.db("usersdb").collection("users");
    app.listen(3000, function(){
        console.log("Сервер ожидает подключения...");
    });
});


//закрываем приложение+подключение при компинации клавишь
// прослушиваем прерывание работы программы (ctrl-c)
process.on("SIGINT", () => {
    dbClient.close();
    process.exit();
});









#Mongoose 
#ORM #ODM #Schema #схема

npm install mongoose --save

// подключение
mongoose.connect("mongodb://localhost:27017/usersdb", { useNewUrlParser: true });
  

const mongoose = require("mongoose");
const Schema = mongoose.Schema;
  
// установка схемы
const userSchema = new Schema({
    name: String},
 { versionKey: false }//при сохранении данных в документе сохраняется версия(поле __v), такой строкой ее можно отключить
);

//название модели, свяжет с таблицей по названию модели во множественном числе
const User = mongoose.model("User", userScheme);
const user = new User({
    name: "Bill"
});
  




#static
добавляем статические методы
userSchema.statics.findUserByName = (name, cb) => {
  return this.findOne({name: new RegExp(name, 'i')}, cb)
}
//User.findUserByName('alex', (err, user) => {console.log(err, user)})


//не статический метод
userSchema.methods.findSimilarUsersByCountry = function (cb) {
  return this.model('User').find({country: this.country}, cb)
}

userSchema.methods.findSimilarUsersByCountry = function (cb) {
  return this.model('User')
    .where('country', this.country)
    .where('_id').ne(this._id)
    .exec(cb)
}






//добавляем в бд+ создаем саму бд если ее нет
user.save(function(err){
    mongoose.disconnect();  // отключение от базы данных
      
    if(err) return console.log(err);
    console.log("Сохранен объект", user);
});
//user.save(тот что выше) можно заменить на
user.save()
.then(function(doc){
    console.log("Сохранен объект", doc);
    mongoose.disconnect();  // отключение от базы данных
})
.catch(function (err){
    console.log(err);
    mongoose.disconnect();
});




//схема

// установка схемы
const userScheme = new Schema({
    name: String,
    age: Number,
name222: {//указываем значение по умолчанию
        type: String,
        default: "NoName"
    },
name333: {//с ограничениями
        type: String,
        required: true,
        minlength:3,
        maxlength:20
    },
company: {//указываем сложный тип данных
        name: String,
        employee: [String], // тип - массив строк
        date: Date
    }
});




//если нужен массив в схеме
var Lib = new mongoose.Schema({
	userId: mongoose.Schema.ObjectId,
	images: {
		// правила валидации и дефолты для каждого из полей объекта массива images
		type: [{
			uploaded: {
				type: Date,
				default: Date.now
			},
			src: String
		}],
		// значение по-умолчанию для поля images
		default: [{uploaded: new Date(2012, 11, 22), src: '/img/default.png'}]
	}
});
module.exports = mongoose.model('Lib', Lib);




//если надо выгрузить всю коллекцию частями
e.m.users.find({}).stream()
	.on('data', function(user) {
		var me = this;
		me.pause();
		
		// выполняем надо пользователем очень хитрые асинронные манипуляции
		user.save(function(err) {
			me.resume(err);
		});
	})
	.on('error', function(err) {
		log(err);
	})
	.on('close', function() {
		log('All done');
	});












Определение типа свойств в схеме
В качестве типа данных можно указывать одно из следующих значений:
String
Number
Date
Buffer
Boolean
Mixed
Objectid
Array
Decimal128
Map




Валидация

Mongoose имеет ряд встроенных правил валидации, которые мы можем указать в схеме:
required: требует обязательного наличия значения для свойства
min и max: задают минимальное и максимальное значения для числовых данных
minlength и maxlength: задают минимальную и максимальную длину для строк
enum: строка должна представлять одно из значений в указанном массиве строк
match: строка должна соответствовать регулярному выражению






что бы правильно сравнивать id объектов надо
user1._id.equals(user2._id)
или user1._id.toString() == user2._id.toString()



#CRUD в Mongoose
Create, Read, Update and Delete

//для сохранения данных можно
user.save()//см выше
//можно так, функция передается точно такая же как и при save
User.create({name: "Tom", age: 34}, function(err, doc){});


Для получения данных можно использовать целый набор методов:
#find: возвращает все объекты, которые соответствуют критерию фильтрации
#findById: возвращает один объект по значению поля _id
#findOne: возвращает один объект, который соответствует критерию фильтрации

User.find({}, function(err, docs){});//функция как обычно, docs-массив выбранных данных
User.findById("123asd", function(err, doc){});//
User.findOne({name: new RegExp('alex', 'i')}, (err, user) => {})
let example = await Example.findOne({ _id: req.params._id });
let examples = await Example.find({});



User.#remove({age:33}, function(err, result){//result-- объект операции
User.#findOneAndDelete({name:"Bill"}, function(err, doc){//result-- объект который удален
User.#findByIdAndDelete("123asd", function(err, doc){

#updateOne() и #updateMany

User.updateOne({name: "Tom"}, {name: "Tom Smith"}, function(err, result){//result-- объект операции
User.#findByIdAndUpdate(id, {name: "Sam", age: 25}, function(err, result){//result-- старый док
User.findByIdAndUpdate(id, {name: "Bilbo Baggins", age: 111}, {new: true}, function(err, user){//result-- обновленный док
User.findOneAndUpdate({name: "Sam"}, {name: "Bill", age:24}, {new: true}, function(err, user){





User.findUserByName('alex', (err, user) => {
  user.country = 'US'
  user.save((err, savedUser) => {
    console.log('saaa', err, savedUser)
  })
})














Express и Mongoose

mongoose.connect("mongodb://localhost:27017/usersdb", { useNewUrlParser: true }, function(err){
    if(err) return console.log(err);
    app.listen(3000, function(){
        console.log("Сервер ожидает подключения...");
    });
});





#связи

var mongoose = require('mongoose');
var UserSchema = new mongoose.Schema({
    name: String
});
module.exports = mongoose.model("User", UserSchema);


var PostSchema = new mongoose.Schema({
    title: String,
    postedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    },
    comments: [{
        text: String,
        postedBy: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'User'
        }
    }]
});
















#db #mysql #sql

надо установить драйвер
mysql2 (можно и mysql, но лучше mysql2)
npm install --save mysql2



//#createConnection


const mysql = require("mysql2");
  
const connection = mysql.createConnection({
  host: "localhost",//хост, на котором запущен сервер mysql. По умолчанию имеет значение "localhost"
  user: "root",//пользователь MySQL, который используется для подключения
  database: "usersdb",//имя базы данных, к которой идет подключение. Необязательный параметр. Если он не указан, то подключение идт в целом к северу
  password: "пароль_от_сервера"//пароль для пользователя MySQL
});

//также доступны параметры
port: номер порта, на котором запущен сервер mysql. По умолчанию имеет значение "3306"
charset: кодировка для подключения, например, по умолчанию используется "UTF8_GENERAL_CI".
timezone: часовой пояс сервера MySQL. This is used to type cast server date/time values to JavaScript. По умолчанию имеет значение "local"


//создаем подключение #connect
connection.connect(function(err){
    if (err) {
      return console.error("Ошибка: " + err.message);
    }
    else{
      console.log("Подключение к серверу MySQL успешно установлено");
    }
 });

// закрытие подключения
//Метод end() гарантирует, что перед закрытием подключения к бд будут выполнены все оставшиеся запросы, которые не завершились к моменту вызова метода.
//Если мы не вызовем этот метод, то подключение будет оставаться активным, и приложение Node.js продолжит свою работу, пока сервер MySQL не закроет подключение.
 connection.end(function(err) {
  if (err) {
    return console.log("Ошибка: " + err.message);
  }
  console.log("Подключение закрыто");
});

//если необходимо закрыть не дожидаясь выполнения всех запросов то
connection.destroy()


#error
Если при подключении к серверу mysql генерируется ошибка
Client does not support authentication protocol requested by server; consider upgrading MySQL client
В этом случае необходимо в MySQL Workbench выполнить следующую команду:
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password'
Вместо 'password' должен быть указан пароль от MySQL для пользователя root.




//выполнение sql #query
query(sqlString, callback)

//при выполнении запросов неявно устанавливается подключение, => необязательно у объекта подключения вызывать метод connect().
connection.query("SELECT * FROM users",
  function(err, results, fields) {
    console.log(err);
    console.log(results); // собственно данные
    console.log(fields); // мета-данные полей 
});
connection.end();




//выполнение sql #execute

connection.execute("SELECT * FROM users", function(err, results, fields) {});


//параметризация для предотвращения sql иньекций
const user = ["Tom", 29];
const sql = "INSERT INTO users(name, age) VALUES(?, ?)";
connection.query(sql, user, function(err, results) {







//#Promise API #промис

const connection = mysql.createConnection({
 //тут как обычно
}).promise();//тут подключаем

//и тогда можем так
// получение объектов
connection.query("SELECT * FROM users")
          .then(result =>{//тут можно указать так .then(([rows, fields]) =>{
            console.log(result);
          })
          .catch(err =>{
            console.log(err);
          });


//если параметризованный запрос + запрос не дложен возвращать данные
connection.query(sql, user)
          .then(result =>{
//в данном случае result будет содержать следующие поля
fieldCount: 0,
  affectedRows: //мы можем получить количество затронутых операцией (добавленных/ удаленных/обновленных) строк
  insertId: //id доабвленной записи
  info: 
  serverStatus: 
  warningStatus: 





добавление массива
const users = [
  ["Bob", 22],
];
const sql = `INSERT INTO users(name, age) VALUES ?`;
connection.query(sql, [users], function(err, results) {






#pool #пулы #createPool
позволяет создать сразу несколько подключений и использовать их если они свободны вместо того что бы создавать новые
при пулах запросы(и на закрытие тоже=> бд может закрыться до выполнения запросов) выполняются асинхронно
пулы поддерживают Promise

//создание пула из 5 подключений
const mysql = require("mysql2");
 
const pool = mysql.createPool({
    connectionLimit: 5,//количество пулов
    host: "localhost",
    user: "root",
    password: "пароль_от_сервера_mysql", 
    database: "usersdb"
});

//закрытие всех подключений
pool.end(function(err) {
  if (err) {
    return console.log(err.message);
  }
});

//выполнение sql....
pool.query(sql, data, function(err, results) {












#orm #odm
#Sequelize
СУБД - MySQL, Postgres, MariaDB, SQLite, MS SQL Server

npm install --save mysql2
npm install --save sequelize


const Sequelize = require("sequelize");
//1-имя бд, 2-логин, 3- пароль
const sequelize = new Sequelize("usersdb2", "root", "123456", {
  dialect: "mysql",//диалект языка SQL
  host: "localhost",//адрес, по которому запущен сервер
  define: {//это нужно если мы не хотим добавлять столбцы createdAt и updatedAt
    timestamps: false
  }
});


подключения к различным субд https://metanit.com/web/nodejs/9.1.php
Для свойства dialect в зависимости от того, с какой СУБД предстоит работать, могут использоваться следующие значения:
mysql
mariadb
sqlite
postgres
mssql




//определение моделей #define
 если в бд для этой модели нет таблицы, то она будет создаваться. Причем в качестве имени таблицы будет применяться название модели во множественном числе в соответствии с правилами английского языка
//соответствие типов с типами sql можно посмотреть тут http://docs.sequelizejs.com/manual/data-types.html
//поле id указывать не обязательно тк при отсутствии оно будет создано само
//кроме собственно полей модели в таблице по умолчанию будут создаваться два дополнительных поля: createdAt и updatedAt, которые будут иметь тип datetime и будут представлять соответственно время создания и последнего обновления строки в таблице.
const User = sequelize.define("user", {
  id: {
    type: Sequelize.INTEGER,
    autoIncrement: true,
    primaryKey: true,
    allowNull: false//указывает, допускает ли поле отсутствие значение.. true-может иметь null значение
  },
  name: {
    type: Sequelize.STRING,
    allowNull: false
  },
  age: {
    type: Sequelize.INTEGER,
    allowNull: false
  }
});

//еще можно определить так
class User extends Model {}
User.init({
  id: {



//синхронизируем БД с моделями приложения, достраиваем таблицы и тд
sequelize.sync().then(result=>{
//если нужно удалить таблицы которые не соответствуют моделям и создать их наново то  force: true
//sequelize.sync({force: true}).then(result=>{

  console.log(result);
})
.catch(err=> console.log(err));




//добавляем объект в таблицу
User.create({
    name: "Tom",
    age: 35
  }).then(res=>{
const user = {id: res.id, name: res.name, age: res.age};//объект который был добавлен
    console.log(res);
  }).catch(err=>console.log(err));


//получение всех данных, raw-позволяет получить именно данные таблицы, без метаданных
User.findAll({raw:true}).then(users=>{
  console.log(users);
}).catch(err=>console.log(err));


//фильтрация #where
User.findAll({where:{name: "Tom"}, raw: true })
.then(users=>{
  console.log(users);
}).catch(err=>console.log(err));


//#findOne #findByPk
User.findByPk(2)
//User.findOne({where: {name: "Tom"}})
.then(user=>{
    if(!user) return; // если пользователь не найден
    console.log(user.name);
}).catch(err=>console.log(err));




//#update
//age-новое значение, name-критерий выборки
User.update({ age: 36 }, {
  where: {
    name: "Bob"
  }
}).then((res) => {
  console.log(res);
});



//#Удаление #destroy
User.destroy({
  where: {
    name: "Bob"
  }
}).then((res) => {
  console.log(res);
});







Связь один-ко-многим #1 #many
По умолчанию в зависимой таблице (то есть products) будет создаваться дополнительный столбец, который называтся по имени главной модели плюс суффикс "Id", 
то есть в данном случае productId. И через данный столбец строка из companies сможет ссылаться на объект из таблицы products.
будет создаваться с ограничением ON DELETE SET NULL
//после объявления моделей докинуть строки
//company- главная модель
Company.hasMany(Product);
Company.hasMany(Product, { onDelete: "cascade" });//для установки каскадного удаления

sequelize.sync({force:true}).then(()=>{


для добавления зависимых записей, можно явно указать id главной сущности(правила по названию столбцов есть выше)

Company.findByPk(1).then(company=>{
//У главной модели для этого неявно определяется метод по имени createЗАВИСИМАЯ_МОДЕЛЬ
    company.createProduct({name:"iPhone X", price: 300,}).catch(err=>console.log(err));


//получить зависимые данные
Company.findByPk(1).then(company=>{
   
  if(!company) return console.log("Company not found");
  company.getProducts()
  .then(res=>{
    for(let i=0; i<res.length;i++)
      console.log(res[i].name, " - ", company.name);
  })
  .catch(err=>console.log(err));
}).catch(err=>console.log(err));






один-к-одному #hasOne


//при такой связке, дополнительный столбец будет добавлен к Team
Coach.hasOne(Team, { onDelete: "cascade"});
 
sequelize.sync({force:true}).then(()=>{

//Для установки связанных данных применяется метод setНАЗВАНИЕ_МОДЕЛИ()
// добавляем тренера
Coach.create({ name: "Tom Smith"})
.then(coach=>{
    // Добавляем команду
    Team.create({name:"Real Madrid"}).then(team=>{
        // устанавливаем для тренера команду, эта функция будет вызывать команду update=> обе сущности уже должны быть в бд
        coach.setTeam(team).catch(err=>console.log(err));
    });
}).catch(err=>console.log(err));


//получение метод getНАЗВАНИЕ_МОДЕЛИ().
// получаем тренера с id=1
Coach.findByPk(1).then(coach=>{
    if(!coach) return console.log("Coach not found");
    coach.getTeam().then(team=>{
        console.log(coach.name, "-", team.name);
    });
});




//получение всех данных+ связанных #TODO вообще не понял эту грязь
Coach.findAll({
    attributes: ["name"], // включаем столбец name из таблицы coaches
    include: [{
      model: Team,
      attributes: ["name"]  // включаем столбец name из таблицы teams
    }]
  }).then(coaches => {
      for(coach of coaches){
        console.log(coach.name, "-", coach.team.name);
      }
});









многие-ко-многим #belongsToMany


// промежуточная сущность, которая связывает курс и студента
const Enrolment = sequelize.define("enrolment", {
    id: {},grade: { }};

//Первый параметр метода - сущность, с которой надо установить связь. Второй параметр - объект конфигурации связи, который с помощью параметра #through обязательно должен задавать промежуточную сущность, через которую будут связаны обе основные сущности
Student.belongsToMany(Course, {through: Enrolment});
Course.belongsToMany(Student, {through: Enrolment});


// получаем пользователя с именем Tom   метод addИМЯ_МОДЕЛИ()
Student.findOne({where: {name: "Tom"}})
.then(student=>{
    if(!student) return;
     
    // добавим Тому курс по JavaScript
    Course.findOne({where: {name: "JavaScript"}})
        .then(course=>{
            if(!course) return;
            student.addCourse(course, {through:{grade:1}});
    });
});




Получение связанных данных метод getИМЯ_МОДЕЛИs()

//в реальности в данном случае мы получаем не просто курс из таблицы courses, а сводные данные на основании таблицы enrolments
Student.findOne({where: {name: "Tom"}})
.then(student=>{
    if(!student) return;
    student.getCourses().then(courses=>{
        for(course of courses){
            console.log("course:", course.name, "grade:", course.enrolment.grade);
        }
    });
});




Удаление связанных данных
Student.findOne({where: {name: "Tom"}})
.then(student=>{
    if(!student) return;
    student.getCourses().then(courses=>{
        for(course of courses){
            if(course.name==="JavaScript") course.enrolment.destroy();
        }
    });
});














#MVC
контроллеры создаются как бычные модули
определим в каталоге приложения новую папку, которую назовем controllers. Создадим в этой папке новый файл userController.js 

//если не выносим роуты в отдельный модуль
const homeController = require("./controllers/homeController.js");

//если выносим роуты в отдельный модуль
в проект новую папку routes. Затем в этой папке создадим новый файл homeRouter.js и определим в нем следующий код

const express = require("express");
const homeController = require("../controllers/homeController.js");
const homeRouter = express.Router();
 
homeRouter.get("/about", homeController.about);
homeRouter.get("/", homeController.index);
 
module.exports = homeRouter;


в файле обработки подключаем роут
const userRouter = require("./routes/userRouter.js");

app.use("/users", userRouter);










#mutler #multer #file #load #middleware
служит для загрузки файлов на сервер
//работает с express
install multer


<form action="/upload" method="post" enctype="multipart/form-data">
        <label>Файл</label><br>
        <input type="file" name="filedata" /><br><br>
        <input type="submit" value="Send" />
      </form>


const express = require("express");
const multer  = require("multer");




const express = require("express");
const multer  = require("multer");
  
const app = express();
  
app.use(express.static(__dirname));
//dest указывает на путь, по которому будет загружаться файл. В данном случае это папка uploads
//функция single() указывает, что загружаться будет один файл filedata-название с формы
app.use(multer({dest:"uploads"}).single("filedata"));
//single можно ПЕРЕНЕСТИ сюда
//app.post("/upload", upload.single("filedata"), function (req, res, next) {
app.post("/upload", function (req, res, next) {
   
    let filedata = req.file;
    console.log(filedata);
    if(!filedata)
        res.send("Ошибка при загрузке файла");
    else
        res.send("Файл загружен");
});
app.listen(3000);






//перед обработкой всех запросов можно #diskStorage
const storageConfig = multer.diskStorage({//в req есть данные запроса
    destination: (req, file, cb) =>{//определяет место для сохранения загруженных файлов - в данном случае папка "uploads"
        cb(null, "uploads");
    },
    filename: (req, file, cb) =>{//определяет имя для загруженных файлов - в данном случае это непосредственно имя загруженного файла +дата
        cb(null, file.originalname+ "-" + Date.now());
    }
});


// определение фильтра
const fileFilter = (req, file, cb) => {
  
    if(file.mimetype === "image/png" || 
    file.mimetype === "image/jpg"|| 
    file.mimetype === "image/jpeg"){
        cb(null, true);//хотим сохранить файл
    }
    else{
//при получении mutler не устанавливает значение req.file, то есть фактически оно равно undefined
        cb(null, false);//хотим отклонить файл
    }
 }


//без фильтра
app.use(multer({storage:storageConfig}).single("filedata"));
//с фильтром
app.use(multer({storage:storageConfig, fileFilter: fileFilter}).single("filedata"));













































































































































