#todo
#async #await


#TODO
Создание API https://metanit.com/web/nodejs/4.11.php










#JS

new #Error("Ошибка выполнения. randInt больше 5")



#string
#replace  data.replace("{header}", "header")
#substring #TODO
#toString()


let data = `${hour}:${minutes}:${seconds} ${request.method} ${request.url} ${request.get("user-agent")}`;


#Date
let now = new Date();
    let hour = now.getHours();
    let minutes = now.getMinutes();
    let seconds = now.getSeconds();




#node



#директория #direct
глобальная константа __dirname












поднять сервак  -->#server   создать такой файл и в консоли cd путь -> filename


исполняемые файлы должны называться name.js






документация по модулям
https://nodejs.org/api/



#module
require("http");
require("os");   // предоставляет информацию об окружении и операционной системе
fs- работа с файлами
zlib - работа с архивами


//подключенные модули кешируются!!
//объект module представляет ссылку(именно ссылку в привычном понимании, если подключить модуль 2 раза и сохранить в разных переменных, они будут ссылаться на 1 и тот же объект) на текущий модуль, 



можно создать и подключить свой модуль, просто создать файл и 
//в данном случае файл находится в томже каталоге, относительный путь с именем файла (расширение файла необязательно)
const greeting = require("./greeting");

//в данном случае welcome-каталог в котором есть файл index.js  , при таком подключении будет вызываться именно он
const welcome = require("./welcome");







создание своего файла модуля
//переменная будет доступна только в данном модуле
let currentDate = new Date();

//вот так можно сделать переменную видимой вне модуля (Объект module.exports - это то, что возвращает функция require() при получении модуля)
//а его свойство exports определяет все свойства и методы модуля, 
//которые могут быть экспортированы и использованы в других модулях
module.exports.date = currentDate;
 
module.exports.getMessage = function(name){
    return currentDate.getHours();
}

//можно и так, в таком случае просто вернет строку
module.exports = "Доброе утро";



















#class
создание класс в модуле

function User(name){
     
    this.name = name;
    this.displayInfo = function(){
        console.log("Имя: ${this.name}");
    }
}
//устанавливаем функцию вне класса
User.prototype.sayHi = function() {
    console.log(`Привет, меня зовут ${this.name}`);
};
 
module.exports = User;


---
const User = require("./user.js");
 
let eugene = new User("Eugene", 32);
eugene.sayHi();










#global
#window или document недоступны тк работает на серваке
но есть другие global переменные
доступные #глобальные объекты https://nodejs.org/api/globals.html

для получения установки глобальной переменной
global.date = currentDate;
получить можно без global, просто через date

global.console.log(), и просто console.log()
















#process.argv
передать параметры в приложение
1 параметр всегда указывает на путь к файлу node.exe  который вызывает приложение
2 параметр всегда указывает на путь к файлу приложения, который выполняется

для передачи параметров вызывается так, все аргументы приводятся к строкам
node app.js Tom 23

let nodePath = process.argv[0];
let appPath = process.argv[1];
let name = process.argv[2];




можно создать команды по умолчанию
в package.json добавить
"scripts" : {
    "start" : "node app.js",
    "dev" : "node app.js Tom 26"
  }
}

//для активации данных команд если имя зарезервировано(start)
npm start
//если свое имя то
npm run [название_команды]
//в обоих случаях будет запущен файл app и при DEV будут переданы параметры














#npm #install
Node Package Manager
//если его необходимо обновить
npm install npm@latest -g
//узнать текущую версию 
npm -v

//установка модулей
перейти в папку проекта
npm install express

//флаг #global
//позволяет установить зависимость nodemon глобально для всех проектов на данной локальной машине
npm install nodemon -g


#package.json  #зависимости #конфиг
файл для управления модулями
name-название приложения
дополнительные секции --- https://docs.npmjs.com/creating-a-package-json-file
{
  "name": "modulesapp",
  "version": "1.0.0"
}

в таком случае(при наличии файла)
устанавливать надо так #install
флаг --save  - указывает что сохранить надо в файле package
npm install express --save


в файле изменения будут записываться так
{
  "name": "modulesapp",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.14.0"
  }
}


если мы определили все необходимые пакеты(или они сами добавили при установке) в файле конфигурации то
мы можем их удалить, а при необходимости докачать все сразу такой командой
npm install


#devDependencies 
зависимости которые добавляются только на этап разработки #save-dev
устанавливать так
npm install jasmine-node --save-dev

и так сохранится в файл
},
  "devDependencies": {
    "jasmine-node": "^1.14.5"
  }


#uninstall
//удаление пакетов
//просто сам пакет
npm uninstall express
//пакет+ информация из файла конфигурации
npm uninstall express --save



ТЕОРИЯ
правила названий версий пакетов
При определении версии пакета применяется семантическое версионирование. Номер версии, как правило, задается в следующем формате "major.minor.patch". Если в приложении или пакете обнаружен какой-то баг и он исправляется, то увеличивается на единицу число "patch". Если в пакет добавляется какая-то новая функциональность, которая совместима с предыдущей версией пакета, то это небольшое изменение, и увеличивается число "minor". Если же в пакет вносятся какие-то большие изменения, которые несовместимы с предыдущей версией, то увеличивается число "major".








#nodemon
если необходимо внести изменения в проект без явной перезагрузки проекта(при изменении кода, перезагрузится сам)
npm install nodemon -g

запускать приложение так
nodemon app.js






#callback
#throw
//такая структура
function (err, data){
    if(err) throw err;
}








#async #асинхронность 
//достигается с помощью #setTimeout  (функция которую туда передаем станосится в очередь и выполняется асинхронно)
// структура функции желательно должна быть именно такой(данные, колбэк).. структура колбэка (ошибка, данные)
function display(data, callback){
    setTimeout(function(){
        callback(err, data);
    }, 0);
}
display("Обработка данных...", function (err, data){
 
    if(err) throw err;
    console.log(data);
});










#fs #file
необходимо подключить модуль "fs"
//что бы считать в синхронном варианте
let fileContent = fs.#readFileSync("hello.txt", "utf8");
//путь файла относительно файла приложения app.js ... функция вернет текст

//в асинхронном.. колбек выполнится после завершения считывания
fs.#readFile("hello.txt", "utf8", function(error,data){ });



запись в файл
//данные функции перезаписывают файл
//синхронный вариант
fs.#writeFileSync("hello.txt", "Привет ми ми ми!")
//асинхронный вариант, сюда тоже можно засунуть колбэк 3 параметром
fs.#writeFile("hello.txt", "Привет МИГ-29!")



ДОзапись в файл

fs.#appendFile()/fs.#appendFileSync():

удаление файла
//синхронное
fs.unlinkSync("hello.txt")

//асинхронное
fs.unlink("hello.txt", (err) => {
  if (err) console.log(err); // если возникла ошибка    
  else console.log("hello.txt was deleted");
});
















#stream #потоки 
#createWriteStream #write #createReadStream

const fs = require("fs");
 
//открывает файл, если файла нет то создает
let writeableStream = fs.createWriteStream("hello.txt");
writeableStream.write("Привет мир!");
writeableStream.write("Продолжение записи \n");
writeableStream.end("Завершение записи");
let readableStream = fs.createReadStream("hello.txt", "utf8");
 
//Сам поток разбивается на ряд кусков или чанков (chunk). И при считывании каждого такого куска, возникает событие data. С помощью метода on() мы можем подписаться на это событие и вывести каждый кусок данных на консоль
readableStream.on("data", function(chunk){ 
    console.log(chunk);
});





проверить существование файла
//2 параметр-проверяем права на чтение из файла
fs.access(filePath, fs.constants.R_OK, err => {
       
        if(err){
             // если произошла ошибка - файла нет
        }
        else{
        }
      });









#Pipe
 это канал, который связывает поток для чтения и поток для записи и позволяет сразу считать из потока чтения в поток записи


let readableStream = fs.createReadStream("hello.txt", "utf8");
let writeableStream = fs.createWriteStream("some.txt");

//это можно переписать 
readableStream.on("data", function(chunk){
    writeableStream.write(chunk);
});
//так
readableStream.pipe(writeableStream);

const zlib = require("zlib");//#zlib #zip #gz
let gzip = zlib.createGzip();
Каждый метод pipe() в цепочке вызовов возвращает поток для чтения, к которому опять же можно применить метод pipe() для записи в другой поток
readableStream.pipe(gzip).pipe(writeableStream);









для отправки файла клиенту(#html страницы например)
response.setHeader("Content-Type", "text/html");
//response.writeHead(200,{"Content-Type":"application/msword"});
//можно через пайп и потоки
fs.createReadStream(filePath).pipe(response);
//можно просто считать все что в файле и закинуть в поток обычной записью(write)



если надо отправлять не статичные файлы то

//сам файл
<body>
    <h1>{header}</h1>
    <p>{message}</p>
</body>

fs.readFile("index.html", "utf8", function(error, data){
                 
        let message = "Изучаем Node.js"; 
        data = data.replace("{header}", header).replace("{message}", message);
        response.end(data);
    })
















#EventEmitter #Emitter #Event 



const Emitter = require("events");
let emitter = new Emitter();
let eventName = "greet";
//связываем функцию и обработчик, можно привязать несколько обработчиков
emitter.on(eventName, function(){
    console.log("Hello all!");
});
 
emitter.on(eventName, function(){
    console.log("Привет!");
});
 
//вызываем событие
emitter.emit(eventName);
//передадим параметр в обработчик, в данном случае обработчик надо переписать так что бы он принимал параметр
emitter.emit(eventName, "Привет пир!");




#наследование от класса события #util

const util = require("util");
const EventEmitter = require("events");
 
//---
//класс наследник от EventEmitter
function User(){
}
//"наследуем"
util.inherits(User, EventEmitter);


//добавляем в класс метод который будет вызывать событие( emit-наследуется)
User.prototype.sayHi = function(data){
    this.emit(eventName, data);
}
//---
let eventName = "greet";
let user = new User();
// добавляем к объекту user обработку события "greet"
user.on(eventName, function(data){
    console.log(data);
});
 
user.sayHi("Мне нужна твоя одежда...");


то что выше находится между //---, можно переписать проще благодаря ES6, тогда строку можно убрать require("util");

class User extends EventEmitter {
    sayHi(data) {
        this.emit(eventName, data);
    }
}









#server
//получаем модуль http, который необходим для создания сервера.
const http = require("http");
//создается новый сервер для прослушивания входящих подключений и обработки запросов
http.createServer(
//request-поток который хранит всю информацию о запросе, 
//response-поток который используется для отправки ответа
function(request,response){

//поддержка русских букв #utf
response.writeHead(200, {"Content-type": "text/plain; charset=utf-8;"})

     //отправляется ответ
    response.end("Hello NodeJS!");
     
//Чтобы сервер начал прослушивать входящие подключения -listen
}).listen(3000, "127.0.0.1",function(){
    console.log("Сервер начал прослушивание запросов на порту 3000");
});//но вроде можно и так .listen(3000);



#Request
//request-поток который хранит всю информацию о запросе,
//объект класса http.#IncomingMessage
основные свойства
#headers: возвращает заголовки запроса... request.headers["user-agent"]
#method: тип запроса (GET, POST, DELETE, PUT)
#url: представляет запрошенный адрес



#Response
//поток который используется для отправки ответа
//объект класса http.#ServerResponse

основные методы
#statusCode: устанавливает статусный код ответа #404
#statusMessage: устанавливает сообщение, отправляемое вместе со статусным кодом
#setHeader(name, value): добавляет в ответ один заголовок
#write: пишет в поток ответа некоторое содержимое
#writeHead: добавляет в ответ статусный код и набор заголовков
#end: сигнализирует серверу, что заголовки и тело ответа установлены, в итоге ответ отсылается клиента. Данный метод должен вызываться в каждом запросе.








#Переадресация #redirect


response.statusCode = 302; // временная переадресация
        // на адрес localhost:3000/newpage
        response.setHeader("Location", "/newpage");
response.end();















#Express



файл должен выглядеть так

// подключение express
const express = require("express");
// создаем объект приложения
const app = express();
// определяем обработчик для маршрута "/"
app.get("/", function(request, response){
     
    // отправляем ответ #send
//В качестве параметра эта функция может принимать объект Buffer, строку, в том числе с html-кодом, объект javascript или массив
    response.send("<h2>Привет Express!</h2>");

//отправка #файла #file #sendFile, в данную функцию необходимо передать абсолютный путь
response.sendFile(__dirname + "/index.html");
});
// начинаем прослушивать подключения на 3000 порту
app.listen(3000);





для обработки определенных типов запросов
должны от более частных к общим
В качестве первого параметра эти функции могут принимать шаблон адреса, запрос по которому будет обрабатываться. Второй параметр функций представляет функцию, которая будет обрабатывать запрос по совпавшему с шаблоном адресу
#use
#get
#post
#put
#delete
app.get("/", function(request, response){});

указать параметры маршрута можно через :
app.get("/categories/:categoryId/products/:productId"

можно использовать регулярки
? указывает, что предыдущий символ может встречаться 1 раз или отсутствовать
+ указывает, что предыдущий символ может встречаться 1 и более раз
* указывает, что на месте данного символа может находиться любое количество символов
группировка - "/book(.html)?"

можно напрямою указать регулярку
app.get(/.*(\.)html$/,



#Переадресация #redirect

response.redirect("https://site.com")//тоже самое что и
response.redirect(302,"https://site.com")


//с ресурса "/home" на ресурс "/about" -- на http://localhost:3000/about
app.use("/home",function (request, response) {
  response.redirect("about")
//на http://localhost:3000/home/about
app.use("/home/bar",function (request, response) {
  response.redirect("about")
//если нужна переадресация относительно корня то нужно добавить \
 response.redirect("/about")
//с http://localhost:3000/home/foo/bar на http://localhost:3000/home/foo/about
response.redirect("./about")
//с http://localhost:3000/home/foo/bar на http://localhost:3000/home/about
response.redirect("../about")
//с http://localhost:3000/home/foo/bar на http://localhost:3000/home/foo
response.redirect(".")
//с http://localhost:3000/home/foo/bar на http://localhost:3000/home
 response.redirect("..")















#middleware #use




const app = express();
//next: следующая в конвейере обработки функция
app.use(function(request, response, next){  
    console.log("Middleware 1");
    next();
});
app.use(function(request, response, next){
//если вызвать send то дальше вызова следующиего next не будет, и сама обработка запроса закончится(это и будет финальный результат независимо от того что и где еще определено)
 response.send("Middleware 2");
});
app.use("/about", function(request, response, next){});//устанавливаем обработчик для определенного маршрута
app.get("/", function(request, response){     
    console.log("Route /");
    response.send("Hello");
});





#status #404

response.sendStatus(404)
//если надо отправть свой текст
response.status(404).send("Ресурс не найден");




#static #file
//express.static()

необходимо поместить до остальных midleware
app.use(express.static(__dirname + "/public"));
//при таком подключении, доступ к файлу по запросу http://localhost:3000/static/about.html
app.use("/static", express.static(__dirname + "/public"));







#params

то что после & это параметры строки запроса, то что до это параметры маршрута
localhost:3000/about/user?id=3&name=Tome


#get #query
получаем параметры из строки запроса
let id = request.query.id;//id-название параметра
    let userName = request.query.name;//если name-массив то получить его точно также, строка запроса такая же как в c#

получить сложный объект точно также, а передать его через ?user[id]=7&user[name]=nms






получение параметров маршрута
задаются через :
app.get("/products/:productId", function (request, response) {
  response.send("productId: " + request.params["productId"])
});
app.get("/categories/:categoryId/products/:productId"







#form #post #get
для того что бы получать значения из формы нужен #body-parser
npm install body-parser --save



const bodyParser = require("body-parser");
  
const app = express();
  
// создаем парсер для данных application/x-www-form-urlencoded
//extended: false указывает, что объект - результат парсинга будет представлять набор пар ключ-значение, а каждое значение может быть представлено в виде строки или массива
const urlencodedParser = bodyParser.urlencoded({extended: false});
 
app.get("/register", urlencodedParser, function (request, response) {
    response.sendFile(__dirname + "/register.html");
});
app.post("/register", urlencodedParser, function (request, response) {
//проверяем передана ли форма
    if(!request.body) return response.sendStatus(400);
    console.log(request.body);
    response.send("${request.body.userName} - ${request.body.userAge}");
});







#json #form

// создаем парсер для данных в формате json
const jsonParser = express.json();
  
app.post("/user", jsonParser, function (request, response) {
    console.log(request.body);
    if(!request.body) return response.sendStatus(400);
//работа также как если бы просто форму принимали, тоесть
request.body.userName;

     //устанавливает для заголовка "Content-Type" значение "application/json", серилизует данные в json с помощью функции JSON.stringify() и затем отправляет данные с помощью response.send()
    response.json(request.body); // отправляем пришедший ответ обратно
});













#Router #routing

//вот такую штуку, можно переписать
app.use("/products/create",function (request, response) {
  response.send("Добавление товара");
});
app.use("/products/:id",function (request, response) {
  response.send(`Товар ${request.params.id}`);
});

//вот так

// определяем Router
const productRouter = express.Router();
 
// определяем маршруты и их обработчики внутри роутера
productRouter.use("/create", function(request, response){
  response.send("Добавление товара");
});
productRouter.use("/:id", function(request, response){
  response.send(`Товар ${request.params.id}`);
});
// сопотавляем роутер с конечной точкой "/products"
app.use("/products", productRouter);














#views 


---------------------#hbs #Handlebars ---------------------------------------
npm install hbs --save
Для хранения представлений определим в проекте папку views. Затем в нее добавим новый файл contact.hbs. hbs - это расширение по умолчанию для представлений, которые обрабатываются движком Handlebars
//#render

в файле так помечаем динамические куски
<title>{{title}}</title>
{{#if emailsVisible}}
        <h3>Электронные адреса</h3>
        <ul>
            {{#each emails}}
                <li>{{this}}</li>
            {{/each}}
        </ul>
    {{/if}}





//устанавливаем движок представлений
app.set("view engine", "hbs");
//устанавливаем путь, это не обязательно, стандартно используется папка views
app.set("views", "templates"); // установка пути к представлениям 


app.use("/contact", function(request, response){
     //страница без параметров
    response.render("contact.hbs");
//с параметрами
response.render("contact.hbs", {
        title: "Мои контакты",
        });
});








#partial

views/partials новый файл menu.hbs

вот так рендерится частичное представление которое находится в файле menu.hbs
<body>{{> menu}}</body>

const hbs = require("hbs");
hbs.registerPartials(__dirname + "/views/partials");






#Layout #лаяут

Создадим в проекте в папке views новый каталог layouts и определим в нем файл layout.hbs


<!DOCTYPE html>
<html>
<head>
    <title>{{title}}</title>
    <meta charset="utf-8" />
</head>
<body>
    {{> menu}}
      
    {{{body}}}
      
    {{> footer}}
</body>
<html>


const express = require("express");
const expressHbs = require("express-handlebars");
const hbs = require("hbs");
const app = express();
  
// устанавливаем настройки для файлов layout
app.engine("hbs", expressHbs(
    {
        layoutsDir: "views/layouts", //относительный путь
        defaultLayout: "layout",//название файла
        extname: "hbs"
    }
))










#Хелперы  #helpers #registerHelper


hbs.registerHelper("getTime", function(){
     
    var myDate = new Date();
    var hour = myDate.getHours();
    return "Текущее время: " + hour;
});


hbs.registerHelper("createStringList", function(array){
     
    var result="";
    for(var i=0; i<array.length; i++){
        result +="<li>" + array[i] + "</li>";
    }
    return new hbs.SafeString("<ul>" + result + "</ul>");
});




вызов хэлпера
<div>{{getTime}}</div>
вызов с параметрами
 <div>{{createStringList fruit}}</div>




------------------КОНЕЦ---#hbs #Handlebars ---------------------------------------

------------------#EJS---------------------------------------

npm install ejs --save



app.set("view engine", "ejs");
 
app.use("/contact", function(request, response){
     //для файла contact.ejs
    response.render("contact", {
        title: "Мои контакты"
    });
});


в html
<title><%=title %></title>
<% if(emailsVisible) {%>
        <h3>Электронные адреса</h3>
        <ul>
            <% for(var i=0; i<emails.length;i++) {%>
                <li><%=emails[i] %></li>
            <%} %>
        </ul>
    <% }else {%>
        <h3>Электронный адрес отсутствует</h3>
    <%} %>






#Частичные представления #partial
определим в папке views каталог partials
#include

подключение частичного представления
<%- include("partials/menu.ejs") %>




------------------КОНЕЦ---#EJS---------------------------------------




---------------------#Pug---------------------------------------
файлы назваются так footer.pug

npm install pug --save



app.set("view engine", "pug");

в html
<title>#{title}</title>
//тут роляют только отступы как в питоне
if emailsVisible
        <h3>Электронные адреса</h3>
	h3 Электронные адреса ТАК ТОЖЕ МОЖНО
        <ul>
            each email in emails
                <li>#{email}</li>
		li=email
        </ul>
    else
        <h3>Электроннный адрес отсутствует</h3>


- var n = 0;
ul
  while n < 4
    li= n++

ul
  each val, index in {1:'one',2:'two',3:'three'}
    li= index + ': ' + val








#partial #частичные

   include footer.pug




#layout 

layout.pug

<body>
    block content   //определяем блок в который будут вставляться некоторые данные - указываем название блока
    include footer.pug
</body>



для применения мастер страницы, на другой странице пишем (путь к файлу)
extends layout.pug

и определяем блоки
block title
    <title>#{title}</title>
 
block content
      
    <h1>#{title} в Pug</h1>


------------------КОНЕЦ---#Pug---------------------------------------
















































