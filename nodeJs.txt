#todo
#async #await


#TODO
Создание API https://metanit.com/web/nodejs/4.11.php










#JS

new #Error("Ошибка выполнения. randInt больше 5")



#string
#replace  data.replace("{header}", "header")
#substring #TODO
#toString()


let data = `${hour}:${minutes}:${seconds} ${request.method} ${request.url} ${request.get("user-agent")}`;


#Date
let now = new Date();
    let hour = now.getHours();
    let minutes = now.getMinutes();
    let seconds = now.getSeconds();




#node



#директория #direct
глобальная константа __dirname












поднять сервак  -->#server   создать такой файл и в консоли cd путь -> filename


исполняемые файлы должны называться name.js






документация по модулям
https://nodejs.org/api/



#module
require("http");
require("os");   // предоставляет информацию об окружении и операционной системе
fs- работа с файлами
zlib - работа с архивами


//подключенные модули кешируются!!
//объект module представляет ссылку(именно ссылку в привычном понимании, если подключить модуль 2 раза и сохранить в разных переменных, они будут ссылаться на 1 и тот же объект) на текущий модуль, 



можно создать и подключить свой модуль, просто создать файл и 
//в данном случае файл находится в томже каталоге, относительный путь с именем файла (расширение файла необязательно)
const greeting = require("./greeting");

//в данном случае welcome-каталог в котором есть файл index.js  , при таком подключении будет вызываться именно он
const welcome = require("./welcome");







создание своего файла модуля
//переменная будет доступна только в данном модуле
let currentDate = new Date();

//вот так можно сделать переменную видимой вне модуля (Объект module.exports - это то, что возвращает функция require() при получении модуля)
//а его свойство exports определяет все свойства и методы модуля, 
//которые могут быть экспортированы и использованы в других модулях
module.exports.date = currentDate;
 
module.exports.getMessage = function(name){
    return currentDate.getHours();
}

//можно и так, в таком случае просто вернет строку
module.exports = "Доброе утро";



















#class
создание класс в модуле

function User(name){
     
    this.name = name;
    this.displayInfo = function(){
        console.log("Имя: ${this.name}");
    }
}
//устанавливаем функцию вне класса
User.prototype.sayHi = function() {
    console.log(`Привет, меня зовут ${this.name}`);
};
 
module.exports = User;


---
const User = require("./user.js");
 
let eugene = new User("Eugene", 32);
eugene.sayHi();










#global
#window или document недоступны тк работает на серваке
но есть другие global переменные
доступные #глобальные объекты https://nodejs.org/api/globals.html

для получения установки глобальной переменной
global.date = currentDate;
получить можно без global, просто через date

global.console.log(), и просто console.log()

//также доступ в любом месте приложения с помощью express
app.locals.collection














#process.argv
передать параметры в приложение
1 параметр всегда указывает на путь к файлу node.exe  который вызывает приложение
2 параметр всегда указывает на путь к файлу приложения, который выполняется

для передачи параметров вызывается так, все аргументы приводятся к строкам
node app.js Tom 23

let nodePath = process.argv[0];
let appPath = process.argv[1];
let name = process.argv[2];




можно создать команды по умолчанию
в package.json добавить
"scripts" : {
    "start" : "node app.js",
    "dev" : "node app.js Tom 26"
  }
}

//для активации данных команд если имя зарезервировано(start)
npm start
//если свое имя то
npm run [название_команды]
//в обоих случаях будет запущен файл app и при DEV будут переданы параметры














#npm #install
Node Package Manager
//если его необходимо обновить
npm install npm@latest -g
//узнать текущую версию 
npm -v

//установка модулей
перейти в папку проекта
npm install express

//флаг #global
//позволяет установить зависимость nodemon глобально для всех проектов на данной локальной машине
npm install nodemon -g


#package.json  #зависимости #конфиг
файл для управления модулями
name-название приложения
дополнительные секции --- https://docs.npmjs.com/creating-a-package-json-file
{
  "name": "modulesapp",
  "version": "1.0.0"
}

в таком случае(при наличии файла)
устанавливать надо так #install
флаг --save  - указывает что сохранить надо в файле package
npm install express --save


в файле изменения будут записываться так
{
  "name": "modulesapp",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.14.0"
  }
}


если мы определили все необходимые пакеты(или они сами добавили при установке) в файле конфигурации то
мы можем их удалить, а при необходимости докачать все сразу такой командой
npm install


#devDependencies 
зависимости которые добавляются только на этап разработки #save-dev
устанавливать так
npm install jasmine-node --save-dev

и так сохранится в файл
},
  "devDependencies": {
    "jasmine-node": "^1.14.5"
  }


#uninstall
//удаление пакетов
//просто сам пакет
npm uninstall express
//пакет+ информация из файла конфигурации
npm uninstall express --save



ТЕОРИЯ
правила названий версий пакетов
При определении версии пакета применяется семантическое версионирование. Номер версии, как правило, задается в следующем формате "major.minor.patch". Если в приложении или пакете обнаружен какой-то баг и он исправляется, то увеличивается на единицу число "patch". Если в пакет добавляется какая-то новая функциональность, которая совместима с предыдущей версией пакета, то это небольшое изменение, и увеличивается число "minor". Если же в пакет вносятся какие-то большие изменения, которые несовместимы с предыдущей версией, то увеличивается число "major".








#nodemon
если необходимо внести изменения в проект без явной перезагрузки проекта(при изменении кода, перезагрузится сам)
npm install nodemon -g

запускать приложение так
nodemon app.js






#callback
#throw
//такая структура
function (err, data){
    if(err) throw err;
}








#async #асинхронность 
//достигается с помощью #setTimeout  (функция которую туда передаем станосится в очередь и выполняется асинхронно)
// структура функции желательно должна быть именно такой(данные, колбэк).. структура колбэка (ошибка, данные)
function display(data, callback){
    setTimeout(function(){
        callback(err, data);
    }, 0);
}
display("Обработка данных...", function (err, data){
 
    if(err) throw err;
    console.log(data);
});










#fs #file
необходимо подключить модуль "fs"
//что бы считать в синхронном варианте
let fileContent = fs.#readFileSync("hello.txt", "utf8");
//путь файла относительно файла приложения app.js ... функция вернет текст

//в асинхронном.. колбек выполнится после завершения считывания
fs.#readFile("hello.txt", "utf8", function(error,data){ });



запись в файл
//данные функции перезаписывают файл
//синхронный вариант
fs.#writeFileSync("hello.txt", "Привет ми ми ми!")
//асинхронный вариант, сюда тоже можно засунуть колбэк 3 параметром
fs.#writeFile("hello.txt", "Привет МИГ-29!")



ДОзапись в файл

fs.#appendFile()/fs.#appendFileSync():

удаление файла
//синхронное
fs.unlinkSync("hello.txt")

//асинхронное
fs.unlink("hello.txt", (err) => {
  if (err) console.log(err); // если возникла ошибка    
  else console.log("hello.txt was deleted");
});
















#stream #потоки 
#createWriteStream #write #createReadStream

const fs = require("fs");
 
//открывает файл, если файла нет то создает
let writeableStream = fs.createWriteStream("hello.txt");
writeableStream.write("Привет мир!");
writeableStream.write("Продолжение записи \n");
writeableStream.end("Завершение записи");
let readableStream = fs.createReadStream("hello.txt", "utf8");
 
//Сам поток разбивается на ряд кусков или чанков (chunk). И при считывании каждого такого куска, возникает событие data. С помощью метода on() мы можем подписаться на это событие и вывести каждый кусок данных на консоль
readableStream.on("data", function(chunk){ 
    console.log(chunk);
});





проверить существование файла
//2 параметр-проверяем права на чтение из файла
fs.access(filePath, fs.constants.R_OK, err => {
       
        if(err){
             // если произошла ошибка - файла нет
        }
        else{
        }
      });









#Pipe
 это канал, который связывает поток для чтения и поток для записи и позволяет сразу считать из потока чтения в поток записи


let readableStream = fs.createReadStream("hello.txt", "utf8");
let writeableStream = fs.createWriteStream("some.txt");

//это можно переписать 
readableStream.on("data", function(chunk){
    writeableStream.write(chunk);
});
//так
readableStream.pipe(writeableStream);

const zlib = require("zlib");//#zlib #zip #gz
let gzip = zlib.createGzip();
Каждый метод pipe() в цепочке вызовов возвращает поток для чтения, к которому опять же можно применить метод pipe() для записи в другой поток
readableStream.pipe(gzip).pipe(writeableStream);









для отправки файла клиенту(#html страницы например)
response.setHeader("Content-Type", "text/html");
//response.writeHead(200,{"Content-Type":"application/msword"});
//можно через пайп и потоки
fs.createReadStream(filePath).pipe(response);
//можно просто считать все что в файле и закинуть в поток обычной записью(write)



если надо отправлять не статичные файлы то

//сам файл
<body>
    <h1>{header}</h1>
    <p>{message}</p>
</body>

fs.readFile("index.html", "utf8", function(error, data){
                 
        let message = "Изучаем Node.js"; 
        data = data.replace("{header}", header).replace("{message}", message);
        response.end(data);
    })
















#EventEmitter #Emitter #Event 



const Emitter = require("events");
let emitter = new Emitter();
let eventName = "greet";
//связываем функцию и обработчик, можно привязать несколько обработчиков
emitter.on(eventName, function(){
    console.log("Hello all!");
});
 
emitter.on(eventName, function(){
    console.log("Привет!");
});
 
//вызываем событие
emitter.emit(eventName);
//передадим параметр в обработчик, в данном случае обработчик надо переписать так что бы он принимал параметр
emitter.emit(eventName, "Привет пир!");




#наследование от класса события #util

const util = require("util");
const EventEmitter = require("events");
 
//---
//класс наследник от EventEmitter
function User(){
}
//"наследуем"
util.inherits(User, EventEmitter);


//добавляем в класс метод который будет вызывать событие( emit-наследуется)
User.prototype.sayHi = function(data){
    this.emit(eventName, data);
}
//---
let eventName = "greet";
let user = new User();
// добавляем к объекту user обработку события "greet"
user.on(eventName, function(data){
    console.log(data);
});
 
user.sayHi("Мне нужна твоя одежда...");


то что выше находится между //---, можно переписать проще благодаря ES6, тогда строку можно убрать require("util");

class User extends EventEmitter {
    sayHi(data) {
        this.emit(eventName, data);
    }
}









#server
//получаем модуль http, который необходим для создания сервера.
const http = require("http");
//создается новый сервер для прослушивания входящих подключений и обработки запросов
http.createServer(
//request-поток который хранит всю информацию о запросе, 
//response-поток который используется для отправки ответа
function(request,response){

//поддержка русских букв #utf
response.writeHead(200, {"Content-type": "text/plain; charset=utf-8;"})

     //отправляется ответ
    response.end("Hello NodeJS!");
     
//Чтобы сервер начал прослушивать входящие подключения -listen
}).listen(3000, "127.0.0.1",function(){
    console.log("Сервер начал прослушивание запросов на порту 3000");
});//но вроде можно и так .listen(3000);



#Request
//request-поток который хранит всю информацию о запросе,
//объект класса http.#IncomingMessage
основные свойства
#headers: возвращает заголовки запроса... request.headers["user-agent"]
#method: тип запроса (GET, POST, DELETE, PUT)
#url: представляет запрошенный адрес



#Response
//поток который используется для отправки ответа
//объект класса http.#ServerResponse

основные методы
#statusCode: устанавливает статусный код ответа #404
#statusMessage: устанавливает сообщение, отправляемое вместе со статусным кодом
#setHeader(name, value): добавляет в ответ один заголовок
#write: пишет в поток ответа некоторое содержимое
#writeHead: добавляет в ответ статусный код и набор заголовков
#end: сигнализирует серверу, что заголовки и тело ответа установлены, в итоге ответ отсылается клиента. Данный метод должен вызываться в каждом запросе.








#Переадресация #redirect


response.statusCode = 302; // временная переадресация
        // на адрес localhost:3000/newpage
        response.setHeader("Location", "/newpage");
response.end();















#Express



файл должен выглядеть так

// подключение express
const express = require("express");
// создаем объект приложения
const app = express();
// определяем обработчик для маршрута "/"
app.get("/", function(request, response){
     
    // отправляем ответ #send
//В качестве параметра эта функция может принимать объект Buffer, строку, в том числе с html-кодом, объект javascript или массив
    response.send("<h2>Привет Express!</h2>");

//отправка #файла #file #sendFile, в данную функцию необходимо передать абсолютный путь
response.sendFile(__dirname + "/index.html");
});
// начинаем прослушивать подключения на 3000 порту
app.listen(3000);





для обработки определенных типов запросов
должны от более частных к общим
В качестве первого параметра эти функции могут принимать шаблон адреса, запрос по которому будет обрабатываться. Второй параметр функций представляет функцию, которая будет обрабатывать запрос по совпавшему с шаблоном адресу
#use
#get
#post
#put
#delete
app.get("/", function(request, response){});

указать параметры маршрута можно через :
app.get("/categories/:categoryId/products/:productId"

можно использовать регулярки
? указывает, что предыдущий символ может встречаться 1 раз или отсутствовать
+ указывает, что предыдущий символ может встречаться 1 и более раз
* указывает, что на месте данного символа может находиться любое количество символов
группировка - "/book(.html)?"

можно напрямою указать регулярку
app.get(/.*(\.)html$/,



#Переадресация #redirect

response.redirect("https://site.com")//тоже самое что и
response.redirect(302,"https://site.com")


//с ресурса "/home" на ресурс "/about" -- на http://localhost:3000/about
app.use("/home",function (request, response) {
  response.redirect("about")
//на http://localhost:3000/home/about
app.use("/home/bar",function (request, response) {
  response.redirect("about")
//если нужна переадресация относительно корня то нужно добавить \
 response.redirect("/about")
//с http://localhost:3000/home/foo/bar на http://localhost:3000/home/foo/about
response.redirect("./about")
//с http://localhost:3000/home/foo/bar на http://localhost:3000/home/about
response.redirect("../about")
//с http://localhost:3000/home/foo/bar на http://localhost:3000/home/foo
response.redirect(".")
//с http://localhost:3000/home/foo/bar на http://localhost:3000/home
 response.redirect("..")















#middleware #use




const app = express();
//next: следующая в конвейере обработки функция
app.use(function(request, response, next){  
    console.log("Middleware 1");
    next();
});
app.use(function(request, response, next){
//если вызвать send то дальше вызова следующиего next не будет, и сама обработка запроса закончится(это и будет финальный результат независимо от того что и где еще определено)
 response.send("Middleware 2");
});
app.use("/about", function(request, response, next){});//устанавливаем обработчик для определенного маршрута
app.get("/", function(request, response){     
    console.log("Route /");
    response.send("Hello");
});





#status #404

response.sendStatus(404)
//если надо отправть свой текст
response.status(404).send("Ресурс не найден");




#static #file
//express.static()

необходимо поместить до остальных midleware
app.use(express.static(__dirname + "/public"));
//при таком подключении, доступ к файлу по запросу http://localhost:3000/static/about.html
app.use("/static", express.static(__dirname + "/public"));







#params

то что после & это параметры строки запроса, то что до это параметры маршрута
localhost:3000/about/user?id=3&name=Tome


#get #query
получаем параметры из строки запроса
let id = request.query.id;//id-название параметра
    let userName = request.query.name;//если name-массив то получить его точно также, строка запроса такая же как в c#

получить сложный объект точно также, а передать его через ?user[id]=7&user[name]=nms






получение параметров маршрута
задаются через :
app.get("/products/:productId", function (request, response) {
  response.send("productId: " + request.params["productId"])
});
app.get("/categories/:categoryId/products/:productId"







#form #post #get
для того что бы получать значения из формы нужен #body-parser
npm install body-parser --save



const bodyParser = require("body-parser");
  
const app = express();
  
// создаем парсер для данных application/x-www-form-urlencoded
//extended: false указывает, что объект - результат парсинга будет представлять набор пар ключ-значение, а каждое значение может быть представлено в виде строки или массива
const urlencodedParser = bodyParser.urlencoded({extended: false});
 
app.get("/register", urlencodedParser, function (request, response) {
    response.sendFile(__dirname + "/register.html");
});
app.post("/register", urlencodedParser, function (request, response) {
//проверяем передана ли форма
    if(!request.body) return response.sendStatus(400);
    console.log(request.body);
    response.send("${request.body.userName} - ${request.body.userAge}");
});







#json #form

// создаем парсер для данных в формате json
const jsonParser = express.json();
  
app.post("/user", jsonParser, function (request, response) {
    console.log(request.body);
    if(!request.body) return response.sendStatus(400);
//работа также как если бы просто форму принимали, тоесть
request.body.userName;

     //устанавливает для заголовка "Content-Type" значение "application/json", серилизует данные в json с помощью функции JSON.stringify() и затем отправляет данные с помощью response.send()
    response.json(request.body); // отправляем пришедший ответ обратно
});













#Router #routing

//вот такую штуку, можно переписать
app.use("/products/create",function (request, response) {
  response.send("Добавление товара");
});
app.use("/products/:id",function (request, response) {
  response.send(`Товар ${request.params.id}`);
});

//вот так

// определяем Router
const productRouter = express.Router();
 
// определяем маршруты и их обработчики внутри роутера
productRouter.use("/create", function(request, response){
  response.send("Добавление товара");
});
productRouter.use("/:id", function(request, response){
  response.send(`Товар ${request.params.id}`);
});
// сопотавляем роутер с конечной точкой "/products"
app.use("/products", productRouter);














#views 


---------------------#hbs #Handlebars ---------------------------------------
npm install hbs --save
Для хранения представлений определим в проекте папку views. Затем в нее добавим новый файл contact.hbs. hbs - это расширение по умолчанию для представлений, которые обрабатываются движком Handlebars
//#render

в файле так помечаем динамические куски
<title>{{title}}</title>
{{#if emailsVisible}}
        <h3>Электронные адреса</h3>
        <ul>
            {{#each emails}}
                <li>{{this}}</li>
            {{/each}}
        </ul>
    {{/if}}





//устанавливаем движок представлений
app.set("view engine", "hbs");
//устанавливаем путь, это не обязательно, стандартно используется папка views
app.set("views", "templates"); // установка пути к представлениям 


app.use("/contact", function(request, response){
     //страница без параметров
    response.render("contact.hbs");
//с параметрами
response.render("contact.hbs", {
        title: "Мои контакты",
        });
});








#partial

views/partials новый файл menu.hbs

вот так рендерится частичное представление которое находится в файле menu.hbs
<body>{{> menu}}</body>

const hbs = require("hbs");
hbs.registerPartials(__dirname + "/views/partials");






#Layout #лаяут

Создадим в проекте в папке views новый каталог layouts и определим в нем файл layout.hbs


<!DOCTYPE html>
<html>
<head>
    <title>{{title}}</title>
    <meta charset="utf-8" />
</head>
<body>
    {{> menu}}
      
    {{{body}}}
      
    {{> footer}}
</body>
<html>


const express = require("express");
const expressHbs = require("express-handlebars");
const hbs = require("hbs");
const app = express();
  
// устанавливаем настройки для файлов layout
app.engine("hbs", expressHbs(
    {
        layoutsDir: "views/layouts", //относительный путь
        defaultLayout: "layout",//название файла
        extname: "hbs"
    }
))










#Хелперы  #helpers #registerHelper


hbs.registerHelper("getTime", function(){
     
    var myDate = new Date();
    var hour = myDate.getHours();
    return "Текущее время: " + hour;
});


hbs.registerHelper("createStringList", function(array){
     
    var result="";
    for(var i=0; i<array.length; i++){
        result +="<li>" + array[i] + "</li>";
    }
    return new hbs.SafeString("<ul>" + result + "</ul>");
});




вызов хэлпера
<div>{{getTime}}</div>
вызов с параметрами
 <div>{{createStringList fruit}}</div>




------------------КОНЕЦ---#hbs #Handlebars ---------------------------------------

------------------#EJS---------------------------------------

npm install ejs --save



app.set("view engine", "ejs");
 
app.use("/contact", function(request, response){
     //для файла contact.ejs
    response.render("contact", {
        title: "Мои контакты"
    });
});


в html
<title><%=title %></title>
<% if(emailsVisible) {%>
        <h3>Электронные адреса</h3>
        <ul>
            <% for(var i=0; i<emails.length;i++) {%>
                <li><%=emails[i] %></li>
            <%} %>
        </ul>
    <% }else {%>
        <h3>Электронный адрес отсутствует</h3>
    <%} %>






#Частичные представления #partial
определим в папке views каталог partials
#include

подключение частичного представления
<%- include("partials/menu.ejs") %>




------------------КОНЕЦ---#EJS---------------------------------------




---------------------#Pug---------------------------------------
файлы назваются так footer.pug

npm install pug --save



app.set("view engine", "pug");

в html
<title>#{title}</title>
//тут роляют только отступы как в питоне
if emailsVisible
        <h3>Электронные адреса</h3>
	h3 Электронные адреса ТАК ТОЖЕ МОЖНО
        <ul>
            each email in emails
                <li>#{email}</li>
		li=email
        </ul>
    else
        <h3>Электроннный адрес отсутствует</h3>


- var n = 0;
ul
  while n < 4
    li= n++

ul
  each val, index in {1:'one',2:'two',3:'three'}
    li= index + ': ' + val








#partial #частичные

   include footer.pug




#layout 

layout.pug

<body>
    block content   //определяем блок в который будут вставляться некоторые данные - указываем название блока
    include footer.pug
</body>



для применения мастер страницы, на другой странице пишем (путь к файлу)
extends layout.pug

и определяем блоки
block title
    <title>#{title}</title>
 
block content
      
    <h1>#{title} в Pug</h1>


------------------КОНЕЦ---#Pug---------------------------------------







#test #testing  #тест #тестирование #unittest


#Mocha
https://mochajs.org/
npm install mocha --save-dev



файл который нужно тестировать operations.js
файл который тестирует operations.test.js

var operations = require("./operations");
 
it("name of test", function(){
     
    var expectedResult = 15;
    var result = operations.multiply(3, 5);
    if(result!==expectedResult){
        throw new Error("Expected ${expectedResult}, but got ${result}");
    }
});
it("name of test2", function(){});


//для тестирования асинхронного кода
it("shoud async multiply two numbers", function(done){
    var expectedResult = 12;
    operations.multiplyAsync(4, 3, function(result){
        if(result!==expectedResult){
            throw new Error(`Expected ${expectedResult}, but got ${result}`);
        }
        done();
    });
});




для автоматического запуска тестирования всех файлов сразу
package.json
"version": "1.0.0",
  "scripts":{
    "test" : "mocha *.test.js"
  },


и для начала тестирования
в командной строке перейдем к папке проекта и выполним команду: npm test






#Assert #Assertions 

#equal


var assert = require("assert");
var operations = require("./operations");
 
it("should multiply two numbers", function(){
     
    var expected = 15;
    var result = operations.multiply(3, 5);
//сгенерит ошибку если значения не равны
    assert.equal(result, expected);
//сгенерит ошибку если значения равны
 assert.notEqual(result, expected);
//
assert.deepEqual(response.body, {name:"Tom", age:22});}
});


#describe
метод для группировки тестов
//в файле тестирования
describe("Operation Tests", function(){
    it("should multiply two numbers", function(){});
it("should multiply two numbers", function(){});});










#Express #supertest 
npm install supertest --save-dev



const express = require("express");
var app = express();
app.get("/", function (request, response){
    response.send("Hello Test");
});
app.listen(3000);
 //это важно
module.exports.app = app;




const request = require("supertest");
const assert = require("assert");
var app = require("./app").app;
it("should return Hello Test", function(done){
    request(app)
        .get("/")
        .expect("Hello Test")//ожидаемый результат
//.expect(404).expect("NotFound") // ---- если результат должен возвращаться так response.status(404).send("NotFound");
//.expect(function(response){assert.deepEqual(response.body, {name:"Tom", age:22});})  // ---- если результат должен возвращаться так response.send({name:"Tom", age: 22});
        .end(done);//выполняем тест
});

















#MongoDB #db 
установка и использование #TODO
https://metanit.com/nosql/mongodb/1.2.php
драйвер https://www.npmjs.com/package/mongodb


{
  "name": "mongoapp",
  "version": "1.0.0",
  "dependencies": {
      "express": "^4.16.0",
      "body-parser": "^1.18.0",
      "mongodb": "^3.1.0"
    }
}
//далее
npm install


#MongoClient - ключевой класс

const MongoClient = require("mongodb").MongoClient;

// создаем объект MongoClient и передаем ему строку подключения
const mongoClient = new MongoClient("mongodb://localhost:27017/", { useNewUrlParser: true });
// err (возникшая ошибка при установке соединения) и client (ссылка на подключенный к серверу клиент)
mongoClient.connect(function(err, client){
 
    if(err){
        return console.log(err);
    }
    // взаимодействие с базой данных, закрываем подключение
    client.close();
});



пример взаимодействия
//обращаемся к бд, если такой нет, то она будет создана
const db = client.db("usersdb");
//также создается при первом обращении
    const collection = db.collection("users");
    let user = {name: "Tom", age: 23};
//err (ошибка, которая может возникнуть при операции) и result (результат операции - добавленный объект).
    collection.insertOne(user, function(err, result){
          
        if(err){ 
            return console.log(err);
        }
//result.ops- результат вставки-- это уже не просто объект user, а объект, который получен обратно из базы данных и который содержит идентификатор, установленный при добавлении
        console.log(result.ops);
        client.close();
    });




#insertOne - обавить 1 объект
#insertMany - добавить набор объектов, использование такое же только передать коллекцию
#findAndModify #TODO
//#find
//#findOne - тоже самое но вернет 1 объект
collection.find().// вернет специальный объект #cursor ---- если надо фильтровать то find({name: "Tom",age:23})
toArray(function(err, results){
                 //result - все записи в "таблице"
        console.log(results);
        client.close();
    });

collection.find({}).toArray(function(err, users){
collection.findOne({_id: id}, function(err, user){


#deleteMany(): удаляет все документы, которые соответствуют определенному критерию, в данном улчае result это не коллекция удаленных элементов, а сложный объект
db.collection("users").deleteMany({name: "Tom"}, function(err, result){
#deleteOne(): удаляет один документ, который соответствует определенному критерию
#findOneAndDelete(): получает и удаляет один документ, который соответствует определенному критерию, result-удаленный элемент
#drop(): удаляет всю коллекцию
 db.collection("users").drop(function(err, result){


#updateOne: обновляет один документ, который соответствует критерию фильтрации, и возвращает информацию об операции обновления
#updateMany: обновляет все документы, которые соответствуют критерию фильтрации, и возвращает информацию об операции обновления
#findOneAndUpdate: обновляет один документ, который соответствует критерию фильтрации, и возвращает обновленный документ

db.collection("users").findOneAndUpdate(
            {age: 21}, // критерий выборки
            { $set: {age: 25}}, // параметр обновления
	{// доп. опции обновления, этот объект можно просто пропустить и тогда он будет по умолчанию null    
            returnOriginal: false//результатом будет новое значение
        },
            function(err, result){

db.collection("users").updateMany(
        {name: "Sam"},              // критерий фильтрации
        { $set: {name: "Bob"}},     // параметр обновления
        function(err, result){




при использовании с express, можно написать так
mongoClient.connect(function(err, client){
    if(err) return console.log(err);
    dbClient = client;
    app.locals.collection = client.db("usersdb").collection("users");
    app.listen(3000, function(){
        console.log("Сервер ожидает подключения...");
    });
});


//закрываем приложение+подключение при компинации клавишь
// прослушиваем прерывание работы программы (ctrl-c)
process.on("SIGINT", () => {
    dbClient.close();
    process.exit();
});









#Mongoose 
#ORM #ODM #Schema #схема

npm install mongoose --save



const mongoose = require("mongoose");
const Schema = mongoose.Schema;
  
// установка схемы
const userScheme = new Schema({
    name: String},
 { versionKey: false }//при сохранении данных в документе сохраняется версия(поле __v), такой строкой ее можно отключить
);

// подключение
mongoose.connect("mongodb://localhost:27017/usersdb", { useNewUrlParser: true });
  
//название модели, свяжет с таблицей по названию модели во множественном числе
const User = mongoose.model("User", userScheme);
const user = new User({
    name: "Bill"
});
  
user.save(function(err){
    mongoose.disconnect();  // отключение от базы данных
      
    if(err) return console.log(err);
    console.log("Сохранен объект", user);
});
//user.save(тот что выше) можно заменить на
user.save()
.then(function(doc){
    console.log("Сохранен объект", doc);
    mongoose.disconnect();  // отключение от базы данных
})
.catch(function (err){
    console.log(err);
    mongoose.disconnect();
});




//схема

// установка схемы
const userScheme = new Schema({
    name: String,
    age: Number,
name222: {//указываем значение по умолчанию
        type: String,
        default: "NoName"
    },
name333: {//с ограничениями
        type: String,
        required: true,
        minlength:3,
        maxlength:20
    },
company: {//указываем сложный тип данных
        name: String,
        employee: [String], // тип - массив строк
        date: Date
    }
});





Определение типа свойств в схеме
В качестве типа данных можно указывать одно из следующих значений:
String
Number
Date
Buffer
Boolean
Mixed
Objectid
Array
Decimal128
Map




Валидация

Mongoose имеет ряд встроенных правил валидации, которые мы можем указать в схеме:
required: требует обязательного наличия значения для свойства
min и max: задают минимальное и максимальное значения для числовых данных
minlength и maxlength: задают минимальную и максимальную длину для строк
enum: строка должна представлять одно из значений в указанном массиве строк
match: строка должна соответствовать регулярному выражению









#CRUD в Mongoose
Create, Read, Update and Delete

//для сохранения данных можно
user.save()//см выше
//можно так, функция передается точно такая же как и при save
User.create({name: "Tom", age: 34}, function(err, doc){});


Для получения данных можно использовать целый набор методов:
find: возвращает все объекты, которые соответствуют критерию фильтрации
findById: возвращает один объект по значению поля _id
#findOne: возвращает один объект, который соответствует критерию фильтрации

User.#find({}, function(err, docs){});//функция как обычно, docs-массив выбранных данных
User.#findById("123asd", function(err, doc){});//

User.#remove({age:33}, function(err, result){//result-- объект операции
User.#findOneAndDelete({name:"Bill"}, function(err, doc){//result-- объект который удален
User.#findByIdAndDelete("123asd", function(err, doc){

#updateOne() и #updateMany

User.updateOne({name: "Tom"}, {name: "Tom Smith"}, function(err, result){//result-- объект операции
User.#findByIdAndUpdate(id, {name: "Sam", age: 25}, function(err, result){//result-- старый док
User.findByIdAndUpdate(id, {name: "Bilbo Baggins", age: 111}, {new: true}, function(err, user){//result-- обновленный док
User.findOneAndUpdate({name: "Sam"}, {name: "Bill", age:24}, {new: true}, function(err, user){









Express и Mongoose

mongoose.connect("mongodb://localhost:27017/usersdb", { useNewUrlParser: true }, function(err){
    if(err) return console.log(err);
    app.listen(3000, function(){
        console.log("Сервер ожидает подключения...");
    });
});













































