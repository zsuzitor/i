

#TODO


компиляция запросов https://metanit.com/sharp/entityframeworkcore/8.1.php
логирование https://metanit.com/sharp/entityframeworkcore/2.12.php
хранимые процедуры https://metanit.com/sharp/entityframeworkcore/6.3.php
хранимые функции https://metanit.com/sharp/entityframeworkcore/6.2.php



#FromBody


HttpContext context
context.Response.ContentType = "text/html; charset=utf-8";
await context.Response.WriteAsync("Текст: context.Itemstext");

context.Request.Path.Value.ToLower()


//Создание своих сервисов
//https://metanit.com/sharp/aspnet5/2.19.php


#kestrel вместо #iis
https://metanit.com/sharp/aspnet5/2.7.php
https://metanit.com/sharp/aspnet5/20.1.php
https://metanit.com/sharp/aspnet5/20.2.php



тут такое, про возврат xml и тд про заголовки и контент принимаемый браузером
https://metanit.com/sharp/aspnet5/23.6.php


Создание движка представлений
https://metanit.com/sharp/aspnet5/7.10.php




аутентификация через claims
https://metanit.com/sharp/aspnet5/15.6.php
https://metanit.com/sharp/aspnet5/15.7.php
https://metanit.com/sharp/aspnet5/15.8.php
#jwt #tokens #api-https://metanit.com/sharp/aspnet5/23.7.php



то что по тегу #Libman записать все






#reactjs
https://metanit.com/sharp/aspnet5/25.1.php
https://metanit.com/sharp/aspnet5/25.2.php





куда то засунуть (уже засунул но надо расписать)
#SignInManager














#core


#program

public static void Main(string[] args)
    {
        BuildWebHost(args).Run();
    }
 
    public static IWebHost BuildWebHost(string[] args) =>
        WebHost.CreateDefaultBuilder(args)
            .UseStartup<Startup>()          // установка класса Startup как стартового
            .UseWebRoot("static")   // установка папки static, стандартно тут wwwroot
            .Build();





#startup

#IServiceCollection представляет коллекцию сервисов в приложении
services-список уже подключенных сервисов
public void #ConfigureServices(IServiceCollection services)
{
    //регистрируем сервис, если этого не сделать его нельзя будет использовать в методе Configure()/(при условии что проект не подключает его сам)
services.#AddMvc();//указываем что будем использовать mvc архитектуру
}



#IHostingEnvironment: позволяет взаимодействовать со средой, в которой запускается приложение



#middleware - компоненты приложения, которые могут быть внедрены в конвейер обработки HTTP-запроса, подключаются в Configure
строятся согласно паттерну Singleton - создаются только 1 раз при старте приложения

По умолчанию ASP.NET Core предоставляет следующие встроенные компоненты middleware:
Authentication: предоставляет поддержку аутентификации
CORS: обеспечивает поддержку кроссдоменных запросов
Responce Caching: позволяет кэшировать результаты запросов
Responce Compression: обеспечивает сжатие ответа клиенту
URL Rewriting Middleware: предоставляет функциональность URL Rewriting
Routing: определяет маршруты, используемые в приложении
Session: предоставляет поддержку сессий
Static Files: предоставляет поддержку обработки статических файлов



#ILoggerFactory: предоставляет механизм логгирования в приложении
//параметрами могут быть только добавленные сервисы, можно создать свой подключить его в ConfigureServices и тогда можно будет докинуть его в параметры
public void #Configure(IApplicationBuilder app, IHostingEnvironment env)
{
//метод будет вызываться при каждом запросе, но объект класса создается 1 раз


app.#UseStaticFiles();//разрешаем отдавать static файлы

#map
//метод является конечным(дальше вызываться ничего не будет)
//Теперь обращения к приложению типа http://localhost:xxxx/about будут обрабатываться с помощью метода About
app.Map("/index", Index);//Index-делегат который будет возвращать html
app.Map("/about", About);

//сложенность, Теперь метод About будет обарабатывать запрос не http://localhost:xxxx/about, а http://localhost:xxxx/home/about
app.Map("/home", home =>
    {
        home.Map("/index", Index);
        home.Map("/about", About);
    });


#MapWhen
//метод является конечным(дальше вызываться ничего не будет)
//принимает в качестве параметра делегат Func<HttpContext, bool> и обрабатывает запрос, если функция, передаваемая в качестве параметра возвращает true.
app.MapWhen(context => {
               
        return context.Request.Query.ContainsKey("id") && 
                context.Request.Query["id"] == "5";
    }, Index);




#use
//метод является НЕ конечным(дальше вызываться будет по очереди)
//что то сделает и затем передает обработку запроса следующим компонентам middleware в конвейере, например app.Run
app.Use(async (context, next) =>
    {
        z = x * y;

//рекомендуется вызывать метод next.Invoke после метода Response.WriteAsync()
        await next.Invoke();//если это убрать то на дальше не будет ничего обрабатываться


//так можно
	x = x * 2;
        await next.Invoke();    // вызов app.Run
        x = x * 2;      // 8 * 2 = 16
        await context.Response.WriteAsync($"Result: {x}");

    });







метод расширения для вызова app.UseToken(); в методе Configure, может быть упразднен, тогда вместо app.UseToken();   => app.UseMiddleware<TokenMiddleware>();
public static class TokenExtensions
{
    public static IApplicationBuilder UseToken(this IApplicationBuilder builder)
    {
        return builder. #UseMiddleware<TokenMiddleware>();//так вызываются самописные Middleware
    }
}

//сам класс который будет обрабатывать запрос 

public class TokenMiddleware
{
    private readonly RequestDelegate _next;//#RequestDelegate делегат который будет выполняться следующим
 
    public TokenMiddleware(RequestDelegate next)
    {
        this._next = next;
    }
 //метод должен называться InvokeAsync или Invoke
    public async Task InvokeAsync(HttpContext context)
    {
await _next.Invoke(context);//моно вызвать следующий по очереди метод, если его не вызвать то он не вызовется сам вообще??? TODO
        var token = context.Request.Query["token"];
        if (token!="12345678")
        {
            context.Response.StatusCode = 403;
            await context.Response.WriteAsync("Token is invalid");
        }
        else
        {
            await _next.Invoke(context);
        }
    }
}








#run
//метод является конечным(дальше вызываться ничего не будет)
//данный метод не передает обработку запроса далее по конвейеру, тоесть его следует помещать в самом конце
//В качестве параметра метод Run принимает делегат RequestDelegate. Этот делегат имеет следующее определение:
//public delegate Task RequestDelegate(HttpContext context);

app.Run(async (context) =>
        {
            await context.Response.WriteAsync($"Result: {1}");
        });
}











#IHostingEnvironment
следует помещать ближе к началу  Configure
#ApplicationName: возвращает имя приложения
#EnvironmentName: возвращает описание среды, в которой хостируется приложение
{
может иметь 1 из 3х значений: #Development, #Staging и #Production
В проекте это свойство задается через установку переменной среды ASPNETCORE_ENVIRONMENT. Ее текущее значение можно посмотреть в свойствах проекта на вкладке Debug
Для определения значения этой переменной для интерфейса IHostingEnvironment определены специальные методы расширения:
#IsDevelopment(): возвращает true, если имя среды - Development
#IsStaging(): возвращает true, если имя среды - Staging
#IsProduction(): возвращает true, если имя среды - Production
Configure() класса Startup-> env.EnvironmentName = EnvironmentName.Production;


Configure() класса Startup-> if (env.IsDevelopment()){app.#UseDeveloperExceptionPage();}  -> если не размещено на хостинге то подробное описание ошибки, если на хостинге то нет

}



#UseExceptionHandler #error #Exception
Он перенаправляет при возникновении исключения на некоторый адрес и позволяет обработать исключение
следует помещать ближе к началу  Configure

if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    else
    {
        app.UseExceptionHandler("/error");//перенаправляет при возникновении ошибки на адрес "/error"
    }

//обрабатываем ошибку
app.Map("/error", ap => ap.Run(async context =>
    {
        await context.Response.WriteAsync("DivideByZeroException occured!");
    }));



Обработка #ошибок #ошибка HTTP #error #404
стандартно статус ошибки можно увидеть только в консоле, сама страница просто будет белой
if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    // обработка ошибок HTTP, благодаря этой строке будет написан код ошибки на странице
  app.UseStatusCodePages();
//{0} - статус ошибки
//app.UseStatusCodePages("text/plain", "Error. Status code : {0}");

//Но теперь при обращении к несуществующему ресурсу клиент получит статусный код 302 / Found. То есть формально несуществующий ресурс будет существовать, просто статусный код 302 будет указывать, что ресурс перемещен на другое место - по пути "/error/404".
//app.#UseStatusCodePagesWithRedirects("/error/{0}");//Здесь будет идти перенаправление по адресу "/error" ErrorStatus.

//app.#UseStatusCodePagesWithReExecute("/error/{0}");//тоже что и UseStatusCodePagesWithRedirects но браузер получит правильный статус

Настройка обработки ошибок в web.config - также можно но значительные ограничения https://metanit.com/sharp/aspnet5/17.1.php










#зависимости #injection #di 
///
при services.AddTransient<ITimeService, SimpleTimeService>();
public class HomeController : Controller
{
    private readonly ITimeService _timeService;
 
    public HomeController(ITimeService timeServ)
    {
        _timeService = timeServ;
    }
}



#получение #объекта 

#[] #attr #FromServices
если не хотим передавать в конструктор контроллера 

///

то можно так, сам все создаст и закинет
public IActionResult Index([FromServices] IHostingEnviroment env)
#TODO кажется дубликат
#create #зависимость
var env=HttpContext.RequestServices.GetService<IHostingEnvironment>();




для внедрения в вью
@inject MvcViewsApp.Services.IMessageSender MessageSender
@MessageSender.SendMessage()


подробнее в "Создание своих сервисов" и "AddTransient"




///ТЕОРИЯ что происходит при передаче через конструктор контроллера
Приложение получает запрос к методу контроллера HomeController
Фреймворк MVC обращается к провайдеру сервисов для создания объекта контроллера HomeController
Провайдер сервисов смотрит на конструктор класса HomeController и видит, что там имеется зависимость от интерфейса ITimeService
Провайдер сервисов среди зарегистрированных зависимостей ищет класс, который представляет реализацию интерфейса ITimeService
Если нужная зависимость найдена, то провайдер сервисов создает объект класса, который реализует интерфейс ITimeService
Затем провайдер сервисов создает объект HomeController, передавая в его конструктор ранее созданную реализацию ITimeService
В конце провайдер сервисов возвращает созданный объект HomeController инфраструктуре MVC, которая использует контроллер для обработки запроса











#Создание своих #сервисов #сервис #внедрение #зависимостей #service

сервис можно передать параметром или получить так TimeService timeService = context.RequestServices.GetService<TimeService>();


Добавим в проект новую папку Services
public interface IMessageSender
{
    string Send();
}
создать несколько классов реализующих интерфейс
EmailMessageSender, SmsMessageSender

в классах можно определить метод расширения
public static void AddTimeService(this IServiceCollection services)
    {
        services.AddTransient<TimeService>();
    }




#AddTransient #Transient
Такие объекты создаются при каждом обращении к ним(к классу, объекту класса).

#AddScoped #Scoped
Метод AddScoped создает один экземпляр объекта для всего запроса. применяется также как и AddTransient

#AddSingleton #Singleton
AddSingleton создает один объект для всех последующих запросов, при этом объект создается только тогда, когда он непосредственно необходим. применяется также как и AddTransient

//подключаем тот класс который будет использоваться(подразумеваться) с интерфейсом
//устанавливаем зависимость
ConfigureServices->
//если метод расширения(static this) не был определен
services.AddTransient<IMessageSender, EmailMessageSender>();
services.AddTransient<TimeService>();//если зависимость устанавливать не нужно, а нужно просто добавить сервис
//services.AddSingleton<ICounter>(new RandomCounter());//объект можно создать самому

//можно передать делегат который будет отвечать за создание
services.AddTransient<IMessageSender>(provider=> {
    if (DateTime.Now.Hour >= 12) return new EmailMessageSender();
    else return new SmsMessageSender();
});


//если метод расширения(static this) был определен
 services.AddTimeService();


// теперь можем указать IMessageSender как подключенный сервис
Configure(IApplicationBuilder app, IHostingEnvironment env, IMessageSender messageSender)
messageSender.Send();//вызовется метод того класса зависимость которого установили

теперь данную зависимость можно использовать:
Через конструктор класса (за исключением конструктора класса Startup) - класс может иметь только 1 конструктор который поддерживает параметр зависимости
{
для такого класса нужно подключить сервис services.AddTransient<MessageService>(); тогда его можно будет также использовать в configure в качестве параметра
и нужно внедрить зависимость которую он получает в качестве параметра
}
Через параметр метода Configure класса Startup
Через параметр метода Invoke компонента middleware
Через свойство RequestServices контекста запроса HttpContext в компонентах middleware // HttpContext.RequestServices
Через свойство ApplicationServices объекта IApplicationBuilder в классе Startup




#console внедрение зависимостей в консольном приложении
using Microsoft.Extensions.DependencyInjection;

public class Program 
{
public static void Main(string[] args)
{
//установка зависимостей DI
var serviceProvider = new ServiceCollection()
.AddSingleton<IFooService, FooService>()
.AddSingleton<IBarService, BarService>()
.BuildServiceProvider();






создание объекта  для зависимости (по например интерфейсу создать объект)

#HttpContext. #RequestServices
предоставляет доступ к всем внедренным зависимостям с помощью своих методов

#GetService<service>(): использует провайдер сервисов для создания объекта, который представляет тип service. В случае если в провайдере сервисов для данного сервиса не установлена зависимость, то возвращает значение null
#GetRequiredService<service>(): использует провайдер сервисов для создания объекта, который представляет тип service. В случае если в провайдере сервисов для данного сервиса не установлена зависимость, то генерирует исключение

при внедрении такой зависимости services.AddTransient<IMessageSender, EmailMessageSender>();
можно получить объект IMessageSender messageSender = context.RequestServices.GetService<IMessageSender>();



#ApplicationServices

Configure(IApplicationBuilder app)
IMessageSender messageSender = app.ApplicationServices.GetService<IMessageSender>();


Метод #Invoke компонентов #middleware

когда создаем свой класс для использования с app.Use можем также добавить параметр в метод Invoke
 public async Task Invoke(HttpContext context, IMessageSender messageSender)






#error
#InvalidOperationException: Cannot resolve scoped service 'DIApp.TimeService' from root provider. в ConfigureServices
возможно не правильно указаны способы подключения, допустим зависимость - AddScoped а сервис AddTransient, может получиться что они взаимосвязаны но 1 объект создается позже другого
#InvalidOperationException: Cannot consume scoped service 'DIApp.ITimer' from singleton 'DIApp.TimeService
Но суть будет та же самая - мы не можем по умолчанию передавать в конструктор singleton-объекта scoped-сервис.









#path #путь #root #корень
#ContentRootPath: возвращает путь к корневой папке приложения
#WebRootPath: возвращает путь к папке, в которой хранится статический контент приложения, как правило, это папка wwwroot
#ContentRootFileProvider: возвращает реализацию интерфейса Microsoft.AspNetCore.FileProviders.IFileProvider, которая может использоваться для чтения файлов из папки ContentRootPath
#WebRootFileProvider: возвращает реализацию интерфейса Microsoft.AspNetCore.FileProviders.IFileProvider, которая может использоваться для чтения файлов из папки WebRootPath

#IHostingEnvironment #appEnvironment
_appEnvironment.ContentRootPath

#Combine #TODO
Path.Combine(str1,str2);


#Directory.#GetCurrentDirectory()






#static #files

необходимо в #sturtup->config докинуть
app.#UseStaticFiles();//разрешаем отдавать static файлы

по ссылке http://localhost:55234/index.html можно получить статический файл который расположен
wwwroot->index.html
если находится в wwwroot/html/ то http://localhost:55234/html/index.html
если нужно изменить папку с статик файлами то в program.cs внести изменения
public static void Main(string[] args)
    {
        BuildWebHost(args).Run();
    }
 
    public static IWebHost BuildWebHost(string[] args) =>
        WebHost.CreateDefaultBuilder(args)
            .UseStartup<Startup>()          // установка класса Startup как стартового
            .UseWebRoot("static")   // установка папки static, стандартно тут wwwroot
            .Build();



сопоставление каталогов с путями
 app.UseStaticFiles(); // обрабатывает все запросы к wwwroot

//такая перегрузка позволит по запросу http://localhost:56431/pages/index.html обратиться к файлу wwwroot/html/index.html
    app.UseStaticFiles(new StaticFileOptions() // обрабатывает запросы к каталогу wwwroot/html
    {
        FileProvider = new PhysicalFileProvider(
            Path.Combine(Directory.GetCurrentDirectory(), @"wwwroot\html")),
        RequestPath = new PathString("/pages")
    });





#UseDefaultFiles
// дописав  app.UseDefaultFiles(); перед app.UseStaticFiles(); , можно определить стандартный статический файл который будет отправляться по запросу http://localhost/
названия у файла должно быть: default.htm default.html index.htm index.html
Если файл будет найден, то он будет отправлен в ответ клиенту. Если же файл не будет найден, то продолжается обычная обработка запроса с помощью следующих компонентов middleware
если надо указать стандатный файл с другим именем то 
в configure докинуть в начало
	DefaultFilesOptions options = new DefaultFilesOptions();
        options.DefaultFileNames.Clear(); // удаляем имена файлов по умолчанию
        options.DefaultFileNames.Add("hello.html"); // добавляем новое имя файла
        app.UseDefaultFiles(options); // установка параметров
app.UseStaticFiles();




app.#UseDirectoryBrowser(); #директория #Directory
докинув в config и докинув  services.AddDirectoryBrowser(); в ConfigureServices
можно позволить пользователям просмотривать файлы на сервере


 using Microsoft.Extensions.FileProviders.
если использовать такую перегрузку то в таком случае путь типа http://localhost:56431/pages/ будет сопоставляться с каталогом "wwwroot\html".
app.UseDirectoryBrowser(new DirectoryBrowserOptions()
    {
        FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), @"wwwroot\html")),
         
        RequestPath = new PathString("/pages")
    });








app.#UseFileServer();
Метод UseFileServer() объединяет(остальные указывать не надо) функциональность сразу всех трех методов UseStaticFiles, UseDefaultFiles и UseDirectoryBrowser

Если нам надо еще включить просмотр каталогов, то
app.UseFileServer(enableDirectoryBrowsing: true);

В этом случае будет разрешен обзор каталога по пути http://localhost:56431/pages/, но при этом путь http://localhost:56431/html/ работать не будет.
app.UseFileServer(new FileServerOptions
{
    EnableDirectoryBrowsing=true,
    FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), @"wwwroot\html")),
    RequestPath = new PathString("/pages"), 
    EnableDefaultFiles=false
});





#owin


в configure
//если #UseOwin что то выводит в поток(результат) то все последующее не будет выведено 
- context.Response.WriteAsync("Hello Work!"); ничего не выведет, повторный запуск owin тоже ничего не выведет
app.UseOwin(pipeline =>
            {
                pipeline(next => SendResponseAsync);
            });


public Task SendResponseAsync(IDictionary<string, object> environment)
        {
//из environment мы можем получать объекты запроса и ответа
            // определяем ответ
            string responseText = "Hello ASP.NET Core";
            // кодируем его в массив байтов
            byte[] responseBytes = Encoding.UTF8.GetBytes(responseText);
 
            // получаем поток ответа
            var responseStream = (Stream)environment["owin.ResponseBody"];
            // отправка ответа
            return responseStream.WriteAsync(responseBytes, 0, responseBytes.Length);
        }



Ключи запроса то что используется тут environment["owin.ResponseBody"]
owin.#RequestBody : объект Stream, представляющий тело запроса
owin.#RequestHeaders : объект IDictionary<string, string[]>, представляющий заголовки запроса
owin.#RequestMethod : объект string, представляющий метод запроса ("GET", "POST")
owin.#RequestPath : объект string, представляет запрошенный путь относительно корня приложения
owin.#RequestPathBase : объект string, содержащий часть запрошенного пути относительно корня приложения
owin.#RequestProtocol : объект string, хранящий название протокола ("HTTP/1.0", "HTTP/1.1")
owin.#RequestQueryString : объект string, хранящий строку запроса, то есть ту часть URI, которая идет после "?" (например, "foo=bar&mes=hello")
owin.#RequestScheme : объект string, хранящий схему URI запроса ("http", "https")
owin.#RequestId : объект string, представляющий уникальный идентификатор запроса (необязательный параметр)

Ключи ответа то что используется тут environment["owin.ResponseBody"]
owin.#ResponseBody : объект Stream, представляющий поток ответа
owin.#ResponseHeaders : объект IDictionary<string, string[]>, представляющий заголовки ответа
owin.#ResponseStatusCode : объект int, хранящий статусный код HTTP, который посылается в ответе (необязательный параметр)
owin.#ResponseReasonPhrase : объект string, содержащий словесное пояснение к статусному коду (необязательный параметр)
owin.#ResponseProtocol : объект string, хранящий название протокола ("HTTP/1.0", "HTTP/1.1")







#log #логирование #логгирование

в Configure
loggerFactory.AddConsole(); //указываем что логи будут выводиться на консоль
loggerFactory.AddConsole(LogLevel.Warning);//устанавливаем детализацию

там где нужно что то вывести (например app.Run(async (context))
// создаем объект логгера
                var logger = loggerFactory.CreateLogger("RequestInfoLogger");
                // пишем на консоль информацию
                logger.LogInformation("Processing request {0}", context.Request.Path);

вывод сообщений уровня Debug и Trace по умолчанию отключен


#LogLevel

Trace: используется для вывода наиболее детализированных сообщений. Подобные сообщения могут нести важную информацию о приложении и его строении, поэтому данный уровень лучше использовать при разработке, но никак не при публикации
Debug: для вывода информации, которая может быть полезной в процессе разработки и отладки приложения
Information: уровень сообщений, позволяющий просто отследить поток выполнения приложения
Warning: используется для вывода сообщений о неожиданных событиях, например, ошибках, которые не влияют не останавливают выполнение приложения, но в то же время должны быть иследованы
Error: информация об ошибках, вследствие которых приложение должно быть остановлено
Critical: уровень критических ошибок, которые могут быть связаны с какими-то ситуациями извне - ошибками операционной системы, потерей данных в бд, переполнение памяти диска и т.д.
None: вывод информации в лог не применяется



у #LogInformation есть методы 

#LogDebug()
#LogTrace()
#LogInformation()
#LogWarning()
#LogError()
#LogCritical()


иногда не все логи можно увидеть, и это можно исправить в program.cs

public static IWebHost BuildWebHost(string[] args) =>
            WebHost.CreateDefaultBuilder(args)
                .UseStartup<Startup>()
                .ConfigureLogging(logging => logging.SetMinimumLevel(LogLevel.Trace))//устанавливаем минимальный уровень который надо видеть в логах
            .Build();



для использования логов в контроллере
public class HomeController : Controller
{
private readonly ILogger _logger;

public HomeController(ILogger<homecontroller> logger)
{
_logger = logger;
}

public IActionResult Index()
{
_logger.LogInformation("Test Message");

return View();
}
}



------------
еще вариант в контроллере #TODO сравнить оценить мб оставить только один варик

есть инструкция проще
public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
{
loggerFactory.AddFile(Configuration["Logging:LogFileName"]);
...
в контроллерах:
[ApiController]
public class BaseController : Controller
{
protected readonly ILogger _logger;

public BaseController(
ILogger<basecontroller> logger
)
{
_logger = logger;
}
}
Использование:
_logger.LogInformation("User logged in.");














--------------------
если не в контроллере а где то еще то

Создаём класс:
using Microsoft.Extensions.Logging;
...

internal static class Log
{
internal static ILoggerFactory LoggerFactory { get; set; }
internal static ILogger CreateLogger<t>() => LoggerFactory.CreateLogger<t>();
internal static ILogger CreateLogger(string categoryName) => LoggerFactory.CreateLogger(categoryName);
}

Затем в Startup.cs добавляем сохранение фабрики:

public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
{
...
Log.LoggerFactory = loggerFactory;
....
}

И в нужном классе, в котором надо вести логгирование:
public class CustomClass
{
private readonly ILogger _logger = Log.CreateLogger<customclass>();

public CustomClass()
{
_logger.LogInformation("test message");
}
}





#TODO создание провайдера логгирования(вывод логов не на консоль а например в файл)
https://metanit.com/sharp/aspnet5/2.10.php







что то типо глабальной переменной для всех middleware

 (IDictionary<object, object>)HttpContext.Items

После завершения запроса все данные из HttpContext.Items удаляются

app.Use(async (context, next) =>
    {
        context.Items["text"] = "Text from HttpContext.Items";}
//и в другом можем получить




#Куки #cookie 



посылаются на сервер с каждым запросом, размер ограничен 4096 байтами
И также по умолчанию куки имеют настройку CookieHttpOnly=true, поэтому они не доступны для клиентских скриптов из браузера
//так можно только получить
if (context.Request.Cookies.ContainsKey("name"))
    string name = context.Request.Cookies["name"];

//для добавления
context.Response.Cookies.Append("name", "Tom");
//удаление
context.Response.Cookies.Delete("name");

коллекция context.Request.Cookies представляет объект #IRequestCookieCollection



using Microsoft.AspNetCore.Http;


#Сессии #Session  #Memory


Для хранения состояния сессии на сервере создается словарь или хеш-таблица, которая хранится в кэше и которая существует для всех запросов из одного браузера в течение некоторого времени. 
На клиенте хранится идентификатор сессии в куках. Этот идентификатор посылается на сервер с каждым запросом. Сервер использует этот идентификатор для извлечения нужных данных из сессии. 
Эти куки удаляются только при завершении сессии. Но если сервер получает куки, которые установлены уже для истекшей сессии, то для этих кук создается новая сессия.
название куки в которой хранится ключ сессии по умолчанию - ".AspNet.Session"
все сессии работают поверх объекта #IDistributedCache //#AddDistributedMemoryCache


в ConfigureServices

services.AddDistributedMemoryCache();
    services.AddSession();


в Configure
вверху app.UseSession();//если не вызвать метод то при обращении будет исключение InvalidOperationException

//читаем 
if(context.Session.Keys.Contains("name"))
//устанавливаем
context.Session.SetString("name", "Tom");


Объект Session определяет ряд свойств и методов, которые мы можем использовать:
Keys: свойство, представляющее список строк, который хранит все доступные ключи
Clear(): очищает сессию
Get(string key): получает по ключу key значение, которое представляет массив байтов
GetInt32(string key): получает по ключу key значение, которое представляет целочисленное значение
GetString(string key): получает по ключу key значение, которое представляет строку
Set(string key, byte[] value): устанавливает по ключу key значение, которое представляет массив байтов
SetInt32(string key, int value): устанавливает по ключу key значение, которое представляет целочисленное значение value
SetString(string key, string value): устанавливает по ключу key значение, которое представляет строку value
Remove(string key): удаляет значение по ключу



переопределение настроик сессии через объект
#SessionOptions:
#CookieName: имя куки
#IdleTimeout: время действия куки в виде объекта TimeSpan
#CookieDomain: домен, для которого устаналиваются куки
#CookieHttpOnly: доступны ли куки только при передаче через HTTP-запрос
#CookiePath: путь, который используется куками


для изменения надо в ConfigureServices(IServiceCollection services)
services.AddDistributedMemoryCache();
    services.AddSession(options =>
    {
        options.CookieName = ".MyApp.Session";
        options.IdleTimeout = TimeSpan.FromSeconds(3600);
    });



хранить в сессии можно только строку\число, поэтому надо конвертить(можно так)
#json #JsonConvert #SerializeObject #DeserializeObject

//context.Session.Get<Person>("person");
//context.Session.Set<Person>("person", person);

using Microsoft.AspNetCore.Http;
using Newtonsoft.Json;
 
public static class SessionExtensions
{
    public static void Set<T>(this ISession session, string key, T value)
    {
        session.SetString(key, JsonConvert.SerializeObject(value));
    }
 
    public static T Get<T>(this ISession session, string key)
    {
        var value = session.GetString(key);
        return value == null ? default(T) : JsonConvert.DeserializeObject<T>(value);
    }
}



#JsonSerializer #json
using System.Text.Json;
JsonSerializer.Serialize(obj);

[JsonPropertyName("access_token")]











#https #UseHttpsRedirection
при попытке доступа по http будет редиректить на #https

Configure-> app.UseHttpsRedirection();
можно задать параметры переадресации
ConfigureServices просто докинуть->
services.AddHttpsRedirection(options =>
    {
        options.RedirectStatusCode = StatusCodes.Status307TemporaryRedirect;
        options.HttpsPort = 44369;
    });


#UseHsts #Hsts 
из за того что при первом обращении пользователь всегда обращается по http надо не просто редиректить а делать еще и так
Configure-> 
if (env.IsDevelopment()){}else//кидать в такое условие тк могут быть проблемы при разработке тк все кешируется
app.UseHsts();//до UseHttpsRedirection


можнно настроить параметры ( Strict-Transport-Security )
ConfigureServices ->
services.AddHsts(options =>
    {
        options.Preload = true;//устанавливает параметр preload
        options.IncludeSubDomains = true;//устанавливает параметр includeSubDomains
        options.MaxAge = TimeSpan.FromDays(60);//устанавливает параметр max-age
        options.ExcludedHosts.Add("us.example.com");//добавляет сисок доменов, которые надо исключить из действия заголовка
        options.ExcludedHosts.Add("www.example.com");
    });




Strict-Transport-Security: max-age=63072000; includeSubDomains; preload
Заголовок имеет три параметра:

max-age: задает максимальное действие заголовка (обязательный параметр)
includeSubDomains: если этот параметр установлен, то действие применяется ко всем поддоменам
preload: если этот параметр установлен, то будет использоваться специальный preload-список доменов, обращение к которым безопасно.







#bower.json
файл который управляет клиентскими зависимостями(библиотеки js css), которые подключаются через менеджер пакетов bower




#bundleconfig.json
файл который содержит задачи по минификации используемых скриптов и стилей, которые выполняются при построении проекта







#Dependency #Injection
#внедрение #зависимостей #IServiceProvider аналог #Ninject








#IConfiguration #IConfigurationRoot #конфигурация #config
хранение конфигурации приложения
в версии 2.0++ не обязательно все явно подключать все может подключиться само:
создать файл appsettings.json - обязательно такое имя // #appsettings.json
в контруктор Startup добавить параметр и хранить его
public Startup(IConfiguration config)
        {
            AppConfiguration = config;
        }
        public IConfiguration AppConfiguration { get; set; }
 var color = AppConfiguration["color"];

если делать таким образом то можно докинуть в #Middleware, и дальше уже юзать в нем
public ConfigMiddleware(RequestDelegate next, IConfiguration config)
        {
            _next = next;
            AppConfiguration = config;
        }
        public IConfiguration AppConfiguration { get; set; }

то что выше(передача параметром через фабрику) можно сделать и без файла appsettings.json, если докинуть
ConfigureServices-> services.AddTransient<IConfiguration>(provider => AppConfiguration);//AppConfiguration - название свойства, описано ниже



Microsoft.Extensions.Configuration
Кроме того настройки конфигурации также могут храниться во внешнем файле - json, ini, xml, и в этом случае нам может потребоваться добавить один из пакетов, который позволяет работать с определенным источников конфигурации. В частности, нам доступно несколько источников конфигурации, которые представлены следующими пакетами:
Microsoft.Extensions.Configuration (предоставляет базовую функциональность для конфигурации, а также позволяет задавать параметры конфигурации в памяти)
Microsoft.Extensions.Configuration.Json (позволяет использовать в качестве источников конфигурации файлы json)
Microsoft.Extensions.Configuration.CommandLine (позволяет считывать параметры конфигурации из командной строки с помощью метода AddCommandLine())
Microsoft.Extensions.Configuration.EnvironmentVariables (позволяет получать параметры конфигурации из переменных окружения)
Microsoft.Extensions.Configuration.Ini (использует в качестве источника конфигурации файлы ini)
Microsoft.Extensions.Configuration.Xml (использует в качестве источника конфигурации файлы xml)

#ConfigurationBuilder #IConfiguration




IConfiguration определяет следующие методы:
#GetSection(name): возвращает объект IConfiguration, который представляет только определенную секцию name
#GetChildren(): возвращает все подсекции текущего объекта конфигурации в виде набора объектов IConfiguration
#GetReloadToken(): возвращает токен - объект IChangeToken, который используется для уведомления при изменении конфигурации
#GetConnectionString(name): эквивалентен вызову GetSection("ConnectionStrings")[name] и предназначается непосредственно для работы со строками подключения к различным базам даных
string con = AppConfiguration.GetConnectionString("DefaultConnection");

[key]: индексатор, который позволяет получить по определенному ключу key хранящееся значение






public Startup()
        {
            // строитель конфигурации, необходимо указать место хранения(можно скопировать ниже) 
var builder =new ConfigurationBuilder();
            
            // создаем конфигурацию./ этот элемент попадает в конфигурацию приложения
            AppConfiguration = builder.Build();
 
        }
        // свойство, которое будет хранить конфигурацию
        public IConfiguration AppConfiguration { get; set; }

//получаем - await context.Response.WriteAsync(AppConfiguration["firstname"]);
//устанавливаем - AppConfiguration["firstname"] = "alice";


#AddInMemoryCollection -хранение в памяти

var builder = new ConfigurationBuilder()
                .AddInMemoryCollection(//указываем место хранения
new Dictionary<string, string>
                {
                    {"firstname", //ключ настройки 
			"Tom"},   // значение
                    {"age", "31"}
                });

#AddJsonFile (class JsonConfigurationExtensions) #json
создать объект json и закинуть туда данные ( {"color": "red"} ), в файле должны быть уникальные ключи
И если во втором файле есть настройки, которые имеют тот же ключ, что и настройки первого файла, то происходит переопределение настроек: настройки из второго файла заменяют настройки первого.


var builder = new ConfigurationBuilder()
                .SetBasePath(env.ContentRootPath)
                .AddJsonFile("conf.json").AddJsonFile("myconfig.json");//можно указать несколько файлов, можно только 1

можно хранить сложные объекты
{
  "color": "red",
  "namespace": { "class": { "method": "AddJson" } }
}
string text = AppConfiguration["namespace:class:method"];
string text = AppConfiguration. #GetSection("namespace").GetSection("class")... .Value;
string text = AppConfiguration. #GetSection("namespace:class:method")... .Value;

#AddXmlFile #xml

добавить новый xml файл
<configuration>
  <color>blue</color>
  <text>Hello ASP.NET</text>
</configuration>

var builder = new ConfigurationBuilder()
                .SetBasePath(env.ContentRootPath);
            builder.AddXmlFile("config.xml");



#AddIniFile #ini
 добавим в проект текстовый файл и переименуем его в conf.ini
color="blue"
text="Hello ASP.NET Core 2.0"
var builder = new ConfigurationBuilder()
                .SetBasePath(env.ContentRootPath)
                .AddIniFile("conf.ini");



#AddEnvironmentVariables
 можно добавить все переменные среды окружения, которые имеются на рабочей машине
AppConfiguration = new ConfigurationBuilder()
        .AddEnvironmentVariables()
        .Build();

string java_dir = AppConfiguration["JAVA_HOME"] ?? "not set";



Объединение источников конфигурации

var builder = new ConfigurationBuilder()
            .SetBasePath(env.ContentRootPath);
        builder.AddJsonFile("conf.json");
        builder.AddEnvironmentVariables();



создание собственного провайдера источника конфигурации #TODO
https://metanit.com/sharp/aspnet5/2.15.php







#IOptions #TOptions
#TODO вообще не понял суть https://metanit.com/sharp/aspnet5/6.3.php



допустим в файле конфигурации appsettings.json сохранен объект класса Person

создаем обычный PersonMiddleware
в конструктор добавляем (, IOptions<Person> options){
Person = options.Value;
}
 public Person Person { get; }
в таком случае в Invoke можем обращаться к объекту person который сохранен в json а в конструктор будет передан автоматически, но надо докинуть то что ниже

public IConfiguration AppConfiguration { get; set; }
ConfigureServices->{
// Настройка параметров и DI, добавляем возможность внедрения зависимостей
            services.AddOptions();
 
            // создание объекта Person по ключам из конфигурации
            services.Configure<Person>(AppConfiguration);

//необязательная часть ConfigureServices

// переопределяем настройки(свойства класса person), имзенятся ли они в файле не понятно #TODO
services.Configure<Person>(opt =>
    {
        opt.Age = 22;
    });

//передача отдельных секций конфигураций(определена в файле appsettings.json)
services.Configure<Company>(AppConfiguration.GetSection("company"));

}
Configure->{
app.UseMiddleware<PersonMiddleware>();
}























#Request #Query #params
получение переданных параметров get
string altitudeString = Request.Query.FirstOrDefault(p => p.Key == "altitude").Value;

см также #RouteData RouteData.Values["name"]

отличие
при routes.MapRoute("api", "api/get/{id?}", new { controller = "Home", action = "About" });
отправляем такой запрос http://localhost:55407/api/get/45?id=56&name=volga

данные маршрута--  controller = Home   action = About   id = 45

строка запроса //идет после знака ? --  id = 56  name = volga


#Form #IFormsCollection
получение переданных параметров post
 string altitudeString = Request.Form.FirstOrDefault(p => p.Key == "altitude").Value;

см также RouteData RouteData.Values["name"]



#attr

#route #HttpGet #get #post #routing #router
[HttpGet("api/index")]
Index()
[HttpGet("api/index/{id}")]
Index(string id)

[HttpGet]
Index(string id)

#HttpPost #HttpPut #HttpDelete #HttpHead , если не указать явно то будет HttpGet



#get  #param #параметры

// передать массив из 3х элементов
http://localhost:57086/Home/Sum?nums=1&nums=2&nums=3 
http://localhost:54274/Home/GetData?items[0]=volga&items[2]=dnepr&items[1]=don
//если передаем только 1 массив
http://localhost:54274/Home/GetData?[0]=volga&[2]=dnepr&[1]=don
//массив сложных объектов
http://localhost:54274/Home/GetPhones?phones[0].Name=Lumia950&


//передать словарь
http://localhost:54274/Home/GetData?items[germany]=berlin&items[france]=paris&items[spain]=madrid

//сложный объект
http://localhost:54274/Home/GetPhone?myPhone.Price=24000&myPhone.Name=Nexus5X&myPhone.Manufacturer.Name=LG


Home/Square?a=10&h=3// 2 параметра с разными именами
http://localhost:57086/Home/Square?altitude=10&height=3// передача сложных объектов (указываются атрибуты объекта)





применение такого атрибута считается "сильнее" чем определение пути в  Startup #route #router #routing
[Route("Home")]
HomeController{}



[Route("{id:int}/{name:maxlength(10)}")]//http://localhost:xxxx/10/lumia
    public IActionResult Test(int id, string name)


//метод Index контроллера Home будет обрабатывать только запросы http://localhost:xxxx/homepage
[Route("homepage")]
    public IActionResult Index()
[Route("{id:int}/{name:maxlength(10)}")]
    public IActionResult Test(int id, string name)


вот такое:
[Route("main")]
public class HomeController : Controller
[Route("store/{name}")]
    public IActionResult Index(string name)


эквивалент вот такому
public class HomeController : Controller
[Route("main/store/{name}")]
    public IActionResult Index(string name)


controller и action надо указывать в [] скобках
[Route("[controller]/[action]")]
    public IActionResult Index()

[Route("[controller]")]
[Route("[action]")]
[Route("[controller]/[action]/{id?}")]


С помощью атрибутов можно задать несколько маршрутов для одного метода. Например:
[Route("[controller]")]
public class HomeController : Controller
{
   [Route("")]     // сопоставляется с Home
   [Route("Index")] // сопоставляется с Home/Index
   public IActionResult Index()


[Route("Store")]
[Route("[controller]")]
public class HomeController : Controller
{
   [Route("Main")]     // сопоставляется с Home/Main, либо с Store/Main
   [Route("Index")] // сопоставляется с Home/Index, либо с Store/Index
   public IActionResult Index()







#ActionName
//localhost:xxxx/Home/Welcome вместо localhost:xxxx/Home/Hellow
[ActionName("Welcome")]
public string Hello()


#NonController
//не сможет обрабатывать запрос и использоваться как контроллер
[NonController]
public class HomeController : Controller

#NonAction
метод пересанет быть доступным как действие контроллера
[NonAction]
public string Hello()








#маршрутизация #routing
#RouterMiddleware
При этом надо учитывать, что RouterMiddleware не передает выполнение запроса дальше, если хотя бы один из определенных маршрутов совпал со строкой запроса.
#AddRouting
ConfigureServices->
services.AddRouting();


#RouteHandler #RouteBuilder 

Configure->
 // определяем обработчик маршрута (только если нужно определить его как объект, в таком случае мы не будем его указывать в MapRoute)
            var myRouteHandler = new RouteHandler(Handle);
            // создаем маршрут, используя обработчик
            var routeBuilder = new RouteBuilder(app, myRouteHandler);//если делегат надо указывать в MapRoute то тут поставляем только параметр app --(app);

//ТУТ надо применить MapRoute


            // строим маршрут, подключает RouterMiddleware в конвейер обработки запроса
            app.UseRouter(routeBuilder.Build());

#MapRoute
MapRoute(string template, RequestDelegate handler): устанавливает маршрут с шаблоном template, который будет обрабатываться делегатом handler
MapRoute(string name, string template): устанавливает маршрут с именем name и шаблоном template
MapRoute(string template, Action<ApplicationBuilder> action): устанавливает маршрут с шаблоном template, для которого будет выполняться действие action
MapRoute(string name, string template, object defaults): добавляет значения по умолчанию в виде объекта defaults
MapRoute(string name, string template, object defaults, object constraints): добавляет ограничения к маршруту в виде объекта constraints
MapRoute(string name, string template, object defaults, object constraints, object dataTokens): добавляет токены в виде объекта dataTokens




//все MapRoute пишутся только для Handle который будет обработчиком запроса

            // само определение маршрута - он должен соответствовать запросу {controller}/{action}
            routeBuilder.MapRoute("default", "{controller}/{action}");

	//id - необязательный параметр
routeBuilder.MapRoute("default", "{controller}/{action?}/{id?}");

	//устанавливаются значения по умолчанию
routeBuilder.MapRoute("default", "{controller}/{action}/{id?}", new { controller = "home", action = "index" });
routeBuilder.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");

//любое количество параметров
routeBuilder.MapRoute("default", "{controller=Home}/{action=Index}/{id?}/{*catchall}");

//указываем константы
routeBuilder.MapRoute("default", "WH/Ru{controller=Home}/{action=Index}-en/{id?}");

//несколько параметров в сегменте-- http://localhost:56130/Store/Order/lumia-2015
routeBuilder.MapRoute("default", "{controller=Home}/{action=Index}/{name}-{year}");


//сразу указываем делегат который будет выполняться
routeBuilder.MapRoute("{controller}/{action}",
                async context => {
                    context.Response.ContentType = "text/html; charset=utf-8";
                    await context.Response.WriteAsync("двухсегментный запрос");
                });




//если мы подключили #MVC добавление компонентов mvc и определение маршрута
//Метод app.UseMvc() в качестве параметра принимает объект Action<IRouteBuilder> #IRouteBuilder
//Для обработки маршрутов фреймворк предоставляет встроенный класс #MvcRouteHandler
        app.UseMvc(routes =>
        {
//внутри этого делегата писать все пути для MVC

routes.MapRoute("api", "api/get", new { controller = "Home", action = "About" });// для запроса http://localhost:xxxx/api/get

//обрабатываем и сразу пишем
routes.MapRoute("api/get", async context=>
                {
                    await context.Response.WriteAsync("для обработки использован маршрут api/get");
                });


            routes.MapRoute(
                name: "default",
                template: "{controller=Home}/{action=Index}/{id?}");
        });




#UseMvcWithDefaultRoute #UseMvc
метод app.UseMvcWithDefaultRoute(); равносилен конструкции
app.UseMvc(routes =>
{
    routes.MapRoute(
        name: "default",
        template: "{controller=Home}/{action=Index}/{id?}");
});










аналоги MapRoute но для других типов запросов
#MapGet
routeBuilder.MapGet("{controller}/{action}", async (context) =>
{
    await context.Response.WriteAsync("Hello From MapGet!");
});
#MapDelete
см MapGet
#MapPost
см MapGet
#MapPut
см MapGet
#MapVerb
 метод MapVerb() добавляет в качестве первого параметра название типа запроса http, например, "GET" или "POST":
MapVerb(string verb, string template, RequestDelegate handler)
MapVerb(string verb, string template, Action<ApplicationBuilder> action)



#GetRouteData #GetRouteData  #RouteData
рядом с configure можно так

private async Task Handle(HttpContext context)
        {
            var routeValues = context.GetRouteData().Values;
            var action = routeValues["action"].ToString();
            var name = routeValues["name"].ToString();
            var year = routeValues["year"].ToString();
            await context.Response.WriteAsync($"action: {action} | name: {name} | year:{year}");
        }











#ограничения

применяется класс #RegexRouteConstraint 

routeBuilder.MapRoute("default", 
        "{controller}/{action}/{id?}", 
        new { action = "Index" },  // параметры по умолчанию
        new { controller = "^H" } // ограничения регулярки
);


routeBuilder.MapRoute("default", 
        "{controller}/{action}/{id?}", 
        null,
        new { controller = new RegexRouteConstraint("^H"), id = new RegexRouteConstraint(@"\d{2}") }
);



#AlphaRouteConstraint: параметр должен состоять только из алфавитных символов английского алфавита

new {controller=new AlphaRouteConstraint()}

#BoolRouteConstraint: параметр должен иметь значение true или false
new {id=new BoolRouteConstraint()}

#DateTimeRouteConstraint: параметр должен предоставлять объект DateTime
new {id=new DateTimeRouteConstraint()}

#DecimalRouteConstraint: параметр должен предоставлять объект decimal
new {id=new DecimalRouteConstraint()}

#DoubleRouteConstraint: параметр должен предоставлять объект double
new {id=new DoubleRouteConstraint()}

#FloatRouteConstraint: параметр должен предоставлять объект float
new {id=new FloatRouteConstraint()}

#GuidRouteConstraint: параметр должен предоставлять объект Guid
new {id=new GuidRouteConstraint()}

#HttpMethodRouteConstraint: запрос должен представлять определенный тип - Get, Post и т.д.


routeBuilder.MapRoute("default",
     "{controller}/{action}/{id?}",
     null,
     new { httpMethod = new HttpMethodRouteConstraint("POST") }
);
В конструктор HttpMethodRouteConstraint передаются названия допустимых типов запросв. В данном случае маршрут будет обрабатываться только для POST-запросов.

#IntRouteConstraint: параметр должен предоставлять объект int
new {id=new IntRouteConstraint()}

#LengthRouteConstraint: строка, представляющая параметр, должна иметь определенную длину
new
{
    controller = new LengthRouteConstraint(4), // точная длина
    action = new LengthRouteConstraint(3,10) // минимальная и максимальная длина
}

#LongRouteConstraint: параметр должен предоставлять объект long
new {id=new LongRouteConstraint()}

#MaxLengthRouteConstraint / #MinLengthRouteConstraint: определяют максимальную и минимальную длину параметра в символах
new
{
    controller = new MaxLengthRouteConstraint(5),
    action = new MinLengthRouteConstraint(3)
}

#MaxRouteConstraint / MinRouteConstraint: определяют максимальное и минимальное числовое значение для параметра
new {id=new MinRouteConstraint(4)} // минимальное значение - 4

#RangeRouteConstraint: параметр должен предоставлять числовое значение int в определенном диапазоне
new {id=new RangeRouteConstraint(3, 100)} // диапазон от 3 до 100

#RegexRouteConstraint: задает регулярное значение, которому должен соответствовать параметр

#OptionalRouteConstraint: определяет ограничение для необязательного параметра. И если параметр имется в запросе, то вступает в силу внутреннее ограничение, задаваемое через свойство InnerConstraint класса OptionalRouteConstraint

#RequiredRouteConstraint: указывает, что параметр должен обязательно иметь какое-нибудь значение




составные ограничения
#CompositeRouteConstraint 


routeBuilder.MapRoute(
    name: "default",
    template: "{controller}/{action}/{id?}",
    defaults: new { controller="Home", action = "Index" },
    constraints: new
    {
        action =  new CompositeRouteConstraint(new IRouteConstraint[] 
        {
            new AlphaRouteConstraint(),
            new MinLengthRouteConstraint(6)
        })
});



Строчный синтаксис ограничений

routeBuilder.MapRoute("default", "{controller:regex(^H.*)}/{action}/{id?}");
routeBuilder.MapRoute("default", "{controller:length(4)}/{action:alpha}/{id:range(4,100)}");

если нужно составное ограничение то через :
routeBuilder.MapRoute(
    name: "default",
    template: "{controller}/{action:alpha:minlength(6)}/{id?}",
    defaults: new { controller="Home", action = "Index" });



int Соответствие числу
{id:int}

bool Соответствие значению true или false
{active:bool}

datetime Соответствие дате и времени
{date:datetime}

decimal Соответствие значению decimal
{price:decimal}

double Соответствие значению типа double 
{weight:double}

float Соответствие значению типа float 
{height:float}

guid Соответствие значению типа Guid
{id:guid}

long Соответствие значению типа long
{id:long}

minlength(value) Строка должна иметь символов не меньше value
{name:minlength(3)}

maxlength(value) Строка должна иметь символов не больше value 
{name:maxlength(20)}

length(value) Строка должна иметь ровно столько символов, сколько определено в параметре value
{name:length(10)}

length(min, max) Строка должна иметь символов не меньше min и не больше max
{name:length(3, 20)}

min(value) Число должно быть не меньше value
{age:min(3)}

max(value) Число должно быть не больше value
{age:max(20)}

range(min, max) Число должно быть не меньше min и не больше max
{age:range(18, 99)}

alpha Строка должна состоять из одно и более алфавитных символов
{name:alpha}

regex(expression) Строка должна соответствовать регулярному выражению expression
{phone:regex(^\d{{3}}-\d{{3}}-\d{{4}}$)}

required Параметр является обязательным, и его значение должно быть определено
{name:required}





#IRouteConstraint 
создание своих ограничений

public interface IRouteConstraint
{
    bool Match(HttpContext httpContext,
            IRouter route,
            string routeKey,
            IDictionary<string, object> values,
            RouteDirection routeDirection);
}

public class CustomConstraint : IRouteConstraint
{
    private string uri;
    public CustomConstraint(string uri)
    {
        this.uri = uri;
    }
 
    public bool Match(HttpContext httpContext, IRouter route, string routeKey, 
            RouteValueDictionary values, RouteDirection routeDirection)
    {
        return !(uri == httpContext.Request.Path);


string[] positions = new[] { "admin", "director", "accountant" };
//Теперь для соответствия маршруту параметр id должен иметь одно из следующих значений: "admin", "director" или "accountant", при id = new CustomConstraint()
//values-содержит набор значений маршрута
 return positions.Contains(values[routeKey]?.//получаем параметр маршрута, для которого действует ограничение
ToString().ToLowerInvariant());
    }
}

//применение собственного ограничения
routeBuilder.MapRoute("default", 
    "{controller}/{action}/{id?}",
    null,//по умолчанию
    new { myConstraint = new CustomConstraint("/Home/Index/12") }//для граничения того что включено в "{controller}" new { id = new CustomConstraint() });
);





Создание inline-ограничений

ConfigureServices->
//устанавливают сопоставление ограничения "position" с классом PositionConstraint
services.Configure<RouteOptions>(options => 
                options.ConstraintMap.Add("position", typeof(PositionConstraint)));
            services.AddRouting();


Configure->
//все как при обычном ограничении, но меняем
routeBuilder.MapRoute(
                "default", 
                "{controller}/{action}/{id:position?}");






Создание своего маршрута
#IRouter

public interface IRouter 
{
    Task #RouteAsync(RouteContext context);//предназначен для обработки входящих запросов
    VirtualPathData #GetVirtualPath(VirtualPathContext context);//применяется для генерации ссылок в соответствии с данным маршрутом
}


public class AdminRoute : IRouter
    {
        public VirtualPathData GetVirtualPath(VirtualPathContext context)
        {
            throw new NotImplementedException();
        }
 
        public Task RouteAsync(RouteContext context)
        {
            string url = context.HttpContext.Request.Path.Value.TrimEnd('/');
            if (url.StartsWith("/Admin", StringComparison.OrdinalIgnoreCase))
            {
//блокируем дальнейшее выполнение (НЕ будет передаваться дальше по списку маршрутов и компонентов middleware), установив делегат для выполнения
                context.Handler = async ctx =>
                {
                    ctx.Response.ContentType = "text/html;charset=utf-8";
                    await ctx.Response.WriteAsync("Привет admin!");
                };
            }
            return Task.CompletedTask;
        }
    }



применение
configure->
var routeBuilder = new RouteBuilder(app);
 
            routeBuilder.Routes.Add(new AdminRoute());
 
            routeBuilder.MapRoute("{controller}/{action}",
                async context => {
                    context.Response.ContentType = "text/html;charset=utf-8";
                    await context.Response.WriteAsync("двухсегментный запрос");
                });
 
            app.UseRouter(routeBuilder.Build());


















#tag #razor #html #helper #taghelper


#addTagHelper для включения в _ViewImports.cshtml (находится в папке Views) нужно докинуть(должно докидываться само)
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
Первый параметр директивы указывает на tag-хелперы, которые будут доступны во всех представлениях из папки Views, а второй параметр определяет библиотеку хелперов. 
В данном случае директива использует синтаксис подстановок - знак звездочки ("*") означает, что все хелперы из библиотеки Microsoft.AspNetCore.Mvc.TagHelpers.
#removeTagHelper удалить подключенные хелперы
@removeTagHelper "*, Microsoft.AspNetCore.Mvc.TagHelpers"


Если необходимо вывести значение переменной без каких-либо html-элементов, то мы можем использовать специальный снипет <text>:
<text>@i</text>
//вывод строки в конструкции
@if (isEnabled)
{
    @: Добро пожаловать
}


#functions
создание функции в представлении
@functions
{
    public int GetFactorial(int n)
    {
        int result = 1;
        for (int i = 1; i <= n; i++)
            result *= i;
        return result;
    }
}
<div>Факториал числа 6 равен: @GetFactorial(6)</div>









#AnchorTagHelper #a #link #asp- #html #razor #tag #helper
#actionlink->

<a asp-controller="Home" asp-action="Contacts" asp-route-id="5" asp-route-data='new Dictionary<string,string>(){{"id","5"}}'>контакты</a>
<a asp-controller="Home" asp-action="About" asp-host="localhost.com" asp-protocol="https">О сайте</a>
<a asp-route="default">Книги</a>

asp-host - указывает на домен сайта, если нам надо сделать ссылку на другой сайт
asp-protocol - определяет http or https
asp-all-route-data - устанавливает набор значений для параметров
asp-fragment - определяет ту часть хэш ссылки которая идет после символа # Например, "paragraph2" в ссылке "http://mysite.com/#paragraph2"
asp-controller: указывает на контроллер, которому предназначен запрос
asp-action: указывает на действие контроллера
asp-route: указывает на название маршрута
asp-route-[название параметра]: определяет значение для определенного параметра

	





#labelTagHelper #InputTagHelper #TextAreaTagHelper
<form asp-action="Create" asp-anti-forgery="true">

такая конструкция
<label asp-for="Name"></label>
<input type="text" asp-for="Name"></input>
эквивалент такой
@Html.LabelFor(m => m.Price)
        @Html.EditorFor(m => m.Price)


#inputTagHelper
может иметь атрибуты asp-for , asp-format


#TextAreaTagHelper
<textarea asp-for="Name"></textarea>



#SelectTagHelper #select #option #droplist
asp-items---IEnumerable<SelectListItem>
//добавляем базовое значение, остальные закинутся из коллекции
<select asp-for"vl" asp-items="ViewBag.Companies">
<option selected="selected"> базовое значение</option>
</select>



#enum #GetEnumSelectList
public enum DayTime
{
    [Display(Name ="Утро")]
    Morning
}
 <select asp-for="Period" asp-items="Html.GetEnumSelectList<DayTime>()"></select>
или так
<select asp-for="Period" asp-items="@new SelectList(Enum.GetNames(typeof(DayTime)))"></select>






#form #FormTagHelper

#asp-controller: указывает на контроллер, которому предназначен запрос
#asp-action: указывает на действие контроллера
#asp-area: указывает на название области, в которой будет вызываться контроллер для обработки формы
#asp-antiforgery: если имеет значение true, то для этой формы будет генерироваться antiforgery token
#asp-route: указывает на название маршрута
#asp-all-route-data: устанавливает набор значений для параметров
#asp-route-[название параметра]: определяет значение для определенного параметра

Все остальные теги, которые используются на формах, имеют два общих атрибута:
#asp-for: указывает, для какого свойства модели создается элемент
#asp-format: устанавливает формат ввода для элемента. например для input label ="{0:dd-MM-yyy}"






#validate 
подключить, после jquery
<script src="~/lib/jquery-validation/dist/jquery.validate.js"></script>
<script src="~/lib/jquery-validation-unobtrusive/jquery.validate.unobtrusive.js"></script>

Views/Shared по умолчанию добавляется частичное представление _ValidationScriptsPartial.cshtml, которое уже содержит подключение вышеопределенных скриптов. Поэтому вместо прямого подключения скриптов можно подключать данное частичное представление
#TODO взял из комментов так что ХЗ. ---->>>что бы форма не отправлялась на сервер Необходимо подключить в Layout ValidationScriptsPartial при помощи <partial name="_ValidationScriptsPartial"/>


#data-#valmsg #TODO хз что это
<span data-valmsg-for="Name" data-valmsg-replace="true">...

asp-#validation-#summary #ValidationSummaryTagHelper


<div asp-validation-summary="ModelOnly">...
{
None - ошибки валидации не отображаются
ModelOnly - отображается только шибка валидации уровня модели, ошибки для отдельных свойств не отображаются
All - отображает все ошибки
}


<div class="validation" asp-validation-summary="ModelOnly"/>
сгенерирует
<div class="validation validation-summary-valid" data-valmsg-summary="true">
    <ul>
        <li style="display:none"></li>
    </ul>
</div>
в список будут добавляться ошибки



#ValidationMessageTagHelper
#asp-validation-for
<input type="text" asp-for="Name" />
<span asp-validation-for="Name" />

span с таким атрибутом сгенерит код и будет содержать ошибки
<span class="field-validation-valid" data-valmsg-for="Name" data-valmsg-replace="true" />





#TODO если одну форму заменили на другую то ВОЗМОЖНО ее валидацию можно пофиксить так -- $.validator.unobtrusive.parse('form');, где form идентификатор формы.








#js #ajax #jquery #error #valid #ModelState #IsValid
обработка ошибок js которые устанавливаются через ModelState.AddModelError
if (!ModelState.IsValid)
                return BadRequest(ModelState);

$.ajax({
                url: "api/users",
                contentType: "application/json",
                method: "POST",
                data: JSON.stringify({
                    name: userName,
                    age: userAge
                }),
                success: function (user) {
                    reset();
                    $("table tbody").append(row(user));
                },
                error: function (jxqr, error, status) {
                    // парсинг json-объекта
                    console.log(jxqr);
                    if(jxqr.responseText===""){
                        $('#errors').append("<h3>" + jxqr.statusText + "</h3>");
                    }
                    else{
                        var response = JSON.parse(jxqr.responseText);
                        // добавляем общие ошибки модели
                        if (response['']) {
 
                            $.each(response[''], function (index, item) {
                                $('#errors').append("<p>" + item + "</p>");
                            });
                        }
                        // добавляем ошибки свойства Name
                        if (response['Name']) {
 
                            $.each(response['Name'], function (index, item) {
                                $('#errors').append("<p>" + item + "</p>");
                            });
                        }
                    }
                     
                    $('#errors').show();
                }
            })
















#attr
#Required #ErrorMessage 
Применение этого атрибута к свойству модели означает, что данное свойство должно быть обязательно установлено.
 [Required (ErrorMessage = "Не указано имя")]
        public string Name { get; set; }



#RegularExpression
Использование данного атрибута предполагает, что вводимое значение должно соответствовать указанному в этом атрибуте регулярному выражению.

[RegularExpression(@"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}", ErrorMessage = "Некорректный адрес")] #mail
public string Email { get; set; }


#StringLength
[StringLength(50, MinimumLength = 3, ErrorMessage = "Длина строки должна быть от 3 до 50 символов")]


#Range
[Range(1, 110, ErrorMessage = "Недопустимый возраст")]

#Compare #Password 
[Required]
public string Password { get; set; }
[Compare("Password", ErrorMessage = "Пароли не совпадают")]
public string PasswordConfirm { get; set; }


[#CreditCard]

[#EmailAddress]
[EmailAddress (ErrorMessage = "Некорректный адрес")]
[#Phone]

[Url]


#Remote
Атрибут Remote из пространства имен Microsoft.AspNetCore.Mvc; для валидации свойства выполняет запрос на сервер к определенному методу контроллера. И если требуемый метод контроллера вернет значение false, то валидация не пройдена.
[Remote(action: "CheckEmail", controller: "Home", ErrorMessage ="Email уже используется")]

public class HomeController : Controller
{
    [AcceptVerbs("Get", "Post")]
    public IActionResult CheckEmail(string email)
    {
        if (email == "admin@mail.ru" || email == "aaa@gmail.com")
            return Json(false);
        return Json(true);
    }







создание собственных атрибутов валидации
#ValidationAttribute 
public class PersonNameAttribute : ValidationAttribute
{
    public PersonNameAttribute()
    {
    }
    public override bool IsValid(object value)
    {
        приведение типов для value и проверка, если все норм то return true; иначе return false;
    }
}

такого рода собственный атрибут валидации можно применить как к свойству так и к классу
 [PersonName(new Entry(), ErrorMessage ="Недопустимое имя")]
    public string Name { get; set; }




#IValidatableObject
#Самовалидация представляет собой процесс, при котором модель запускает механизм валидации из себя самой. И сама инкапсулирует всю логику валидации.
// Если в конструктор ValidationResult передается только сообщение об ошибке, тогда данная ошибка будет относиться ко всей модели в целом. Однако с помощью второго параметра можно указать конкретный список свойств модели, к которым относится ошибка
public class Person : IValidatableObject
{
public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
    {
        List<ValidationResult> errors = new List<ValidationResult>();
            errors.Add(new ValidationResult("Введите имя!", new List<string>() { "Name" }));
            errors.Add(new ValidationResult("Введите электронный адрес!"));
       
        return errors;
    }




#css для валидации
.field-validation-error {color: #b94a48;}
.field-validation-valid {    display: none;}
input.input-validation-error {    border: 1px solid #b94a48;}
input[type="checkbox"].input-validation-error {    border: 0 none;}
.validation-summary-errors {    color: #b94a48;}
.validation-summary-valid {    display: none;}







#валидация на стороне сервера

если свойство не может принимать null и его не установить то оно не будет default, модель не пройдет валидацию  =>> является по умолчанию Required
на сервере проверяется так if (ModelState.IsValid) //#ModelState #IsValid

Фреймворк MVC валидирует свойства объекта, пока количество ошибок не достигнет предельного максимального количества (по умолчанию это 200 ошибок). 
Но мы можем настроить это поведение, определив нужное количество ошибок в методе ConfigureServices() класса Startup:
services.AddMvc(options => options.MaxModelValidationErrors = 50);

//добавляем ошибку для конкретного свойства
if (string.IsNullOrEmpty(person.Name))
    {
        ModelState.AddModelError("Name", "Некорректное имя");
    }
//добавляем ошибку уровня модели
ModelState.AddModelError("", "Имя и пароль не должны совпадать");
























#attr
#аннотация #отображение
System.ComponentModel. #DataAnnotations

#Display
изменит подпись для свойства при @Html.DisplayForModel() или <label asp-for="Name"></label>
 [Display(Name="Имя и фамилия")]
        public string Name { get; set; }




#ScaffoldColumn
Атрибут ScaffoldColumn позволяет скрыть отображение свойства при использовании хелперов Html.DisplayForModel() и Html.EditorForModel()

#DataType
Атрибут DataType позволяет предоставлять среде выполнения информацию об использовании свойства
[DataType(DataType.Password)]
public string Password { get; set; }

DataType----
#CreditCard: отображает номер кредитной карты
#Currency: отображает текст в виде валюты
#Date: отображает только дату, без времени
#DateTime: отображает дату и время
#Time: отображает только время
#Duration: отображает число - некоторую продолжительность
#EmailAddress: отображает электронный адрес
#Password: отображает символы с использованием маски
#PhoneNumber: отображает номер телефона
#PostalCode: отображает почтовый индекс
#ImageUrl: представляет путь к изображению
#Url: отображает строку Url
#MultilineText: отображает многострочный текст (элемент textarea)
#Text: отображает однострочный текст



#UIHint
Данный атрибут указывает, какой будет использоваться шаблон отображения при создании разметки html для данного свойства. Шаблон управляет, как свойство будет рендерится на странице

#Boolean
Хелперы редактирования создают флажок (checkbox) для булевых значений. Для значений типа bool? (nullable) создается элемент select с параметрами True, False и Not Set
Хелперы отображения генерируют те же элементы html, что и хелперы редактирования, только с атрибутом disabled

#Collection
Используется соответствующий шаблон для рендеринга каждого элемента коллекции. Причем элементы могут быть разных типов.

#Decimal
Хелперы редактирования создают однострочное текстовое поле - элемент input

#EmailAddress
Хелперы редактирования создают однострочное текстовое поле.
Хелперы отображения генерируют элемент ссылка, где атрибут href имеет значение mailto:url

HiddenInput
Создается скрытое поле - элемент hidden input

#Html
Хелперы редактирования создают однострочное текстовое поле.
Хелперы отображения просто показывают текст

#MultilineText
Хелперы редактирования создают многострочное текстовое поле (элемент textarea)

#Object
Хелперы изучают свойства объекта и выбирают наиболее подходящие для него шаблоны.

#Password
Хелперы редактирования создают текстовое поле для ввода символов с использованием маски
Хелперы отображения показывают пароль как есть, без использования маски

#String
Хелперы редактирования создают однострочное текстовое поле

#Url
Хелперы редактирования создают текстовое поле
Хелперы отображения создают элемент ссылки для данного Url

[UIHint("Url")] // отрисует содержимое ссылкой
        public string HomePage { get; set; }



#DisplayFormat #DataFormatString

[DisplayFormat(DataFormatString = "{0:dd.MM.yyyy}", ApplyFormatInEditMode = true)]
public DateTime DateOfBirth { get; set; }
свойство DataFormatString указывает на сам формат
Свойство #ApplyFormatInEditMode позволяет применять форматирование к свойству даже в режиме редактирования









#LinkTagHelper  #css #link #js #asp- 
см также ScriptTagHelper
используется для подключения файлов стилей


asp-append-version: если имеет значение true, то к пути к названию файла стиля добавляется номер #версии #version
asp-fallback-href: указывает вспомогательный путь к файлу стиля, который используется, если загрузка файла, указанного в атрибуте href пройдет неудачно
asp-fallback-test-class: определяет класс, который используется для теста загрузки стиля из атрибута href
asp-fallback-test-property: определяет свойство, которое используется для тестирования загрузки стиля из атрибута href
asp-fallback-test-value: определяет значение свойства из атрибута asp-fallback-test-property, которое используется для теста загрузки стиля из атрибута href
asp-href-include: определяет через запятую набор шаблонов подключаемых файлов стилей
asp-href-exclude: определяет через запятую набор шаблонов для тех файлов, которые следует исключить из загрузки
asp-fallback-href-include: определяет через запятую набор шаблонов файлов, которые подключаются в том случае, если загрузка основного файла стиля из атрибута href прошла неудачно
asp-fallback-href-exclude: определяет через запятую набор шаблонов файлов, которые следует исключить из загрузки в том случае, если загрузка основного файла стиля из атрибута href прошла неудачно



пример с объяснением
<link rel="stylesheet" href="https://ajax.aspnetcdn.com/ajax/bootstrap/3.0.0/css/bootstrap.min.css"
                  asp-fallback-href="~/lib/bootstrap/dist/css/bootstrap.min.css"
                  asp-fallback-test-class="hidden" asp-fallback-test-property="visibility" asp-fallback-test-value="hidden" />

Здесь атрибут href указывает на файл стилей фреймворка bootstrap, который располагается в CDN. Если веб-браузер не сможет загрузить данный файл, то загружается локальный файл стилей, путь к которому указан в атрибуте asp-fallback-href. Чтобы протестировать, что файл стилей из атрибута href нормально загрузился, используются атрибуты asp-fallback-test-class, asp-fallback-test-property и asp-fallback-test-value.




#ScriptTagHelper #js #script #css
<script asp-src-include="~/js/**/*.js" asp-scr-exclude="~/js/util/**/*.js"></script>




подключение всех файлов из папки и подпапок
<link asp-href-include="~/css/**/*.css"/>
подключение всех файлов из папки БЕЗ подпапок
"~/js/*.js"


? - любой символ кроме слеша
Например выражение js/script?.js будет соответствовать таким файлам как js/script1.js или js/scriptX.js, но не js/script35.js
* - любое количество сомволов кроме слеша
Например выражение js/*.js будет соответствовать таким файлам как js/script.js или js/scriptX25.js, но не js/bootstrap/script.js
** - любое количество символов включая слеш
Например выражение js/**/script.js будет соответствовать таким файлам как js/script.js или js/bootstrap/script.js, но не js/script35.js


для таких подключаемых блоков
href-css ..  src-js
asp-append-version если имеет значение true то к пути к файлу скрипта добавляется номер версии
asp-fallback-(scr|href) - указывает вспомогательный путь к скрипту, который используется если загрузка скрипта указанного в утрибудет src пройдет неудачно
asp-fallback-test - определяет выражение, которое тестирует загрузку основного скрипта из атрибута src (для link доступны -class -property -value)
asp-(src|href)-include - определяет шаблон подключаемых файлов через запятую можно задать несколько шаблонов

asp-(src|href)-exclude - определяет через запятую набор шаблонов для тех файлов которые следует исключить из загрузки
asp-fallback-(src|href)-include - определяет через запятую набо шаблонов файлов которые подключаются в том случае если загрузка основного скрипта из атрибута src прошла неудачно
asp-fallback-(src|href)-exclude - определяет через запятую набо шаблонов файлов которые следует исключить из загрузки в том случае если загрузка основного скрипта из атрибута scr прошла неудачно
asp-route-[название параметра]: определяет значение для определенного параметра

<script asp-src-include="~/js/**/*.js" asp-src-exclude="~/js/util/**/*.js"></script>
<ink rel="stylesheet" href="~/css/site.css" asp-append-version="true" />


пример с объяснением

<script src="https://ajax.aspnetcdn.com/ajax/jquery/jquery-2.2.0.min.js"
        asp-fallback-src="~/lib/jquery/dist/jquery.min.js"
        asp-fallback-test="window.jQuery"
        crossorigin="anonymous"
        integrity="sha384-K+ctZQ+LL8q6tP7I94W+qzQsfRV2a+AfHIi9k8z8l9ggpc8X+Ytst4yBo/hH+8Fk">
</script>
Данный элемент представляет не просто стандартный тег script, но и класс тег-хэлпера ScriptTagHelper. Атрибут src указывает на скрипт, который мы хотим подключить. 
Логично подключать скрипты из CDN, чтобы сократить нагрузку на собственный сайт. Но CDN может не работать, например, произойдет какой-то временный сбой, и чтобы определить, 
что скрипт загружен, применяется атрибут asp-fallback-test. Он тестирует загрузку с помощью выражения window.jQuery. Если объект window.jQuery определен, то загрузка скрипта прошла успешно. 
Если же нет, то загружается скрипт, который указан в атрибуте asp-fallback-src.






#EnvironmentTagHelper

определение группы скриптов которые будут загружаться
При обработке данного тега фреймворк использует значение переменной окружения ASPNETCORE:ENVIRONMENT. При разработке по умолчанию эта переменная имеет значение "Development". В частности, мы можем увидеть ее значение, открыв свойства проекта и далее вкладку Debug:

например в _Layout.cshtml
<environment names="Development">
    <link 111111/>
</environment>
<environment names="Staging,Production">
<link 22222222/>
</environment>







#CacheTagHelper #cache #кеш #кэш
CacheTagHelper оборачивает контент представления и позволяет кэшировать его в памяти сервера. Он использует тег <cache>, и весь контент, определенный внутри этого тега, кэшируется в памяти. 
Перед кэшированием тег-хелпер проверяет, сохранен ли уже данный контент в MemoryCache. Если контент имеется в кэше, тогда движку Razor посылается контент из кэша.
 Если же данного контента не оказывается в кэше, тогда Razor обрабатывает контент, а тег-хелпер сохраняет контент в memory cache для последующего использования
<cache expires-after="@TimeSpan.FromMinutes(5)">  
    @Html.Partial("BookInfo")
</cache> 

атрибуты
<cache expires-after="@TimeSpan.FromMinutes(10)"> 
#expires-after указывает, на какое время контент будет кэшироваться. В качестве значения атрибут принимает объект TimeSpan:

<cache expires-on="@DateTime.Now.AddDays(1)"> 
#expires-on указывает, когда именно истечет срок хранения контента в кэше. В качестве значения атрибут принимает объект DateTime

<cache expires-sliding="@TimeSpan.FromMinutes(10)">  
#expires-sliding определяет, через какое время с момента последнего посещения контент будет удаляться из кэша. В качестве значения атрибут принимает объект TimeSpan

<cache expires-after="@TimeSpan.FromMinutes(15)" vary-by-user="true">  
#vary-by-user позволяет кэшировать контент отдельно для каждого залогиненного пользователя. При кэшировании к ключу контента в кэше добавляется логин пользователя. В качестве значения атрибут принимает логическое значение true (надо кэшировать по пользователю) или false

<cache expires-after="@TimeSpan.FromMinutes(15)" vary-by-route="id"> 
#vary-by-route позволяет кэшировать различные версии одного и того же контента в зависимости от параметров маршрута. В качестве значения атрибут принимает названия параметров через запятую, которые будут учитываться при кэшировании. И затем в кэше для контента к ключу будет добавляться значение параметров. В данном случае будут создаваться разные версии одного и того же контента для разных значений параметра id

<cache vary-by-query="name"> 
#vary-by-query позволяет кэшировать различные версии контента в зависимости от значений параметров, переданных в запросе. В качестве значения атрибуту передается список параметров через запятую. При кэшировании к ключу контента в кэше добавляется значение этих параметров

<cache vary-by-cookie="pubid"> 
#vary-by-cookie позволяет кэшировать различные версии одного и того же контент в зависимости от значений, которые хранятся в куках. В качестве значения атрибут принимает названия куков через запятую, которые будут учитываться при кэшировании. В ходе кэширования значения этих кук будут добавляться к ключам контента в кэше

<cache vary-by-header="User-Agent"> 
#vary-by-header позволяет кэшировать различные версии контента в зависимости от значений заголовков запроса. В качестве значения атрибуту передается название заголовка запроса. Например, для кэширования разных версий контента для разных браузеров может использоваться заголовок User-Agent

<cache vary-by="@ViewBag.Id"> 
#vary-by позволяет кэшировать различные версии контента в зависимости от произвольного строкового значения. Например, кэшируем в зависимости от значения ViewBag.Id

<cache vary-by-user="true" priority="@Microsoft.Extensions.Caching.Memory.CacheItemPriority.Normal">
Определяет приоритет кэшируемого контента. Приоритет может иметь значение, если для размещения кэша не хватает памяти. В этом случае из кэша могут удаляться некоторые объекты. И чем ниже приоритет, тем больше вероятность что данные объекты будут удалены при нехватке памяти.
Атрибут priority принимает одно из значений перечисления Microsoft.Extensions.Caching.Memory.CacheItemPriority
Low: низкий приоритет
High: высокий приоритет
NeverRemove: контент никогда не удаляется из кэша
Normal: средний приоритет


















создание своего #тэг #хэлпера #TagHelper
см также TagBuilder

для того что бы этим можно было пользоваться нужно в
Views/_ViewImports.cshtml добавить  ... где TagHelpersApp - название проекта приложения
@addTagHelper "*, TagHelpersApp"
//если надо указать явно что подключать то 
@addTagHelper "TagHelpersApp.TagHelpers.VkTagHelper, TagHelpersApp"


!!!!!!!стиль названий -lower kebab
Например, атрибуту go-to будет соответствовать свойство GoTo. Или тегу <book-info> будет соответствовать класс хелпера BookInfoTagHelper


применять вот так 
<vk  group="str"></vk>
//можно передавать сложные объекты но нужно  указать @using на namespace объекта. (в самом классе все будет точно также как и при передаче простого типа)
<vk info='new LinkInfo{Color="red", FontFamily="Verdana", FontSize=18}'>Група в вк</vk>
//в cshtml - var g_1=new List<Entry>();
<vk info='g_1'>Група в вк</vk>


//Если tag-хелпер содержит оба метода: и Process(), и ProcessAsync(), то вызываться будет именно метод ProcessAsync().

using Microsoft.AspNetCore.Razor.TagHelpers;

//класс должен оканчиваться на суффикс TagHelper
public class VkTagHelper : TagHelper
{
private const string address = "https://vk.com";
//теперь это свойство можно установить из атрибута group(по названию свойства)
public string Group { get; set; }


//
dependency injection в тэг хелпер
//с помощью таких атрибутов автоматически получаем контекст, доступно только для свойств
[ #ViewContext]
        [ #HtmlAttributeNotBound] //отменяет заполнение свойства из атрибутов 
        public ViewContext ViewContext { get; set; }
 
IHostingEnvironment environment;
        // получаем сервис IHostingEnvironment
        public VkTagHelper(IHostingEnvironment env)
        {
            environment = env;
        }


//переопределяем метод 
   public override void Process(TagHelperContext context, TagHelperOutput output)
    {
output.TagName = "a";    // заменяет тег <vk> тегом <a>
        // присваивает атрибуту href значение из address
        output.Attributes.SetAttribute("href", address);
        output.Content.SetContent("Группа в ВК");
    }

//Если в tag-хелпер должен выполнять какие-то асинхронные операции, например, обращатьс к базе данных или к файлу в асинхронном режиме, то вместо метода Process() мы можем переопределить другой метод класса TagHelper - метод ProcessAsync()
public override async Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
        {
            output.TagName = "div";
            // получаем вложенный контекст из дочерних tag-хелперов
            var target = await output.GetChildContentAsync();
            var content = "<h3>Социальные сети</h3>" + target.GetContent();
            output.Content.SetHtmlContent(content);
        }

}




#TagHelperOutput

Для управления выводом хелпера используется объект TagHelperOutput, который передается в качестве параметра в метод Process tag-хелпера. Его свойства позволяют управлять генерацией элемента html:
#TagName: указывает, какой элемент html будет создаваться вместо тега хелпера
#TagMode: устанавливает формат создаваемого элемента (с одним или с двумя тегами)
принимает объект перечисления с 1м из значений
#StartTagAndEndTag: элемент имеет оба тега
#SelfClosing: элемент содержит самозакрывающийся тег
#StartTagOnly: элемент имеет только открывающий тег

если создаем тэг так(закрытие при создании) <vk /> то и создастся тэгточно также <a href="https://vk.com"> , что не всегда правильно

меняем
public override void Process(TagHelperContext context, TagHelperOutput output)
        {
            output.TagName = "a";
            output.Attributes.SetAttribute("href", address);
            output.Content.SetContent("Группа в ВК");
            output.TagMode = TagMode.StartTagAndEndTag;




#Attributes: представляет коллекцию атрибутов, устанавливаемых у создаваемого элемента html
#Content: представляет содержимое генерируемого элемента html в виде объекта TagHelperContent
#PreContent: представляет содержимое, которое устанавливается перед создаваемым элементом html
#PostContent: представляет содержимое, которое устанавливается после создаваемого элемента html
#PreElement: представляет html-элемент, который добавляется перед создаваемым элементом html
#PostElement: представляет html-элемент, который добавляется после создаваемого элемента html



#TagHelperContent
методы-
#SetContent(text): устанавливает текстовое содержимое элемента
#SetHtmlContent(html): устанавливает вложенный html-код элемента
#Append(text): добавляет к текстовому содержимому элемента некоторый текст
#AppendHtml(html): добавляет к внутреннему коду элемента некоторый код html
#Clear(): очищает элемент

output.TagName = "a";
             
        output.Attributes.SetAttribute("href", address);
        output.Content.SetContent("Группа в ВК");
        output.TagMode = TagMode.StartTagAndEndTag;
        output.PreElement.SetHtmlContent("<h3>Социальные сети</h3>");
        output.PostElement.SetHtmlContent("<p>Элемент после ссылки</p>");




#SuppressOutput
позволяет не обрабатывать тег
То есть при применении этого метода тег не будет обрабатываться, и для него не будет создаваться никакой html-разметки на веб-странице

public override void Process(TagHelperContext context, TagHelperOutput output)
    {
        if (!Condition)
            output.SuppressOutput();
        else
            output.TagName = "a";
    }







#attr
для тегов


[ #ViewContext] #TODO
        [ #HtmlAttributeNotBound] //отменяет заполнение свойства из атрибутов 
public ViewContext ViewContext { get; set; }

#HtmlTargetElement #HtmlTargetElementAttribute 


определяет следующие свойства:
#Attributes: указывает, что tag-хелпер применяется только к тем элементам, которые имеют определенные атрибуты.
#ParentTag: указывает, что tag-хелпер применяется только к тем элементам, которые определены внутри определенного элемента
#TagStructure: указывает, что tag-хелпер применяется только к тем элементам, которые соответствуют определенному значению из перечисления TagStructure: Unspecified, NormalOrSelfClosing (стандартный или самозакрывающийся элемент) и WithoutEndTag (элемент без закрывающего тега)




//Атрибут #HtmlTargetElement указывает, что класс будет применяться к элементам, у которых установлен атрибут header. Важно, что название хелпера опять же соответствует целевому объекту - атрибуту header.
using Microsoft.AspNetCore.Razor.TagHelpers;
 
[HtmlTargetElement(Attributes = "header")]
//можно несколько, В этом случае элемент должен иметь сразу два атрибута: header и divtitle. 
//[HtmlTargetElement(Attributes = "header, divtitle")] //
//можно указать к какому элементу будет применяться
//[HtmlTargetElement("article-header")] //-- <article-header>Заголовок!</article-header>
//будет применяться только к элементам в элементах form
//[HtmlTargetElement(ParentTag ="form")]
//указываем несколько
//[HtmlTargetElement("form-header", ParentTag ="form", Attributes ="form-title")]
public class HeaderTagHelper : TagHelper
{
    public override void Process(TagHelperContext context, TagHelperOutput output)
    {
        output.TagName = "h2";
        output.Attributes.RemoveAll("header");
    }
}
<div header>Первый параграф</div> заменит на <h2>Первый параграф</h2>












#helper #хелпер 
Microsoft.AspNetCore.Mvc.Rendering. #IHtmlHelper #HtmlString
создать папку #App_Code. Затем в эту папку добавим новый класс ListHelper

public static class ListHelper
    {
        public static HtmlString CreateList(this IHtmlHelper html, string[] items)
        {
            return new HtmlString("HTML");
        }
    }


вызвать в представлении так

@Html.CreateList(cities)
@ListHelper.CreateList(Html, countries)




#TagBuilder
см также TagHelper
Microsoft.AspNetCore.Mvc.Rendering.TagBuilder

#Append #AppendHtml #InnerHtml #WriteTo #HtmlEncoder
public static HtmlString CreateList(this IHtmlHelper html, string[] items)
        {
            TagBuilder ul = new TagBuilder("ul");
            
                TagBuilder li = new TagBuilder("li");
                // добавляем текст в li
                li.InnerHtml.Append(item);
                // добавляем li в ul
                ul.InnerHtml.AppendHtml(li);
            
            ul.Attributes.Add("class", "itemsList");
            var writer = new System.IO.StringWriter();
            ul.WriteTo(writer, HtmlEncoder.Default);
            return new HtmlString(writer.ToString());
        }


Свойство #InnerHtml позволяет установить или получить содержимое тега в виде строки. Чтобы манипулировать этим свойством, можно вызвать один из методов:
#Append(string text): добавление строки теста внутрь элемента
#AppendHtml(IHtmlContent html): добавление в элемент кода html в виде объекта IHtmlContent - это может быть другой объект TagBuilder
#Clear(): очистка элемента
#SetContent(string text): установка текста элемента
#SetHtmlContent(IHtmlContent html): установка внутреннего кода html в виде объекта IHtmlContent

Свойство #Attributes позволяет управлять атрибутами элемента
Метод #MergeAttribute() позволяет добавить к элементу один атрибут
Метод #AddCssClass() позволяет добавить к элементу класс css
Метод #WriteTo() позволяет создать из элемента и его внутреннего содержимого строку при помощью объектов TextWriter и HtmlEncoder.



#razor
Html. #BeginForm 

@using(Html.BeginForm("Create", "Home", FormMethod.Post))
если вызов страницы с формой и отправка формы осуществляется одним и тем же действием (например разделены атрибутами get post). В этом случае можно не указывать в хелпере Html.BeginForm параметры
@using(Html.BeginForm())



Html. #TextBox 
@Html.TextBox("Price","", new { type="number" })
 <input type="number" name="Price" />



Html. #Label 
Html.Label("Name", "Модель")
<label for="Name">Модель</label>


Html. #TextArea 
@Html.TextArea("text", "привет мир")
<textarea cols="20" id="text" name="text" rows="2">привет мир</textarea>
@Html.TextArea("text", "привет мир", 5, 50, null)
<textarea cols="50" id="text" name="text" rows="5">привет мир</textarea>




Html. #Hidden 
@Html.Hidden("PhoneId", "2")
<input id="PhoneId" name="PhoneId" type="hidden" value="2" />


Html. #Password
@Html.Password("UserPassword", "val")
<input id="UserPassword" name="UserPassword" type="password" value="val" />



Html. #RadioButton #Radio
@Html.RadioButton("color", "red")
<span>красный</span> <br />
@Html.RadioButton("color", "blue")
<input id="color" name="color" type="radio" value="red" />
<span>красный</span> <br />
<input id="color" name="color" type="radio" value="blue" /> 



Html. #CheckBox 
@Html.CheckBox("Enable", false)
сгенерит 2 элемента
<input id="Enable" name="Enable" type="checkbox" value="true">
<input name="Enable" type="hidden" value="false">




Html. #DropDownList #SelectListItem #select  #SelectList 
Объект SelectListItem имеет свойства Text (отображаемый текст), Value (само значение, которое может не совпадать с текстом) и Selected. 
@Html.DropDownList("phone", new SelectList(new string[] { "iPhone 7 Pro", "Galaxy 7 Edge", "HTC 10", "Honor 5X" }), "Выберите модель")
<select id="phone" name="phone"><option value="">Выберите модель</option></select>

List<Phone> phones
ViewBag.Phones = new SelectList(phones, "Id", "Name");
@Html.DropDownList("phoneid", ViewBag.Phones as SelectList)




Html. #ListBox #MultiSelectList
<select />, но при этом делает возможным множественное выделение элементов (то есть для атрибута multiple устанавливается значение multiple)

@Html.ListBox("phones", new MultiSelectList(new string[] { "iPhone 7 Pro", "Galaxy 7 Edge", "HTC 10", "Honor 5X" }))
<select id="phones" multiple="multiple" name="phones">



Html. #GetEnumSelectList
выпадающего списка по перечислению


 public enum TimeOfDay
    {
        [Display(Name ="Утро")]
        Morning,

 @Html.DropDownList("daytime", Html.GetEnumSelectList(typeof(TimeOfDay)))



@Html.TextBoxFor(m=>m.Price, "", new { type = "number" })

#Display
Создает элемент разметки для отображения значения указанного свойства модели: Html.Display("Name")

#DisplayFor
Строго типизированный аналог хелпера Display: Html.DisplayFor(m => m.Name)

#Editor
Создает элемент разметки для редактирования указанного свойства модели: Html.Editor("Name")

#EditorFor
Строго типизированный аналог хелпера Editor: Html.EditorFor(m => m.Name)

#DisplayText
Создает выражение для указанного свойства модели в виде простой строки: Html.DisplayText("Name")

#DisplayTextFor


#DisplayForModel
Создает поля для чтения для всех свойств модели: Html.DisplayForModel()

#DisplayTextForModel
Создает поля для чтения для всех свойств модели в виде строки

#EditorForModel
Создает поля для редактирования для всех свойств модели: Html.EditorForModel()










#a #href #link

<a href="~/Home/Index/3" />

Html. #ActionLink  

ссылаем на тот же контроллер в котором текущее представление
@Html.ActionLink("О сайте", "About")

//другой контроллер +параметры
@Html.ActionLink("Все книги", "Index", "Book", new { id=10}, null)


Html. #RouteLink
@Html.RouteLink("Все книги", new { controller = "Book", action = "Index", author = "Толстой", id = 10 }, new { id = "Tolstoi", @class = "link" })

// если есть MapRoute с именем Default
@Html.RouteLink("Все книги","Default",new { action = "Show" })


#url #uri

используют систему маршрутизации
#Action
вернет url до страницы
@Url.Action("Index", "Book", new { author = "Толстой", id = 10 }, null)

#Content
преобразует относительные пути в абсолютные
<script src='@Url.Content("~/lib/jquery/dist/jquery.js")'></script>

#RouteUrl
@Url.RouteUrl(new { controller = "Book", action = "Index", author = "Толстой", id = 10 })







#mvc
ConfigureServices->
services.AddMvc();


Configure->
app.UseMvc(routes =>
        {
            routes.MapRoute(
                name: "default",
                template: "{controller=Home}/{action=Index}/{id?}");
        });



папка Controllers

public class HomeController : Controller
    {
        public IActionResult Index()
        {
            return View();
        }
    }


папка Views-> папка Home ->Razor View










#db  #ef #efc  #context #entity #framework 
#DefaultConnection #Configuration #GetConnectionString #connection #AddDbContext #context



Microsoft.EntityFrameworkCore. #DbContext

controller->
MobileContext db;
в контроллер конструктор
public HomeController(MobileContext context){
db=context;
}





public class MobileContext : DbContext
    {
//каждая строка включает не только саму сущность но и ее зависимости(все связанные с ней сущности)
        public DbSet<Phone> Phones { get; set; }
        public DbSet<Order> Orders { get; set; }
 
        public MobileContext(DbContextOptions<MobileContext> options)
            : base(options)
        {
//по определению моделей будет создаваться база данных (если она отсутствует)
            Database.EnsureCreated();//создаст БД если ее нет, это лучше не использовать тк может сломать миграции
        }

protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // использование Fluent API см по тегу fluent
        base.OnModelCreating(modelBuilder);
    }

//если не настраиваем строку подключения через конфиг и если не передаем объект #DbContextOptions в конктруктор(если только в конструктор, то его придется каждый раз настраивать и передавать руками): public MobileContext(){
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlServer("Server=(localdb)\\mssqllocaldb;Database=helloappdb;Trusted_Connection=True;");
        }


    }


//#ConnectionStrings #GetConnectionString
в appsettings.json->
добавить в внешние скобки "ConnectionStrings": 
{
"ConnectionStrings": {
    "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=mobilestoredb;Trusted_Connection=True;MultipleActiveResultSets=true"
  },
.....
}


Startup.cs. В нем нам надо изменить метод ConfigureServices()
public void ConfigureServices(IServiceCollection services)
        {
// получаем строку подключения из файла конфигурации
            string connection = Configuration.GetConnectionString("DefaultConnection");
 // добавляем контекст MobileContext в качестве сервиса в приложение
            services.AddDbContext<MobileContext>(options => options.UseSqlServer(connection));
            services.AddMvc();
        }




//если выбираем способ через передачу в конструктор
var optionsBuilder = new DbContextOptionsBuilder<ApplicationContext>();
var options = optionsBuilder.UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=helloappdb;Trusted_Connection=True;").Options;
using (ApplicationContext db = new ApplicationContext(options))







#migration #миграция
//консоль диспетчера пакетов
добавить в проект Microsoft.EntityFrameworkCore.Tools
Add-Migration уникальное_название_миграции
//выполняем
Update-Database

//в конструкторе бд, это создает бд если ее нет, но может сломать миграции
//#err с такой ошибкой There is already an object named 'AspNetRoles' in the database
Database.EnsureCreated()



#create
создание бд
можно создавать через ->seed и можно через консоль
И в конце создадим миграции и базу данных. Для этого построим проект, откроем окно Package Manager Console и последовательно введем в него команду на создание миграции:
"Add-Migration Initial
И также введем команду для создания базы данных:
"Update-Database
После этого подключение должным образом настроено, база данных будет создана, и мы сможем с ней работать.






#initial #инициализация #seed #Initialize

//просто класс
public static class SampleData
    {
        public static void Initialize(MobileContext context)
        {
//db.entr.Add();
            context.entr.Add();
        }
    }



Program->Main

//CreateWebHostBuilder(args).Build().Run();
            var host = CreateWebHostBuilder(args).Build();
 
            using (var scope = host.Services.CreateScope())
            {
                var services = scope.ServiceProvider;
                try
                {
                    var context = services.GetRequiredService<MobileContext>();
                    SampleData.Initialize(context);
                }
                catch (Exception ex)
                {
                    var logger = services.GetRequiredService<ILogger<Program>>();
                    logger.LogError(ex, "An error occurred while seeding the database.");
                }
            }
 
            host.Run();

--
//public static IWebHost BuildWebHost(string[] args) =>
//            WebHost.CreateDefaultBuilder(args).UseStartup<Startup>().Build();
//вроде так лучше, определяется само
public static IWebHostBuilder CreateWebHostBuilder(string[] args) =>
            WebHost.CreateDefaultBuilder(args)
                .UseStartup<Startup>();





вроде бы другой способ #OnModelCreating
//при таком способе данные будут добавляться либо при миграции либо при  Database. #EnsureCreated()
public class ApplicationContext : DbContext
    {
        public ApplicationContext(DbContextOptions<ApplicationContext> options)
            : base(options)
        {
            Database.EnsureCreated();// это лучше не использовать тк может сломать миграции
        }
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
// добавляем роли
            Role adminRole = new Role { Id = 1, Name = adminRoleName };
            modelBuilder.Entity<Role>().HasData(new Role[] { adminRole});
            base.OnModelCreating(modelBuilder);
}









#like #Functions #linq
db.Phones.Where(p => EF.Functions.Like(p.Name, "%Galaxy%"))
%: соответствует любой подстроке, которая может иметь любое количество символов, при этом подстрока может и не содержать ни одного символа
_: соответствует любому одиночному символу
[ ]: соответствует одному символу, который указан в квадратных скобках
[ - ]: соответствует одному символу из определенного диапазона
[ ^ ]: соответствует одному символу, который неуказан после символа ^


#find
db.Phones.Find(3); // выберем элемент с id=3





#отслеживание #изменений #ChangeTracker #QueryTrackingBehavior #NoTracking #AsNoTracking #отслеживание #tracing #tracking 
Можно отключить отслеживание изменений 
db.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;

//изменения не будут сохранены
var phone = db.Phones.FirstOrDefault();
phone.Price = 66600;
db.SaveChanges();

 var phone = db.Phones.AsNoTracking().FirstOrDefault();


Узнать сколько элементов отслеживаются db.ChangeTracker.Entries().Count();


Если объекты отслеживаются то ссылки будут указывать на 1 объект 
var phone = db.Phones.FirstOrDefault();
var phone2 = db.Phones.FirstOrDefault();
phone.Price = 66000;
Если не отслеживается то они не будут связаны







#attr


#fluent #api
protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
//можно включить сущность в контекст(аналог public DbSet<Phone> Phones { get; set; })  вот так
 modelBuilder.Entity<Tablet>();//#entity
//можно исключить сущность из бд, еще исключить можно атрибутом #NotMapped
modelBuilder.Ignore<Company>();//#Ignore
//исключаем свойство
modelBuilder.Entity<Phone>().Ignore(b => b.CurrentRate);// еще исключить можно атрибутом #NotMapped
//изменяем название таблицы , также можно с помощью атрибута [#Table("Tabname")]
 modelBuilder.Entity<User>().ToTable("People");
//изменяем название столбца, также можно через атрибут [#Column("user_id")]
 modelBuilder.Entity<User>().Property(u=>u.Id).HasColumnName("user_id");
//явно указываем id, также можно через атрибут [#key]
modelBuilder.Entity<User>().HasKey(u => u.Ident);//можем к haskey добавить .HasName("UsersPrimaryKey")  и тогда сможем явно указать название ограничения
//явно указываем составной id(это единственный способ сделать составной id)
 modelBuilder.Entity<User>().HasKey(u => new { u.PassportSeria, u.PassportNumber});
//установка уникального ключа(не первичный), может быть составным
modelBuilder.Entity<User>().HasAlternateKey(u => u.Passport);
 modelBuilder.Entity<User>().HasAlternateKey(u => new { u.Passport, u.PhoneNumber });
//установка индекса
 modelBuilder.Entity<User>().HasIndex(u => u.Passport);//к hasindex можно добавить .IsUnique();
//индексы для нескольких свойств
modelBuilder.Entity<User>().HasIndex(u => new { u.Passport, u.PhoneNumber });
        
//отключаем автогенерацию значения при добавлении #id, если будем добавлять сущность у которой не установлен id то будет ошибка, можно установить атрибутом [#DatabaseGenerated(DatabaseGeneratedOption.None)], и есть противоположность [#DatabaseGenerated(DatabaseGeneratedOption.Identity)]
 modelBuilder.Entity<User>().Property(b => b.Id).ValueGeneratedNever();
//устанавливаем значение по умолчанию
modelBuilder.Entity<User>().Property(u => u.Age).HasDefaultValue(18);
//тоже значение по умолчанию но на базе sql #HasComputedColumnSql
modelBuilder.Entity<User>().Property(u => u.CreatedAt).HasComputedColumnSql("GETDATE()");
//можно установить sql команду
 modelBuilder.Entity<User>().Property(u => u.Name).HasComputedColumnSql("[FirstName] + ' ' + [LastName]");
//устанавливаем свойство как обязательное #IsRequired, можно через атрибут [#Required]
 modelBuilder.Entity<User>().Property(b => b.Name).IsRequired();
//ограничение по длине #HasMaxLength, атрибут #MaxLength
modelBuilder.Entity<User>().Property(b => b.Name).HasMaxLength(50);
//устанавливаем тип данных #HasColumnType, атрибут [#Column(TypeName = "varchar(200)")]
 modelBuilder.Entity<User>().Property(u=>u.Name).HasColumnType("varchar(200)");

#1 к 1 #many #многие #многим
в основном все как в обычном entity
#OnDelete
#Cascade: зависимая сущность удаляется вместе с главной
#SetNull: свойство-внешний ключ в зависимой сущности получает значение null
#Restrict: зависимая сущность никак не изменяется при удалении главной сущности

modelBuilder.Entity<Player>()
            .HasOne(p => p.Team)
            .WithMany(t => t.Players)
            .OnDelete(DeleteBehavior.Cascade);



//ограничиваем запросы к таблице(добавление #фильтра #filter) все запросы к таблице будут возвращать только записи которые будут удовлетворять этим условиям
//в результате запросов будут извлекаться только те объекты User, у которых значение свойства Age больше 17, а свойство RoleId равно значению свойства RoleId их контекста данных
//данный фильтр будет действовать для всех запросов к базе данных, которые извлекают данные из таблицы Users
modelBuilder.Entity<User>().HasQueryFilter(u => u.Age > 17 && u.RoleId == this.RoleId);
//Можно игнорировать фильтры 
db.Users.IgnoreQueryFilters().Min(x => x.Age);


        base.OnModelCreating(modelBuilder);
    }


настройки fluent api можно вынести в отдельный класс 
#IEntityTypeConfiguration<T> #ApplyConfiguration
protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplyConfiguration(new PhoneConfiguration());
        modelBuilder.ApplyConfiguration(new CompanyConfiguration());
    }

public class PhoneConfiguration : IEntityTypeConfiguration<Phone>
{
    public void Configure(EntityTypeBuilder<Phone> builder)
    {
        builder.ToTable("Mobiles").HasKey(p => p.Ident);
        builder.Property(p => p.Name).IsRequired().HasMaxLength(30);
    }
}





//при связи 1 к 1 данные можно хранить в 1 таблице

...(обычная настрока связи 1 к 1).....HasForeignKey<UserProfile>(e => e.Id);
        modelBuilder.Entity<User>().ToTable("Users");
        modelBuilder.Entity<UserProfile>().ToTable("Users");
в таком случае данные надо добавлять сразу цельной сущностью
User user1 = new User
    {
        Login = "login1",
        Password = "pass1234",
        Profile = new UserProfile { Age = 22, Name = "Tom"}
    };





//многие ко многим
на данный момент необходимо самому создавать связывающий класс


protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<StudentCourse>()
            .HasKey(t => new { t.StudentId, t.CourseId });
 
        modelBuilder.Entity<StudentCourse>()
            .HasOne(x => x.Student)
            .WithMany(x => x.StudentCourses)
            .HasForeignKey(x => x.StudentId);
 
        modelBuilder.Entity<StudentCourse>()
            .HasOne(x => x.Course)
            .WithMany(x => x.StudentCourses)
            .HasForeignKey(x => x.CourseId);
    }


public class Student
{
    public List<StudentCourse> StudentCourses { get; set; }}
public class Course
{
    public List<StudentCourse> StudentCourses { get; set; }}
public class StudentCourse
{
    public int StudentId { get; set; }
    public Student Student { get; set; }
 
    public int CourseId { get; set; }
    public Course Course { get; set; }
}



s1.StudentCourses.Add(new StudentCourse { CourseId = c1.Id, StudentId = s1.Id });





//несколько модерей в 1 таблице ....
1 способ см не в коре по--: Две модели в одной таблице #ToTable #Table
2 способ
#OwnsOne #Комплексные типы
если нужны сущности которые дополняют определенную сущность,
данные сущности не содержат id
public class User
{
    public int Id { get; set; }
    public string Login { get; set; }
    public string Password { get; set; }
    public UserProfile Profile { get; set; }
}  
public class UserProfile
{
    public Claim Name { get; set; }
    public Claim Age { get; set; }
}
public class Claim
{
    public string Key { get; set; }
    public string Value { get; set; }
}

protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<User>().OwnsOne(u => u.Profile, p =>
        {
            p.OwnsOne(c => c.Name);
            p.OwnsOne(c => c.Age);
        });
    }







По умолчанию при работе с цепочками наследования классов Entity Framework Core использует подход #TPH (Table Per Hierarchy / Таблица на одну иерархию классов).,
 если несколько сущностей и главная user, то при получении userов мы получим всех, но в контексте будет 3 списка




















#load #include

Team team = db.Teams
        .Include(t=>t.Players)//загружаем связанное свойство
	.Include(p => p.Team)//загружаем еще одно связанное свойство
            .ThenInclude(p=>p.Country)//загружаем связанное свойство в свойстве Players
//.Include(p => p.Team)//это свойство можно загрузить до ThenInclude и после  
        .FirstOrDefault();



#Explicit loading
все как в обычном entity+ можно еще так
db.Entry(company).Collection(t=>t.Users).Load();//Reference
Team team = db.Teams.FirstOrDefault();
    db.Players.Where(p=>p.TeamId==team.Id).Load();
//если надо загрузить вообще всех то
db.Players.Load()



#Lazy loading
Однако при использовании lazy loading следует учитывать ряд моментов. В частности, при загрузке объектов из бд, загружаются также все связанные с ними данные. Для определения загружены ли данные, EF Core использует специальный флаг, который устанавливается после загрузки. И после этого данные не перезагружаются, даже если базе данных произошли какие-нибудь изменения (например, другой пользоваль изменил данные).
данные загружаются синхронно

//добавить в проект Microsoft.EntityFrameworkCore.Proxies

 protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder
                .UseLazyLoadingProxies()//без этого не будет работать #UseLazyLoadingProxies
                .UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=relationsdb2;Trusted_Connection=True;");
        }

public int TeamId { get; set; }
        public virtual Team Team { get; set; }




#Reverse #Engineering если нужно сгенерить классы по #db #бд #class #poco
это создаст все классы бд+ контекст бд
Чтобы воспользоваться этой функцией перейдем в Visual Studio к окну Package Manager Console. Его открыть можно, перейдя в меню Tools –> NuGet Package Manager –> Package Manager Console
передается строка подключения с указанием сервера+ название бд: Scaffold-DbContext "Server=(localdb)\mssqllocaldb;Database=helloappdb;Trusted_Connection=True;" Microsoft.EntityFrameworkCore.SqlServer










#ef #bd #crud



await db.Phones.ToListAsync()
db.Phones.Add(phone);
    await db.SaveChangesAsync();


#удаление #delete #remove
удалить можно так//сгенерирует 1 запрос #EntityState #Deleted
Phone phone = new Phone { Id = id.Value };
        db.Entry(phone).State = EntityState.Deleted;
        await db.SaveChangesAsync();

или так//сгенерирует 2 запроса
Phone phone = await db.Phones.FirstOrDefaultAsync(p => p.Id == id);
db.Phones.Remove(phone);
            await db.SaveChangesAsync();


#каскадное удаление

свойство внешнего ключа должно иметь тип int - этого достаточно



если необходимо #обновить данные #update

 db.Users.Update(user);//user может быть даже не присоеденен к текущему контексту
db.Users.UpdateRange(user1, user2);









#sql #query #comand 
#FromSql - только для выборки
var comps = db.Companies.FromSql("SELECT * FROM Companies").ToList();
Тут все будет выполняться за 1 sql. Запрос var comps = db.Companies.FromSql("SELECT * FROM Companies").OrderBy(x=>x.Name).ToList();


//#param #SqlParameter 
SqlParameter param = new SqlParameter("@name", "%Galaxy%");
var phones = db.Phones.FromSql("SELECT * FROM Phones WHERE Name LIKE @name", param).ToList();
//
var name = "%Galaxy%";
var phones = db.Phones.FromSql("SELECT * FROM Phones WHERE Name LIKE {0}", name).ToList();

для crud надо применять метод #ExecuteSqlCommand(),который возвращает количество затронутых командой строк. надо применять к свойству #Database 
string htc = "htc";
int numberOfRowInserted = db.Database.ExecuteSqlCommand("INSERT INTO Companies (Name) VALUES ({0})", htc);



Если в строку запроса параметры будет передавать через интерполяцию $, то. В бд будет генериться так
@p0='%Galaxy%'
@p1=30000
SELECT *
FROM Phones
WHERE Name LIKE @p0 AND Price > @p1




#injection #иньекции
для предотвращения иньекция надо параметризировать запрос
FromSql("EXECUTE dbo.GetMostPopularBlogsForUser {0}", user)
FromSql($"EXECUTE dbo.GetMostPopularBlogsForUser {user}")
FromSql("EXECUTE dbo.GetMostPopularBlogsForUser @user", user)
FromSql("EXECUTE dbo.GetMostPopularBlogs @filterByUser=@user", user)


#parallel
Параллелизм выбросит исключение если данные кто то уже поменял 

Перед добавлением сравнивает Id,name и если они одинаковые то все хорошо
[#ConcurrencyCheck]
public string Name { get; set; 

через fluent 
protected override void OnModelCreating(ModelBuilder modelBuilder)
{modelBuilder.Entity<User>().Property(b => b.Name).IsConcurrencyToken();}



Другой способ 
[#Timestamp]//свойство именно такогго типа
public byte[] RowVersion { get; set; }
 


catch(#DbUpdateConcurrencyException ex){
foreach (var entry in ex.Entries)
            {
                if (entry.Entity is Person)//сущность из за которой исключение
                {
                    var proposedValues = entry.CurrentValues;
                    var databaseValues = entry.GetDatabaseValues();

                    foreach (var property in proposedValues.Properties)
                    {
                        var proposedValue = proposedValues[property];
                        var databaseValue = databaseValues[property];

                        // TODO: decide which value should be written to database
                        // proposedValues[property] = <value to be saved>;
                    }

                    // Refresh original values to bypass next concurrency check
                    entry.OriginalValues.SetValues(databaseValues);
                }
                else
                {
                    throw new NotSupportedException(
                        "Don't know how to handle concurrency conflicts for "
                        + entry.Metadata.Name);
                }
            }
}







#UseAuthentication #Authentication
#AddAuthentication #Authentication #user #авторизация #CookieAuthenticationDefaults #AuthenticationScheme #AddCookie #CookieAuthenticationOptions #LoginPath 
#Identity  #IIdentity 



public void ConfigureServices(IServiceCollection services)
        {
//подключение бд и потом вот это
services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
                .AddCookie(options => //CookieAuthenticationOptions
                {
//свойство CookieAuthenticationOptions - LoginPath устанавливает относительный путь, по которому будет перенаправляться анонимный пользователь при доступе к ресурсам, для которых нужна аутентификация.
                    options.LoginPath = new Microsoft.AspNetCore.Http.PathString("/Account/Login");

 options.AccessDeniedPath = new Microsoft.AspNetCore.Http.PathString("/Account/Login");

                });
 
            services.AddMvc();



public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {

app.UseAuthentication();




если реализовывать самому то обычные контроллеры + вьюхи

в методе логина
if (user != null)
    await Authenticate(model.Email); // аутентификация


//#Claim #ClaimsIdentity #SignInAsync #CookieAuthenticationDefaults #AuthenticationScheme #ClaimsPrincipal #ClaimsIdentity                   
private async Task Authenticate(string userName)
        {
            // создаем один claim
//набор данных, которые шифруются и добавляются в аутентификационные куки            
var claims = new List<Claim>
            {
                new Claim(ClaimsIdentity.DefaultNameClaimType, userName),
		new Claim(ClaimsIdentity.DefaultRoleClaimType, user.Role?.Name)
            };
            // создаем объект ClaimsIdentity

//В ClaimsIdentity передается:
//Ранее созданный список claims
//Тип аутентификации, в данном случае "ApplicationCookie"
//Тип данных в списке claims, который преставляет логин пользователя. То есть при добавлении claimа мы использовали в качестве типа ClaimsIdentity.DefaultNameClaimType, поэтому и тут нам надо указать то же самое значение. Мы, конечно, можем указать и разные значения, но тогда система не сможет связать различные claim с логином пользователя.
//Тип данных в списке claims, который представляет роль пользователя. Хотя у нас такого claim нет, который бы представлял роль пользователя, но но опционально мы можем указать константу ClaimsIdentity.DefaultRoleClaimType. В данном случае она ни на что не влияет.


            ClaimsIdentity id = new ClaimsIdentity(claims, "ApplicationCookie", ClaimsIdentity.DefaultNameClaimType, ClaimsIdentity.DefaultRoleClaimType);
            // установка аутентификационных куки
//В качестве параметра он принимает схему аутентификации, которая была использована при установки middleware app.UseCookieAuthentication в классе Startup 
           await HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, new ClaimsPrincipal(id));
        }
 
        public async Task<IActionResult> Logout()
        {
//передается название схемы аутентификации, использованное в классе Startup
            await HttpContext.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);
            return RedirectToAction("Login", "Account");
        }


#Authorize #AuthorizeAttribute  #авторизация #login #логин
применение через  [Authorize] [Authorize(Roles = "admin, user")]

если такой атрибут применен к контроллеру и к методу контроллера применить вот такой - #AllowAnonymous то к этому методу сможет получить доступ анон

//#TODO получить #роль пользователя #role
string role = User.FindFirst(x => x.Type == ClaimsIdentity.DefaultRoleClaimType).Value;
можно получить через usermanager



 
можно получить #логин пользователя текущего #login 
HttpContext.User.Idenity.Name
//в контроллере
var claimsIdentity = this.User.Identity as ClaimsIdentity; 
var #userId = claimsIdentity.FindFirst(ClaimTypes.Name)?.Value;//ClaimTypes.Name - перечисление, мы получаем то что ранее записали в клаймы под флагом этого перечисления

// в методе контроллера
User.Identity.IsAuthenticated

Свойство HttpContext.User представляет объект интерфейса IPrincipal, который определен в пространстве имен System.Security.Principal. Этот интерфейс определяет метод IsInRole() и свойство Identity. ????? фактически представляет объект #ClaimsPrincipal
Свойство #Identity возвращает объект интерфейса #IIdentity, который связан с текущим запросом.
Метод #IsInRole() в качестве параметра принимает роль и возвращает true, если текущий пользователь принадлежит данной роли.
#Объект IIdentity, в свою очередь, предоставляет информацию о текущем пользователе через следующие свойства:
#AuthenticationType: тип аутентификации в строковом виде
#IsAuthenticated: возвращает true, если пользователь аутентифицирован
#Name: возвращает имя пользователя. Как правило, в качестве подобного имени используется логин, по которому пользователь входит в приложение









#claim 
более глубокая аторизация(может учитывать не только логин и пароль но и еще поля)
Каждый объект claim представляет класс Claim, который определяет следующие свойства:


Issuer: "издатель" или название системы, которая выдала данный claim
Subject: возвращает информацию о пользователе в виде объекта ClaimsIdentity
Type: возвращает тип объекта claim
Value: возвращает значение объекта claim



Для работы с объектами Claim в классе ClaimsPrincipal есть следующие свойства и методы:

#Identity: возвращает объект ClaimsIdentity, который реализует интерфейс IIdentity и представляет текущего пользователя
#FindAll(type) / FindAll(predicate): возвращает все объекты claim, которые соответствуют определенному типу или условию
#FindFirst(type) / FindFirst(predicate): возвращает первый объект claim, который соответствуют определенному типу или условию
#HasClaim(type, value) / HasClaim(predicate): возвращает значение true, если пользователь имеет claim определенного типа с определенным значением
#IsInRole(name): возвращает значение true, если пользователь принадлежит роли с названием name
С помощью объекта #ClaimsIdentity, который возвращается свойством User.Identity, мы можем управлять объектами claim у текущего пользователя. В частности, класс ClaimsIdentity определяет следующие свойства и методы:
#Claims: свойство, которое возвращает набор ассоциированных с пользователем объектов claim
#AddClaim(claim): добавляет для пользователя объект claim
#AddClaims(claims): добавляет набор объектов claim
#FindAll(predicate): возвращает все объекты claim, которые соответствуют определенному условию
#HasClaim(predicate): возвращает значение true, если пользователь имеет claim, соответствующий определенному условию
#RemoveClaim(claim): удаляет объект claim


создание можно посмотреть выше по --claim 
Для создания объекта ClaimsIdentity в его конструктор передается набор claim, тип аутентификации (ApplicationCookie), тип для claima, представляющего логин, и тип для claima, представляющего роль.
Созданный объект ClaimsIdentity передается в конструктор ClaimsPrincipal. И фактически этот объект ClaimsPrincipal и будет представлять то, что мы потом в любом контроллере сможем получить через HttpContext.User.



------------------------------конец клаймов----------------





#Identity 
для добавления функционала нажмем на название проекта правой кнопкой мыши и в контекстном меню выберем пункт 
Add -> New Scaffolded Item-> identity
добавить->создать шаблонный элемент->удостоверение

public void ConfigureServices(IServiceCollection services){
 // добавление ApplicationDbContext для взаимодействия с базой данных учетных записей
    services.AddDbContext<ApplicationDbContext>(options =>
        options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
 
    // добавление сервисов Idenity
    services.AddDefaultIdentity<IdentityRole>()
        .AddEntityFrameworkStores<ApplicationDbContext>();
 

public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseAuthentication();
     




//для того что бы можно было работать с бд
Для этого откроем окно Package Manager Console и введем в командную строку следующую команду: "Update-Database




#IdentityDbContext #ApplicationDbContext #db #ef #context


public class ApplicationDbContext : IdentityDbContext<ApplicationUser>
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
            : base(options)
    {
Database.EnsureCreated();//, это лучше не использовать тк может сломать миграции
    }
 
    protected override void OnModelCreating(ModelBuilder builder)
    {
            base.OnModelCreating(builder);
    }
}


По умолчанию данный класс наследует весь функционал от IdentityDbContext. Так, мы можем получить содержимое таблиц из бд с помощью следующих свойств:
#Users: набор объектов IdentityUser, соответствует таблице пользователей
#Roles: набор объектов IdentityRole, соответствует таблице ролей
#RoleClaims: набор объектов IdentityRoleClaim, соответствует таблице связи ролей и объектов claims
#UserLogins: набор объектов IdentityUserLogin, соответствует таблице связи пользователей с их логинами их внешних сервисов
#UserClaims: набор объектов IdentityUserClaim, соответствует таблице связи пользователей и объектов claims
#UserRoles: набор объектов IdentityUserRole, соответствует таблице, которая сопоставляет пользователей и их роли
#UserTokens: набор объектов IdentityUserToken, соответствует таблице токенов пользователей




#IdentityUser  #ApplicationUser #user
public class ApplicationUser : IdentityUser{}
public class ApplicationDbContext : IdentityDbContext<ApplicationUser>
надо заменить все схождения "IdentityUser" в проекте на "ApplicationUser"



#id #check_id #userId  #userName #Email
в контроллере
var userId =  User.FindFirst(ClaimTypes.NameIdentifier)?.Value // will give the user userId
        var userName =  User.FindFirst(ClaimTypes.Name)?.Value // will give the user userName
        var userEmail =  User.FindFirst(ClaimTypes.Email)?.Value // will give the user Email

не в контроллере
получаем через DI
public OtherClassConstr(IHttpContextAccessor httpContextAccessor)

var userId = _httpContextAccessor.HttpContext.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
      // or
      var userId = _httpContextAccessor.HttpContext.User.FindFirstValue(ClaimTypes.NameIdentifier);
   
и регистрируем
 services.TryAddSingleton<IHttpContextAccessor, HttpContextAccessor>();
    // Or you can also register as follows
    services.AddHttpContextAccessor();

//#TODO usermanager.





класс для взаимодействия с пользователями #UserManager   получается через обычное DI
public AdminController(UserManager<ApplicationUser> manager)
        {

содержит методы
#ChangePasswordAsync(user, old, new): изменяет пароль пользователя
#CreateAsync(user): создает нового пользователя
#DeleteAsync(user): удаляет пользователя
#FindByIdAsync(id): ищет пользователя по id
#FindByEmailAsync(email): ищет пользователя по email
#FindByNameAsync(name): ищет пользователя по нику
#UpdateAsync(user): обновляет пользователя
#Users: возвращает всех пользователей
#AddToRoleAsync(user, role): добавляет для пользователя user роль role
#GetRolesAsync (user): возвращает список ролей, к которым принадлежит пользователь user #roles
#IsInRoleAsync(user, name): возвращает true, если пользователь user принадлежит роли name
#RemoveFromRoleAsync(user, name): удаляет роль name у пользователя user
#GetUserAsync(HttpContext.User)
var passwordOK = await _userManager.#CheckPasswordAsync(user, model.Password);//проверяет соответствует ли пароль



#SignInManager #TODO
public AccountController(UserManager<User> userManager, SignInManager<User> signInManager)

SignInManager.#PasswordSignInAsync
проверяет разрешен ли вход(например из за не подтвержденной почты)
вызывает UserManager.#CheckPasswordAsync для проверки пароля
Если для пользователя включена двухфакторная аутентификация, метод устанавливает соответствующий файл cookie и возвращает результат SignInResult.TwoFactorRequired
выполняет процесс входа, который завершает создание ClaimsPrincipalи сохранение его с помощью cookie






#IdentityRole #role #роль #роли 

[Authorize(Roles="admin")]
public class HomeController : Controller



При установке контекста в методе ConfigureServices() также устанавливается и класс роли:
//до mvc
services.AddIdentity<ApplicationUser, IdentityRole>()
    .AddEntityFrameworkStores<ApplicationDbContext>()
    .AddDefaultTokenProviders();


#RoleManager<T> где параметр T представляет класс, описывающий роль
можно получить также через DI
методы:
#CreateAsync(role): создает новую роль
#DeleteAsync(role): удаляет роль
#FindByIdAsync(id): возвращает роль по id
#FindByNameAsync(name): возвращает роль по названию
#RoleExistsAsync(name): возвращает true, если роль с данным именем существует
#UpdateAsync(role): обновляет роль
свойство
#Roles: возвращает все роли

IdentityResult result = await _roleManager.CreateAsync(new IdentityRole(name));







добавление #identity в пустой проект


определить 
public class User : IdentityUser{}

определить по примеру выше
public class ApplicationContext : IdentityDbContext<User>



ConfigureServices
//подключить бд

//#AddIdentity #AddEntityFrameworkStores
//указываем тип пользователя и тип роли, которые будут использоваться системой Identity. В качестве типа пользователя выступает созданный нами выше класс User, а в качестве типа роли взят стандартный класс IdentityRole
//Метод AddEntityFrameworkStores() устанавливает тип хранилища, которое будет применяться в Identity для хранения данных. В качестве типа хранилища здесь указывается класс контекста данных
services.AddIdentity<User, IdentityRole>()
                .AddEntityFrameworkStores<ApplicationContext>();
//подключить mvc если надо

Configure
//этот middleware должен вызываться перед UseMvc()
app.UseAuthentication();






создание пользователя #register #login

public AccountController(UserManager<User> userManager, SignInManager<User> signInManager)
        {}

[HttpPost]
        public async Task<IActionResult> Register(RegisterViewModel model)
        {
            if(ModelState.IsValid)
            {
                User user = new User { Email = model.Email, UserName = model.Email, Year=model.Year};
                // добавляем пользователя
                var result = await _userManager.CreateAsync(user, model.Password);
                if (result.Succeeded)
                {
                    // установка куки
                    await _signInManager.SignInAsync(user, false);
                    return RedirectToAction("Index", "Home");
                }
                else
                {
                    foreach (var error in result.Errors)
                    {
                        ModelState.AddModelError(string.Empty, error.Description);
                    }
                }
            }
            return View(model);
        }




[HttpGet]
public IActionResult Login(string returnUrl = null)
{
    return View(new LoginViewModel { ReturnUrl = returnUrl });
}
 
[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> Login(LoginViewModel model)
{
    if (ModelState.IsValid)
    {
        var result = 
            await _signInManager.PasswordSignInAsync(model.Email, model.Password, model.RememberMe, false);
        if (result.Succeeded)
        {
            // проверяем, принадлежит ли URL приложению
            if (!string.IsNullOrEmpty(model.ReturnUrl) && Url.IsLocalUrl(model.ReturnUrl))
            {
                return Redirect(model.ReturnUrl);
            }
            else
            {
                return RedirectToAction("Index", "Home");
            }
        }
        else
        {
            ModelState.AddModelError("", "Неправильный логин и (или) пароль");
        }
    }
    return View(model);
}
 
[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> LogOff()
{
    // удаляем аутентификационные куки
    await _signInManager.SignOutAsync();
    return RedirectToAction("Index", "Home");
}



//#FindByIdAsync поиск пользователя по id, если не найдет то вернет null
User user = await _userManager.FindByIdAsync(model.Id);



//изменение пароля пользователя
#IPasswordValidator #IPasswordHasher #UpdateAsync #HashPassword #ValidateAsync #password #ChangePassword
var _passwordValidator = HttpContext.RequestServices.GetService(typeof(IPasswordValidator<User>)) as IPasswordValidator<User>;
            var _passwordHasher = HttpContext.RequestServices.GetService(typeof(IPasswordHasher<User>)) as IPasswordHasher<User>;
     //user- запись которая вернула бд
            IdentityResult result = await _passwordValidator.ValidateAsync(_userManager, user, model.NewPassword);
            if(result.Succeeded)
            {
                user.PasswordHash = _passwordHasher.HashPassword(user, model.NewPassword);
                await _userManager.UpdateAsync(user);


можно изменить вот так
IdentityResult result = 
                await _userManager.ChangePasswordAsync(user, model.OldPassword, model.NewPassword);
            if(result.Succeeded)



#hash #Salt #KeyDerivation #Pbkdf2 #KeyDerivationPrf #HMACSHA1
 public static string GetHashRefreshToken(string token)
        {
            
            // generate a 128-bit salt using a secure PRNG
            //byte[] salt = new byte[128 / 8];
            //using (var rng = RandomNumberGenerator.Create())
            //{
            //    rng.GetBytes(salt);
            //}
            //Console.WriteLine($"Salt: {Convert.ToBase64String(salt)}");

            // derive a 256-bit subkey (use HMACSHA1 with 10,000 iterations)
            string hashed = Convert.ToBase64String(KeyDerivation.Pbkdf2(
                password: token,
                salt: new byte[0],
                prf: KeyDerivationPrf.HMACSHA1,
                iterationCount: 10000,
                numBytesRequested: 256 / 8));
            //Console.WriteLine($"Hashed: {hashed}");
            return hashed;
        }







валидация пароля Microsoft.AspNetCore.Identity.#PasswordOptions
можно переопределить стандартную логику валидации

что то такое
services.AddIdentity<ApplicationUser, IdentityRole>()
    .AddEntityFrameworkStores<ApplicationDbContext>()
    .AddDefaultTokenProviders();

меняем на что то такое

services.AddIdentity<ApplicationUser, IdentityRole>(opts=> {
        opts.Password.RequiredLength = 5;   // минимальная длина
        opts.Password.RequireNonAlphanumeric = false;   // требуются ли не алфавитно-цифровые символы
        opts.Password.RequireLowercase = false; // требуются ли символы в нижнем регистре
        opts.Password.RequireUppercase = false; // требуются ли символы в верхнем регистре
        opts.Password.RequireDigit = false; // требуются ли цифры
    })
    .AddEntityFrameworkStores<ApplicationDbContext>()
    .AddDefaultTokenProviders();


Класс PasswordOptions предоставляет следующие свойства:
#RequiredLength: минимальная длина пароля
#RequireNonLetterOrDigit: если равно true, то пароль должен будет иметь как минимум один символ, который не является алфавитно-цифровым
#RequireDigit: если равно true, то пароль должен будет иметь как минимум одну цифру
#RequireLowercase: если равно true, то пароль должен будет иметь как минимум один символ в нижнем регистре
#RequireUppercase: если равно true, то пароль должен будет иметь как минимум один символ в верхнем регистре


если нужна более сложная валидация то нужно реализоваться интерфейс #IPasswordValidator
public interface IPasswordValidator<T> where T : class {
 
    Task<IdentityResult> ValidateAsync(UserManager<T> manager, T user, string password);
}


для использования такого класса нужно 
public void ConfigureServices(IServiceCollection services)
{
    services.AddTransient<IPasswordValidator<ApplicationUser>, 
                    CustomPasswordValidator>(serv=>new CustomPasswordValidator(6));


public class CustomPasswordValidator : IPasswordValidator<ApplicationUser>
    {
        public int RequiredLength { get; set; } // минимальная длина
 
        public CustomPasswordValidator(int length)
        {
            RequiredLength = length;
        }
 
        public Task<IdentityResult> ValidateAsync
            (UserManager<ApplicationUser> manager, ApplicationUser user, string password)
        {
            List<IdentityError> errors = new List<IdentityError>();
 
            if (String.IsNullOrEmpty(password) || password.Length < RequiredLength)
            {
                errors.Add(new IdentityError
                {
                    Description = String.Format("Минимальная длина пароля равна {0}", RequiredLength)
                });
            }
            string pattern = "^[0-9]+$";
 
            if (!Regex.IsMatch(password, pattern))
            {
                errors.Add(new IdentityError
                {
                    Description = "Пароль должен состоять только из цифр"
                });
            }
            return Task.FromResult(errors.Count == 0 ?
                IdentityResult.Success : IdentityResult.Failed(errors.ToArray()));
        }
    }








#валидация пользователя-почта и тд #validation #email #password #login


#UserOptions
такой способ не позволит переопределить сообщения ошибок и тд
свойства
AllowedUserNameCharacters: если равно true, то юзернейм должен содержать только алфавитно-цифровые символы
RequireUniqueEmail: если равно true, то email пользователя должен быть уникальным


public void ConfigureServices(IServiceCollection services)
{ 
    services.AddIdentity<ApplicationUser, IdentityRole>(opts => {
            opts.User.RequireUniqueEmail = true;    // уникальный email
            opts.User.AllowedUserNameCharacters = "abcdefghijklmnopqrstuvwxyz"; // допустимые символы
        })
        .AddEntityFrameworkStores<ApplicationDbContext>()
        .AddDefaultTokenProviders();
}





можно изменить через создание своего класса валидации #IUserValidator или переопределить-унаследовать класс #UserValidator


public void ConfigureServices(IServiceCollection services)
{
    services.AddTransient<IUserValidator<ApplicationUser>, CustomUserValidator>();
 
    services.AddIdentity<ApplicationUser, IdentityRole>()
        .AddEntityFrameworkStores<ApplicationDbContext>()
        .AddDefaultTokenProviders();
 
    services.AddMvc();
}



public interface IUserValidator<TUser> where TUser : class {
//Метод ValidateAsync() вызывается при валидации адреса электронной почты. В качестве параметров в метод передаются объект UserManager и валидируемый пользователь.
    Task<IdentityResult> ValidateAsync(UserManager<TUser> manager, TUser user);
}


 public class CustomUserValidator : IUserValidator<ApplicationUser>
    {
        public Task<IdentityResult> ValidateAsync(UserManager<ApplicationUser> manager, ApplicationUser user)
        {
            List<IdentityError> errors = new List<IdentityError>();
 
            if (user.Email.ToLower().EndsWith("@spam.com"))
            {
                errors.Add(new IdentityError
                {
                    Description = "Данный домен находится в спам-базе. Выберите другой почтовый сервис"
                });
            }
            return Task.FromResult(errors.Count == 0 ?
                IdentityResult.Success : IdentityResult.Failed(errors.ToArray()));
        }
    }



















#mail #почта #SmtpClient
Для отправки email будем использовать #MailKit. Для его установки добавим через NuGet


добавление классов пользователя контекста и тд тд , общая настройка всего


#AddDefaultTokenProviders #AddEntityFrameworkStores
ConfigureServices->

services.AddIdentity<User, IdentityRole>() 
                .AddEntityFrameworkStores<ApplicationContext>()
                .AddDefaultTokenProviders();//добавляется функциональность генерации токенов, которые отсылаются в письме для подтверждения. В принципе мы можем и не использовать этот метод - AddDefaultTokenProviders(), однако тогда нам придется самостоятельно реализовать интерфейс #IUserTwoFactorTokenProvider, методы которого собственно и отвечают за генерацию и валидацию токена подтверждения электронной почты.


Configure->
app.UseAuthentication();






public class EmailService
    {
        public async Task SendEmailAsync(string email, string subject, string message)
        {
            var emailMessage = new MimeMessage();
 
            emailMessage.From.Add(new MailboxAddress("Администрация сайта", "login@yandex.ru"));
            emailMessage.To.Add(new MailboxAddress("", email));
            emailMessage.Subject = subject;
            emailMessage.Body = new TextPart(MimeKit.Text.TextFormat.Html)
            {
                Text = message
            };
             
            using (var client = new SmtpClient())
            {
                await client.ConnectAsync("smtp.yandex.ru", 25, false);
                await client.AuthenticateAsync("login@yandex.ru", "password");
                await client.SendAsync(emailMessage);
 
                await client.DisconnectAsync(true);
            }
        }
    }




//подтверждение при регистрации
//заносим в бд
if (result.Succeeded)
                {
                    // генерация токена для пользователя
                    var code = await _userManager.GenerateEmailConfirmationTokenAsync(user);
                    var callbackUrl = Url.Action(
                        "ConfirmEmail",
                        "Account",
                        new { userId = user.Id, code = code },
                        protocol: HttpContext.Request.Scheme);
                    EmailService emailService = new EmailService();
                    await emailService.SendEmailAsync(model.Email, "Confirm your account",
                        $"Подтвердите регистрацию, перейдя по ссылке: <a href='{callbackUrl}'>link</a>");
 
                    return Content("Для завершения регистрации проверьте электронную почту и перейдите по ссылке, указанной в письме");
                }


//пытаемся подтвердить почту
[HttpGet]
        [AllowAnonymous]
        public async Task<IActionResult> ConfirmEmail(string userId, string code)
        {
            if (userId == null || code == null)
            {
                return View("Error");
            }
            var user = await _userManager.FindByIdAsync(userId);
            if (user == null)
            {
                return View("Error");
            }
            var result = await _userManager.ConfirmEmailAsync(user, code);
            if(result.Succeeded)
                return RedirectToAction("Index", "Home");
            else
                return View("Error");
        }



//при логине

if (!await _userManager.IsEmailConfirmedAsync(user))
                    {
                        ModelState.AddModelError(string.Empty, "Вы не подтвердили свой email");
                        return View(model);
                    }



[HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> LogOff()
        {
            // удаляем аутентификационные куки
            await _signInManager.SignOutAsync();
            return RedirectToAction("Index", "Home");
        }








#reset #password #сброс #пароль


#GeneratePasswordResetTokenAsync
var code = await _userManager.GeneratePasswordResetTokenAsync(user);
var callbackUrl = Url.Action("ResetPassword", "Account", new { userId = user.Id, code = code }, protocol: HttpContext.Request.Scheme);
        EmailService emailService = new EmailService();
        await emailService.SendEmailAsync(model.Email, "Reset Password",
            $"Для сброса пароля пройдите по ссылке: <a href='{callbackUrl}'>link</a>");
        return View("ForgotPasswordConfirmation");




var result = await _userManager.ResetPasswordAsync(user, model.Code, model.Password);
if (result.Succeeded)




































#пути #sign #path
#css #rel #href
из папки wwwroot/lib/bootstrap/dist/css/
<link rel="stylesheet" href="~/lib/bootstrap/dist/css/bootstrap.css" />
#a <a href="~/Home/Index" class="navbar-brand">Главная</a>






#_Layout #Layout
#_ViewStart #ViewStart
_ViewStart.cshtml - установка мастер страницы по умолчанию/ устанавливает общую мастер-страницу

_Layout.cshtml - мастер страница по умолчанию
если мастер страницу не нужно использовать в представлении то вверху страницы
@{
    Layout = null;
}
//явно указваем
@{
    Layout = "~/Views/_Layout.cshtml";
}


для создания файла мастер страницы надо создать файл с типом "MVC View Layout Page"

#RenderBody
рендерит тело представления

#IgnoreBody проигнорировать тело, это нужно использовать ВМЕСТО renderBody и обязательно с скобками
@{IgnoreBody();}



#RenderSection #Section

<footer>@RenderSection("Footer")</footer>
//если не определено то не отрисует
<footer>@RenderSection("Footer", false)</footer> 


в представление которой будет использовать мастер страницу добавить секцию 

@section Footer {
    Все права защищены. Site Corp. 2016.
}

#IsSectionDefined
@if (IsSectionDefined("Footer"))
    {
        @RenderSection("Footer")
    }
    else
    {
        <span>Содержание элемента footer по умолчанию.</span>
    }








#_ValidationScripsPartial #ValidationScripsPartial
частичное представление, которое подключает скрипты валидации формы

#Error
использутся для отображения ошибок



#_ViewImports #ViewImports
тип файла "MVC View Imports Page"
устанавливает некоторые общие для всех представлений пространства имен

если добавить такую строку, то юзинг будет применен для всех представлений
@using MvcViewsApp.Models


если необходимо добавить using только для определенных представлений то
создать папку в папке Views например Other , добавить туда _ViewImports.cshtml
теперь все директивы и выражения из файла Views/Other/_ViewImports.cshtml будут применяться к представлениям только из папки Views/Other. Кроме того, ко всем представлениям во всех папках продолжит применяться глобальный файл Views/_ViewImports.cshtml








#ActionResult #IActionResult #result



создание
добавим в проект папку Util

public class HtmlResult : IActionResult
    {
        string htmlCode;
        public HtmlResult(string html)
        {
            htmlCode = html;
        }
        public async Task ExecuteResultAsync(ActionContext context)
        {
            string fullHtmlCode = "<!DOCTYPE html><html><head>";
            fullHtmlCode += "<title>Главная страница</title>";
            fullHtmlCode += "<meta charset=utf-8 />";
            fullHtmlCode += "</head> <body>";
            fullHtmlCode += htmlCode;
            fullHtmlCode += "</body></html>";
            await context.HttpContext.Response.WriteAsync(fullHtmlCode);
        }
    }





public HtmlResult GetHtml()
    {
        return new HtmlResult("<h2>Привет ASP.NET Core</h2>");
    }





#ContentResult: пишет указанный контент напрямую в ответ в виде строки
return Content($"Площадь треугольника с основанием {altitude} и высотой {height} равна {square}");

#EmptyResult: отправляет пустой ответ в виде статусного кода 200
public IActionResult GetVoid()
{
    return new EmptyResult();
}
Аналогичен следующему методу:
public void GetVoid()
{
}
#NoContentResult: во многом похож на EmptyResult, также отправляет пустой ответ, только в виде статусного кода 204
public IActionResult GetVoid()
{
    return new NoContentResult();
}
#FileResult: является базовым классом для всех объектов, которые пишут набор байтов в выходной поток. Предназначен для отправки файлов
#FileContentResult: класс, производный от FileResult, пишет в ответ массив байтов
#VirtualFileResult: также производный от FileResult класс, пишет в ответ файл, находящийся по заданному пути
#PhysicalFileResult: также производный от FileResult класс, пишет в ответ файл, находящийся по заданному пути. Только в отличие от предыдущего класса использует физический путь, а не виртуальный.
#FileStreamResult: класс, производный от FileResult, пишет бинарный поток в выходной ответ
#StatusCodeResult: результат действия, который возвращает клиенту определенный статусный код HTTP
#UnauthorizedResult: класс, производный от StatusCodeResult. Возвращает клиенту ответ в виде статусного кода HTTP 401, указывая, что пользователь не прошел авторизацию и не имеет прав доступа к запрошенному ресурсу.
#NotFoundResult: производный от StatusCodeResult. Возвращает клиенту ответ в виде статусного кода HTTP 404, указывая, что запрошенный ресурс не найден
#NotFoundObjectResult: производный от ObjectResult. Также возвращает клиенту ответ в виде статусного кода HTTP 404 с дополнительной информацией
#BadRequestResult: производный от StatusCodeResult. Возвращает статусный код 400, тем самым указывая, что запрос некорректен
#BadRequestObjectResult: производный от ObjectResult. Возвращает статусный код 400 с некоторой дополнительной информацией
#OkResult: производный от StatusCodeResult. Возвращает статусный код 200, который уведомляет об успешном выполнении запроса
#OkObjectResult: производный от ObjectResult. Возвращает статусный код 200 с некоторой дополнительной информацией
#CreatedResult: возвращает статусный код 201, который уведомляет о создании нового ресурса. В качестве параметра принимает адрес нового ресурса
#CreatedAtActionResult: возвращает статусный код 201, который уведомляет о создании нового ресурса. В качестве параметра принимает название метода и контроллера, а также параметров запроса, которые вместе создают адрес нового ресурса
#CreatedAtRouteResult: возвращает статусный код 201, который уведомляет о создании нового ресурса. В качестве параметра принимает название маршрута, который используется для создания адреса нового ресурса
#ChallengeResult: используется для проверки аутентификации пользователя
#JsonResult: возвращает в качестве ответа объект или набор объектов в формате JSON

#return #Json(user);
//
Response.ContentType = "application/json";
await Response.WriteAsync(JsonConvert.SerializeObject(response, new JsonSerializerSettings { Formatting = Formatting.Indented }));

JsonConvert.SerializeObject(YourObject, Formatting.Indented,
    new JsonSerializerSettings() {
        ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore
    }
);



#PartialViewResult: производит рендеринг частичного представления в выходной поток
#RedirectResult: перенаправляет пользователя по другому адресу URL, возвращая статусный код 302 для временной переадресации или код 301 для постоянной переадресации зависимости от того, установлен ли флаг Permanent.
#RedirectToRouteResult: класс работает подобно RedirectResult, но перенаправляет пользователя по определенному адресу URL, указанному через параметры маршрута
#RedirectToActionResult: выполняет переадресацию на определенный метод контроллера
#LocalRedirectResult: перенаправляет пользователя по определенному адресу URL в рамках веб-приложения
#ViewComponentResult: возвращает в ответ сущность ViewComponent
#ViewResult: производит рендеринг представления и отправляет результаты рендеринга в виде html-страницы клиенту



#ObjectResult
он реализует такую функциональность, как Content negotiation.
Content negotiation предполагает процесс согласования между сервером и клиентом по поводу типа контента, который отправляется клиенту
А для объектов классов отправляемые данные в ObjectResult по умолчанию форматируются в формат JSON, а для заголовка Content-Type устанавливается значение application/json.
если мы пишем так return db.Users.ToList(); то это транслируется в return new ObjectResult(db.Users.ToList());
выражение return Ok(user); возвращает объект OkObjectResult





#RedirectResult, #LocalRedirectResult, #RedirectToActionResult 

//временная
return Redirect("~/Home/About");
return Redirect("http://microsoft.com")

#RedirectPermanent
//постоянная

Для обращения к локальным адресам в нашей системе мы можем использовать класс #LocalRedirectResult. Для создания временной переадресации применяется метод #LocalRedirect(), а для создания постоянной переадресации - метод #LocalRedirectPermanent
return LocalRedirect("http://microsoft.com");// исключение




#RedirectToRouteResult. Для переадресации он использует маршруты. Для создания объекта этого класса имеются два метода: #RedirectToRoute и #RedirectToRoutePermanent (соответственно для временной и постоянной переадресации).

return RedirectToRoute("default", new { controller = "Home", action = "Square", height = 2, altitude = 20});
при routes.MapRoute(
        name: "default",






отправка #статуса #кода #StatusCode  #status
#404 #200 #500
#StatusCodeResult

 return StatusCode(401);
 Response.StatusCode = 404;

#HttpNotFoundResult #HttpNotFoundObjectResult #NotFound
посылает код 404, уведомляя браузер о том, что ресурс не найден. Второй класс в дополнении к статусному коду позволяет отправить доплнительную информацию, которая потом отобразится в браузере.
return NotFound("Ресурс в приложении не найден");



#UnauthorizedResult
//вернет 401-не авторизован
return Unauthorized();


#BadResult и #BadObjectResult
//400 - запросс не корректный
return BadRequest("Не указаны параметры запроса");


#OkResult и #OkObjectResult
// 200, уведомляя об успешном выполнении запроса
return Ok("Запрос успешно выполнен");




















#FileResult #PhysicalFileResult #PhysicalFile #result #viewresult #byte #io

#FileContentResult: отправляет клиенту массив байтов, считанный из файла

#VirtualFileResult: представляет простую отправку файла напрямую с сервера по виртуальному пути

#FileStreamResult: создает поток - объект System.IO.Stream, с помощью которого считывает и отправляет файл клиенту

#PhysicalFileResult: также отправляет файл с сервера, но для отправки используется реальный физический путь


"application/octet-stream" -- универсальный тип файлов, если не можем определить правильный
"application/mp4";

#file 
public IActionResult GetFile()
        {
            // Путь к файлу
            string file_path = Path.Combine(_appEnvironment.ContentRootPath, "Files/book.pdf");//см path
            // Тип файла - content-type
            string file_type = "application/pdf";
            // Имя файла - необязательно
            string file_name = "book.pdf";
            return PhysicalFile(file_path, file_type, file_name);
        }

#byte


// Отправка массива байтов
string path = Path.Combine(_appEnvironment.ContentRootPath, "Files/book.pdf");
    byte[] mas = System.IO.File.ReadAllBytes(path);
    string file_type = "application/pdf";
    string file_name = "book2.pdf";
    return File(mas, file_type, file_name);



// Отправка потока
public FileResult GetStream()
{
    string path = Path.Combine(_appEnvironment.ContentRootPath, "Files/book.pdf");
    FileStream fs = new FileStream(path, FileMode.Open);
    string file_type = "application/pdf";
    string file_name = "book3.pdf";
    return File(fs, file_type, file_name);
}




VirtualFileResult работает похожим образом, только возвращает файл по виртуальному пути. Здесь надо учитывать, что по умолчанию все пути к файлам в данном случае будут сопоставляться с папкой wwwroot. То есть нам надо помещать папки с файлами или отдельные файлы в каталог wwwroot:
В данном случае предполагается, что файл "hello.txt" располагается в папке "wwwroot/Files/".
public VirtualFileResult GetVirtualFile()
{
    var filepath = Path.Combine("~/Files", "hello.txt");
    return File(filepath, "text/plain", "hello.txt");
}















#controller
#filter #методы
public class HelloBaseController : Controller{}



все метод с атрибутом [NonAction] и являются альтернативой фильтрам действий
Метод #OnActionExecuting() выполняется при вызове метода контроллера до его непосредственного выполнения.

Метод #OnActionExecuted() выполняется после выполнения метода контроллера.

Метод #OnActionExecutionAsync() представляет асинхронную версию метода OnActionExecuting().


создаем класс(но можно и не создавать, а переопределить сразу в нужном контроллере)
Также мы бы могли переопределить какие-либо другие действия или определить новые общие для всех действия
public abstract class HelloBaseController : Controller
{
    public override void OnActionExecuting(ActionExecutingContext context)
    {
        if (context.HttpContext.Request.Headers.ContainsKey("User-Agent") &&//проверяем, установлен ли заголовок "User-Agent":
//содержит ли этот User-Agent MSIE 8.0 (то есть юзерагент для IE 8)
            Regex.IsMatch(context.HttpContext.Request.Headers["User-Agent"].FirstOrDefault(), "MSIE 8.0"))
        {
//переопределяется результат метода в виде переадресации:
            context.Result = Content("Internet Explorer 8.0 не поддерживается");
        }
        base.OnActionExecuting(context);
    }
}


теперь делаем так и теперь до начала работы метода Index будет срабатывать метод OnActionExecuting(), определенный в базовом классе HelloBaseController
public class HomeController : HelloBaseController
{
    public IActionResult Index()
    {
        return Content("Запрос успешно выполнен");
    }
    // остальные методы контроллера
}

















#ControllerContext #context
#param #параметры #запрос #ответ

свойства класса ControllerContext
#HttpContext: содержит информацию о контексте запроса

#ActionDescriptor: возвращает дескриптор действия - объект ActionDescriptor, который описывает вызываемое действие контроллера

#ModelState: возвращает словарь #ModelStateDictionary, который используется для валидации данных, отправленных пользователем

#RouteData: возвращает данные маршрута
получить в контроллере все параметры маршрута, используя объект RouteData
var controller = RouteData.Values["controller"].ToString();



обращение к 1 и тому же свойству
var ctx1 = ControllerContext.HttpContext;
var ctx2 = HttpContext;

Объект HttpContext инкапсулирует всю информацию о запросе. В частности, он определяет следующие свойства:
#Request: содержит собственно информацию о текущем запросе. #HttpRequest , можно получить через свойство Request класса Conroller
#Response: управляет ответом #HttpResponse , можно получить через свойство Response класса Conroller
#User: представляет текущего пользователя, который обращается к приложению
#Session: объект для работы с сессиями


Request---

#Body: объект Stream, который используетя для чтения данных запроса
#Cookies: куки, полученные в запросе
#Form: коллекция значений отправленных форм
#Headers: коллекция заголовков запроса
#Path: возвращает запрошенный путь - строка запроса без домена и порта
#Query: возвращает коллекцию переданных через строку запроса параметров
#QueryString: возвращает ту часть запроса, которая содержит параметры. Например, в запросе http://localhost:52682/Home/Index?alt=4 это будет ?alt=4

Получим значения определенных заголовков:
string userAgent = Request.Headers["User-Agent"].ToString();
string referer = Request.Headers["Referer"].ToString();



Response---

#Body: объект Stream, который применяется для отправки данных в ответ пользователю
#Cookies: куки, отправляемые в ответе
#ContentType: MIME-тип ответа
#Headers: коллекция заголовков ответа
#StatusCode: статусный код ответа

с его помощью можем отправить ответ
 Response.StatusCode = 404;
            Response.WriteAsync("Ресурс не найден");
















#PartialView #Partial #RenderPartialAsync
частичное представление
@Html.Partial("_GetMessage")
@Html.Partial("_GetMessage", new List<string> { "Lumia 950", "iPhone 6S", "Samsung Galaxy s 6", "LG G 4" })
 <partial name="_LoginPartial" />
<partial name="~/Pages/Folder/_PartialName.cshtml" />
<partial name="../Account/_PartialName.cshtml" />
!!! @await Html.PartialAsync("/Views/Partial/MainHeader.cshtml",new DataArchives.Models.ViewModel.MainHeaderV((string)ViewData["MainHeaderSelectPage"]))

тоже самое что и @{await Html.RenderPartialAsync("_GetMessage");}

 public ActionResult GetMessage()
    {
        return PartialView("_GetMessage");
    







#Области #area
каждая область представляет какой-то свой сегмент приложения. Например, одна область может отвечать за функции администрирования, другая - за управление учетными записями и т.д.
 И каждая область представляет собой мини-проект, имеет свою собственную структуру каталогов. Это позволяет разрабатывать и тестировать код для каждой области отдельно независимо от других областей.
Как правило, области помещаются в отдельную папку.

создать иерархию Areas/Store и добавить - Controllers и Views


создаем контроллер
[Area("Store")]//название области
    public class HomeController : Controller




app.UseMvc(routes =>
            {
//Для сопоставления с областью определен сегмент area. Ограничение exists используется для того, 
//чтобы маршрут сопоставлялся только с теми областями, которые определены в приложении
                routes.MapRoute(
                    name: "areas",
                    template: "{area:exists}/{controller=Home}/{action=Index}");
                routes.MapRoute(
                    name: "default",
                    template: "{controller=Home}/{action=Index}/{id?}");
            });


или можно через атрибуты

[Area("Store")]
public class HomeController : Controller
{
    [Route("[area]/[controller]/[action]")]
    public IActionResult Index()


теперь можно обратиться вот так, где Store - это название области которое указано в атрибуте контроллера
http://localhost:xxxx/Store/Home/Index

для генерации ссылки на контроллер в области, если представление само находится в области
@Html.ActionLink("Онлайн-магазин", "Index", "Home")
// или
<a asp-action="Index" asp-controller="Home">Онлайн-магазин</a>
<a href="Store/Home/Index/">Онлайн-магазин</a>

если не находится в области то надо указать явно
@Html.ActionLink("Все книги", "List", new { area = "Store", controller = "Book" })
// или
<a asp-action="List" asp-controller="Book" asp-route-area="Store">Все книги</a>


если находится в области, а нужно сослаться на основной проект то
@Html.ActionLink("Главная", "Index", new { area = "", controller = "Home" })
// или так
<a asp-action="Index" asp-controller="Home" asp-route-area="">Главная</a>




Если в контроллеры области используют представления, то система будет искать эти представления по следующим путям:

/Areas/Название_области/Views/Название_контроллера/Имя_представления.cshtml
/Areas/Название_области/Views/Shared/Имя_представления.cshtml
/Views/Shared/Имя_представления.cshtml

в главном проекте функциональность tag-хелперов добавляется с помощью файла _ViewImports.cshtml. 
В области он будет недоступен. И чтобы задействовать tag-хелперы в представлениях в области, 
нам надо добавить аналогичный файл в каталог Views, который находится в области. 
Либо же добавлять в представления области эту строку, где надо использовать tag-хелперы









View Component #ViewComponent #компонент
чем то похоже на частичное представление

Есть три способа определения компонента:

определение компонента как обычного класса (класс POCO)
наследование от базового класса ViewComponent
применение к классу атрибута ViewComponent

можно также как в контроллер в конструктор внедрять зависимости


1 способ - Компонент как обычный класс
Согласно условностям классы компонентов помещаются в папку Components
При определении компонента в виде обычного класса C# название этого класса должно оканчиваться на суффикс ViewComponent, 
плюс в самом классе должен быть определен метод Invoke() или InvokeAsync НО!!! только 1, метод может быть с параметрами в таком случае передавать через анонимный объект.

public class BestPhoneViewComponent
    {
        int phones=10;
        public BestPhoneViewComponent()
        {
         phones=11;  
        }
        public string Invoke()
        { 
          return $"число {phones}";
        }
//можно создать асинхронный, он встроится в страницу только после выполнения
public async Task<IViewComponentResult> InvokeAsync()
        {
                   var htmlContent = await reader.ReadToEndAsync();
            return new HtmlContentViewComponentResult(new HtmlString(htmlContent));
        }



    }


//в  view(представлении) пишем так, где BestPhone-название компонента без суффикса ViewComponent
//в результате на страницу отрисуется результат выполнения метода Invoke
@await Component.InvokeAsync("BestPhone")
<p>@await Component.InvokeAsync("PhonesList", new { maxprice = 60000, minprice=20000 })</p>



2 способ создания - Наследование класса ViewComponent
//класс полностью такой же , меняется только название и указывается родитель
public class BestPhone : ViewComponent
    {

#ViewComponentContext
в таком случае  нам становится доступным контекст компонента через ряд свойств:

HttpContext: представляет контекст, который описывает полученный запрос, а также отправляемый ответ
ModelState: представляет состояние модели в виде объекта ModelStateDictionary
Request: возвращает контекст запроса в виде объекта HttpRequest
RouteData: возвращает данные маршрута
Url: представляет объект IUrlHelper, который используется для генерации адресов URL
User: представляет текущего пользователя в виде объкта IPrincipal
ViewBag: представляет динамический объект, который может использоваться для передачи данных в представление
ViewContext: описывает контекст главного представления, в котором вызывается компонент
ViewComponentContext: представляет объект ViewComponentContext, который инкапсулирует контекст компонента
ViewData: возвращает объект ViewDataDictionary, который применяется для передачи данных в представление

public IViewComponentResult Invoke()
        {
            // если передан параметр id. берем параметр "id", который определен в маршруте по умолчанию
            if(RouteData.Values.ContainsKey("id"))
                Int32.TryParse(RouteData.Values["id"]?.ToString(), out maxPrice);
            ViewBag.Phones = phones.Where(p => p.Value <= maxPrice).ToList();





3 способ создания - Применение атрибута ViewComponent
//добавляем атрибут, меняем название, остальное точно так же
[ViewComponent]
public class BestPhone
{




компоненты могут возвращать не только строку но и #IViewComponentResult
имеется 3 реализации
#ViewViewComponentResult: используется для генерации представления Razor с возможностью передачи модели. Для создания этого объекта может применяться метод View() класса ViewComponent
ViewComponentResult позволяет использовать для рендеринга контента частичное представление. Если мы наследуем класс компонента от базового класса ViewComponent, то для генерации объекта ViewComponentResult мы можем вызвать унаследованный метод View
перегруженные версии
View(): для рендеринга контента выбирает представление по умолчанию
View(model): для рендеринга контента выбирает представление по умолчанию, в которое передает некоторую модель
View(viewName): для рендеринга контента выбирает представление с именем viewName
View(viewName, model): для рендеринга контента выбирает представление с именем viewName, в которое передает некоторую модель

Если при вызове метода View в компоненте имя представления явным образом не указано, то в качестве представления используется файл Default.cshtml. Для поиска файла представления Razor будет просматривать следующие пути в порядке приоритета:
Views/Название_Контроллера/Components/Название_Компонента/Название_Представления.cshtml
Views/Shared/Components/Название_Компонента/Название_Представления.cshtml

public class PhonesList : ViewComponent
    {
public IViewComponentResult Invoke(int maxPrice)
        {
            var items = phones.Where(p => p.Value <= maxPrice).ToList();
 return View("Phones", items);
            return View(items);
        }




#ContentViewComponentResult: применяется для отправки текстового контента. Для создания объекта используется метод Content() , который в качестве параметра принимает строку.
public IViewComponentResult Invoke()
        {
//в данном случае ВСЕ(и html) будет интерпретироваться как строки
            return Content($"Самый дорогой телефон: {item.Key} - {item.Value.ToString("c")}");
        }


#HtmlContentViewComponentResult: представляет фрагмент кода HTML, который инкорпорируется в веб-станицу
 public IViewComponentResult Invoke()
        {
//html будет интерпретироваться как html а не как строка
            return new HtmlContentViewComponentResult(
                new HtmlString($"<h3>Самый дорогой телефон: {item.Key} - {item.Value.ToString("c")}</h3>"));
        }











#привязка #IModelBinder #ModelBinder #binder


Для поиска значений привязчик модели используется следующие источники в порядке приоритета:
Данные форм. Хранятся в объекте Request.Form
Данные маршрута, то есть те данные, которые формируются в процессе сопоставления строки запроса маршруту. Хранятся в объекте RouteData.Values
Данные строки запроса. Хранятся в объекте Request.Query

свойства, к которым осуществляется привязка, должны быть объявлены с модификатором public и быть доступными для записи
класс должен иметь общедоступный конструктор по умолчанию
И когда будет осуществляться механизм привязки для создания объекта будет использоваться этот стандартный конструктор, и затем у созданного объекта будут устанавливаться свойства.



#BindRequired и #BindNever #attr #binding
изменение алгоритма привязки

Атрибут BindRequired требует обязательного наличия значения для свойства модели.

Атрибут BindNever указывает, что свойство модели надо исключить из механизма привязки.

public class User
{
    [BindRequired]
    public string Name { get; set; }
    [BindNever]
    public bool HasRight { get; set; }
}
//вот так можно проверить  // #ModelState #IsValid
if(ModelState.IsValid)



#BindingBehavior 
перечисление
#Required: аналогично примению атрибута BindRequired
#Never: аналогично примению атрибута BindNever
#Optional: действие по умолчанию, мы можем передавать значение, а можем и не передавать, тогда будут применяться значения по умолчанию


 [BindingBehavior(BindingBehavior.Required)]
    public string Name { get; set; }



Атрибут #Bind позволяет установить выборочную привязку отдельных значений. Так, применим атрибут в методе AddUser:
public IActionResult AddUser([Bind("Name", "Age", "HasRight")] User user)

переобпределяем для всей сущности
[Bind("Name")]
public class User
{



можем указать где необходимо искать данные для привязки

#FromHeader]: данные берутся из заголовоков запроса
#FromQuery]: данные берутся из строки запроса
#FromRoute]: данные берутся из значений маршрута
#FromForm]: данные берутся из полученных форм
#FromBody]: данные берутся из тела запроса. Этот атриут может применяться, когда в качестве источника данных выступает не форма и не строка запроса, а, скажем, данные отправляются через код javascript
Атрибут FromBody может применяться, если метод имеет только один параметр, иначе будет сгенерировано исключение.

public IActionResult GetUserAgent([FromHeader(Name="User-Agent")] string userAgent)
public IActionResult AddUser([FromQuery] User user)


создание привязчика модели #TODO
https://metanit.com/sharp/aspnet5/8.6.php











#filer #pipeline #фильтры #IActionFilter
Фильтры позволяют выполнять некоторые действия до или после определенной стадии обработки запроса. В ASP.NET Core имеются следующие типы фильтров:
например можно что то записать в куки, применить фильтр глобально и это заменит вызов записи в куки для каждого метода всех контроллеров

есть разные версии(синхронные и асинхронные) и для каждой версии свой интерфейс, 
но одновременно можно реализовать только 1 интерфейс. Если же класс будет реализовать оба варианта, то система будет вызывать только метод асинхронного интерфейса, а реализация синхронного интерфейса будет игнорироваться.

I[Stage]Filter, где [Stage] - это этап обработки запроса, на котором вызывается фильтр
Синхронные фильтры определяют два метода: On[Stage]Executing и On[Stage]Executed. Метод On[Stage]Executing вызывается непосредственно перед этапом Stage, а метод On[Stage]Executed сразу после завершения этапа [Stage].
Асинхронные интерфейсы фильтров называются IAsync[Stage]Filter, и они определяют только один метод - On[Stage]ExecutionAsync

подробнее все фильтры описаны ниже
Фильтры авторизации: определяют, авторизован ли пользователь для выполнения текущего запроса
#IAuthorizationFilter  #IAsyncAuthorizationFilter

Фильтры ресурсов: выполняются после фильтров авторизации, а также после всех остальных фильтров
#IResourceFilter #IAsyncResourceFilter

Фильтры действий: применяется к действиям контроллера, запускается после фильтра ресурсов как до, так и после выполнения метода контроллера
#IActionFilter #IAsyncActionFilter

Фильтры исключений: определяют действия в отношении необработанных исключений
#IExceptionFilter #IAsyncExceptionFilter

Фильтры результатов действий: фильтр применяется к результатам действий, выполняется как до, так и после получения результата
#IResultFilter #IAsyncResultFilter

//желательно также наследовать от Attribute тк фильтры используются в основном как атрибуты
public class SimpleActionFilter : Attribute, IActionFilter
    {
public SimpleActionFilter(int age, string message){}

        public void OnActionExecuting(ActionExecutingContext context)
        {}
        public void OnActionExecuted(ActionExecutedContext context)
        { 
		context.HttpContext.Response.Cookies.Append("LastVisit","--");
		//вот так можно остановить конвейер выполнения (предотвратить выполнение последующих фильтров)
// Значение этого свойства фактически будет использоваться в качестве результата выполнения запроса.
		context.Result =  new ContentResult { Content = "Ресурс не найден" };

}}
public class SimpleAsynActionFilter : Attribute, IAsyncActionFilter
    {
        public async Task OnActionExecutionAsync(ActionExecutingContext context, 
                                    ActionExecutionDelegate next)
        {await next();}
    }


применение фильтров
//применяем для метода + передаем параметры в конструктор
[SimpleActionFilter(30,"")]
    public IActionResult Index()


//применяем для контроллера
[SimpleActionFilter]
public class HomeController : Controller



//Глобальная область действия, при которой фильтр применяется ко всем методам всех контроллеров.
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc(options =>
    {
        options.Filters.Add(typeof(SimpleActionFilter)); // подключение по типу
         
        // альтернативный вариант подключения
        //options.Filters.Add(new SimpleActionFilter()); // подключение по объекту
    });
}




для применения внедрения зависимостей \иньекции
нужно переписать параметры

//#ResourceExecutedContext
public class SimpleResourceFilter : Attribute, IResourceFilter
{
    ILogger _logger;
    public SimpleResourceFilter(ILoggerFactory loggerFactory)
    {
        _logger = loggerFactory.CreateLogger("SimpleResourceFilter");
    }
    public void OnResourceExecuted(ResourceExecutedContext context)
    {}
 
    public void OnResourceExecuting(ResourceExecutingContext context)
    {}
}


//применение с зависимостями #ServiceFilterAttribute
//нужно зарегистрировать в ConfigureServices
[ServiceFilter(typeof(SimpleResourceFilter))]
public class HomeController : Controller



public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    services.AddScoped<SimpleResourceFilter>();
}



////применение с зависимостями #TypeFilterAttribute
В этом случае класс фильтра больше не надо регистрировать в ConfigureServices()
[TypeFilter(typeof(SimpleResourceFilter))]
public class HomeController : Controller





//возможно расписывать каждый тип фильтр смысла нет ХЗ


#Фильтры #filter #ресурсов

#IResourceFilter #IAsyncResourceFilter.


//#ie #MSIE #ResourceExecutedContext
public class IEFilterAttribute : Attribute, IResourceFilter
    {
//срабатывает после выполнения метода и фильтров действий, исключений и результатов
        public void OnResourceExecuted(ResourceExecutedContext context){}
 
//срабатывает после фильтров авторизации, но до выполнения метода и работы фильтров действий, исключений и результатов
        public void OnResourceExecuting(ResourceExecutingContext context)
        {
            // получаем информацию о браузере пользователя
            string userAgent = context.HttpContext.Request.Headers["User-Agent"].ToString();
            if(Regex.IsMatch(userAgent, "MSIE [6-9]"))
            {
//на этом обработка запроса завершается, и метод и последующие фильтры не выполняются
                context.Result = new ContentResult { Content = "Ваш браузер устарел" };
            }
        }
    }





#IActionFilter #IAsyncActionFilter
Фильтры действий выполняются после фильтров авторизации и ресурсов и уже после того, как произошла привязка модели. 
----Поэтому данные фильтры являются прекрасным местом для исследования результатов привязки модели, а также модификации входных данных в метод контроллера или его результата.

public class WhitespaceAttribute : Attribute, IActionFilter
    {
        public void OnActionExecuting(ActionExecutingContext context){}
 
        public void OnActionExecuted(ActionExecutedContext context)
        {
            var response = context.HttpContext.Response;
            // Если sitemap, то ничего не делаем
            if (context.HttpContext.Request.Path.ToString() == "/sitemap.xml") return;
            if (response.Body == null) return;
            response.Body = new SpaceCleaner(response.Body);
        }
//если async интерфейс
public async Task OnActionExecutionAsync(ActionExecutingContext context, 
                                                        ActionExecutionDelegate next)
        {
            if (context.ModelState.IsValid == false)
                context.ActionArguments["id"] = 34;
            await next();
        }




#IResultFilter #IAsyncResultFilter #ResultExecutingContext
Фильтры результатов выполняются только тогда, когда выполнение метода завершилось успешно.
Фильтры результатов не вызываются, если фильтры исключений обрабатывают исключение, но не устанавливают свойство Exception = null.
Как правило, фильтры результатов применяются, когда надо выполнить какую-то постобработку результата метода, отформатировать его.

Если при выполнении результата действия будет выброшено исключение, то свойство ResultExecutedContext.Exception будет иметь значение, отличное от null. Установка свойства ResultExecutedContext.Exception в null позволит некоторым образом обработать исключение и предотвратить выброс исключение на последующих этапах обработки запроса
При добавлении каких-нибудь заголовков в ответ в фильтре результатов это следует делать до выполнения результата, то есть в методе OnResultExecuting(), а не в OnResultExecuted()

public class TimeExecutionFilterAttribute : Attribute, IResultFilter
    {
        DateTime start;
//вызывается перед выполнением результата метода
        public void OnResultExecuting(ResultExecutingContext context)
        {
            start = DateTime.Now;
//можно предотвратить дальнейшее выполнение фильтров и обработку запроса, установив свойство ResultExecutingContext.Cancel равным true.
        }
//вызывается после выполнения результата действия
        public async void OnResultExecuted(ResultExecutedContext context)
        {
            DateTime end = DateTime.Now;
            double processTime = end.Subtract(start).TotalMilliseconds;
            await context.HttpContext.Response.WriteAsync($"Время выполнения результата: {processTime} миллисекунд");
//можно предтвратить дальнейшую обработку запроса на других фильтрах, присвоив свойству ResultExecutedContext.Canceled значение true
        }

//async
public async Task OnResultExecutionAsync(ResultExecutingContext context, 
                                                    ResultExecutionDelegate next)
    {
        context.HttpContext.Response.Headers.Add("DateTime", DateTime.Now.ToString());
        await next();
    }

    }





#Фильтры #исключений #exception

Фильтры исключений обрабатывают необработанные исключения, в том числе те, которые возникли при создании контроллера и привязки модели. При этом надо сразу отметить, что они обрабатывают только исключения, которые возникают при вызове действия контроллера в MVC, а не абсолютно все исключения в приложении. В этом плане они менее гибки, чем, скажем, компоненты middleware, которые также предназначены для обработки исключений

#IExceptionFilter #IAsyncExceptionFilter #ExceptionContext

При установке свойства context.ExceptionHandled равным true мы можем получить эффект, как будто мы обработали исключение. И в этому случае обработка запроса продолжится, как будто никакого исключения и не было, а браузеру будет отправлен статусный код 200 OK.

public class CustomExceptionFilterAttribute : Attribute, IExceptionFilter
    {
        public void OnException(ExceptionContext context)
        {
            string actionName = context.ActionDescriptor.DisplayName;
            string exceptionStack = context.Exception.StackTrace;
            string exceptionMessage = context.Exception.Message;
            context.Result = new ContentResult
            {
                Content = $"В методе {actionName} возникло исключение: \n {exceptionMessage} \n {exceptionStack}"
            };
//исключение будет считаться обработанным
            context.ExceptionHandled = true;
        }
    }













#page #PageModel
создание страниц #razor
папки Pages
нужно подключить в ConfigureServices

Например, обратимся к About.cshtml и для этого введем адрес /About:
Путь к странице

URL

/Pages/Index.cshtml ----   / или /Index
/Pages/Contact.cshtml  ---- /Contact
/Pages/Store/Contact.cshtml ---  /Store/Contact
/Pages/Store/Index.cshtml     --- /Store или /Store/Index







В начале идет директива @page, которая по сути и делает обычное представление страницей Razor. Эта директива позволяет страницам обрабатывать запросы напрямую без контроллеров.
//код страницы

@page
@model AboutModel
@{
    ViewData["Title"] = "About";
}
<h2>@ViewData["Title"]</h2>
<h3>@Model.Message</h3>



//этот класс одновременно будет и обрабатывать запрос и будет моделью, он должен создаваться для файла cshtml и будет по архитектуре как бы в него вложен
файл About.cshtml.cs
public class AboutModel : PageModel
    {
//#BindProperty, если применить такой атрибут то параметры не обязательно передавать через методы, достаточно просто определить свойство
//Type: тип привязчика модели
//Name: имя данных в запросе, если оно отличается
//SupportGet: поддерживает ли запросы get, изначально имеет значение false
//[BindProperty(Name="id", SupportsGet=true)]
[BindProperty]
        public string Message { get; set; }

//при таком применении все будет нормально работать, свойства правильно свяжутся по именам, как если бы мы определили их без класса
[BindProperty]
        public Entry CLP { get; set; }
 
//метод #OnGet обрабатывает GET-запросы
        public void OnGet(int? param)
        {
            Message = "Your application description page.";
        }
//On[Тип_запроса] - запросы которые может обрабатывать модель
//#OnGetAsync(), а запросы Post - методами #OnPost() и #OnPostAsync()



//если хотим определить еще методы для обработки запросов то On[Тип_запроса][доп название]
//для передачи чего либо этому методу нужно в строке запроса ( http://localhost:56288/Person?handler=ByName&name=Tom ) указать handler= название метода
//иногда так сделать не получится и тогда нужно модифицировать представление см ниже
public void OnGetByName(string name)
        {}


//если надо возвращать не void
//но данный класс так и остается моделью представления=> его не надо передавать как в обычном методе
public IActionResult OnGet(string name)
        {
#Content() возвращает объект ContentResult, то есть фактически некоторое текстовое содержимое
#File() возвращает с помощью различных перегруженных версий объекты FileContentResult/FileStreamResult/VirtualFileResult, то есть отправляет клиенту файл
#Forbid() возвращает статусный код 403
#LocalRedirect()/LocalRedirectPermanent() выполняет переадресацию по определенному локальному адресу
#NotFound() возвращает статусный код 404
#PhysicalFile() возвращает файл по физическому пути
#Page() возвращает объект PageResult или фактически текущую страницу Razor
#Redirect()/RedirectPermanent() выполняет переадресацию по определенному адресу

string url = Url.Page("About", new {name="Tom", age=34});
    return Redirect(url);

#RedirectToAction()/RedirectToActionPermanent() выполняет переадресацию на определенное действие контроллера
#RedirectToPage()/RedirectToPagePermanent() выполняет переадресацию на определенную страницу Razor

Например, текущая страница расположена по пути Pages/Products/Create.cshtml, и из нее вызывается метод RedirectToPage.
RedirectToPage("/Index")  --- Pages/Index
RedirectToPage("./Index") --- Pages/Products/Index
RedirectToPage("../Index") ---Pages/Index
RedirectToPage("Index") ---Pages/Products/Index
return RedirectToPage("Index");

#RedirectToRoute()/RedirectToRoutePermanent() выполняет переадресацию по определенному маршруту
#StatusCode() возвращает объект StatusCodeResult, то есть посылает статусный код
#Unauthorized() возвращает объект UnauthorizedResult, то есть статусный код ошибки 401

            return Page();
        }

    }



Для обработки запроса можно использовать класс, производный от PageModel. 
Однако страница Razor уже сама по себе представляет модель. И мы можем всю логику обработки и свойства модели определить напрямую в странице.
но так лучше не делать


@page
//если указать так то можно будет получить параметры запроса сразу в представлении через var userid = RouteData.Values["id"]; и использовать потом так: <h1>@userid</h1>
//если указана @model Entry и в ней  [BindProperty(SupportsGet = true)] то они будут записываться туда
//@page "{id}"
//@page "{id}/{name}/{age}"
//@page "{id:int}/{name:alpha:minlength(3)}/{age:int}"

//позволит указать метод для обрабоки запроса, нужно что бы была указана model
//http://localhost:56288/Person/ByName?name=Tom
//@page "{handler?}"

//передавать можно просто параметром <input type="submit" asp-page-handler="GreaterThan" value="Старше" />
//если закинуть в пост форму то тоже будет работать



@{
    ViewData["Title"] = "Factorial";
}
@functions {
    public string Message { get; set; }
    public void OnGet()
    {
        Message = "Введите число";
    }
    public void OnPost(int? number)
    {}
}
 
<h2>@Model.Message</h2>
<form method="post">
    <input type="number" name="number" />
    <input type="submit" value="Send" />
</form>




Создание адреса на страницу в представлении:
<a href='@Url.Page("/About", new {name="Bob", age=32 })'>About</a>
<a asp-page="About" asp-route-name="Bob" asp-route-age="32" asp-page-handler="GreaterThan">About</a>







#AddRazorPagesOptions #RootDirectory 
//Для настройки конфигурации Razor Pages 
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc().AddRazorPagesOptions(options =>
    {
//настраивается путь к папке со страницами Razor. По умолчанию этот папка Pages, но мы можем указать любую другую с помощью этого свойства.
        options.RootDirectory = "RazorPages";
    });
}
















 #api
пу сути обычное mvc приложение которое возвращает не html а результат
public List<int> Index(){}


контроллер желательно унаследовать от #ControllerBase а не от Controller
к контроллеру атрибут [#ApiController]



#webapi #web 
выделяется сущность и за работу с этой сущностью будет отвечать выбранный контроллер
в контроллере создаются методы!!! Get Post Put Delete, которые обрабатывают соответствующие запросы


#restapi #rest 
архитектурный стиль
также строится на 4х http методах
сервер не запоминает состояние пользователя между запросами(состояние #stateless, когда данные хранятся stateful ) - в каждом запросе передаётся информация, 
идентифицирующая пользователя (например token)и все параметры, необходимые для выполнения операции.
обычные контроллеры, которые возвращают данные
отсутствие состояния для того что бы любой запрос мог обработать людей сервер, допустим 2 запроса подряд(А И Б), запрос А обработается сервером А а запрос Б сервером Б и ничего не сломается тк нет сессий и тд


#soap
протокол
возвращает только xml



#put - при одинаковых входных данных всегда одинаковый результат
put-создание, 
#post-изменение,
#get-получение,
#delete-удаление, 
#patch частичное изменение





#jwt #token
штука для аутентификации
использовать можно для апи

//генерировать токен можно через  #IdentityServer или #OpenIdDict ниже вариант с OpenIdDict


services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
                    .AddJwtBearer(options =>
                    {
                        options.RequireHttpsMetadata = false;
                        options.TokenValidationParameters = new TokenValidationParameters
                        {
                            // укзывает, будет ли валидироваться издатель при валидации токена
                            ValidateIssuer = true,
                            // строка, представляющая издателя
                            ValidIssuer = AuthOptions.ISSUER,
 
                            // будет ли валидироваться потребитель токена
                            ValidateAudience = true,
                            // установка потребителя токена
                            ValidAudience = AuthOptions.AUDIENCE,
                            // будет ли валидироваться время существования
                            ValidateLifetime = true,
 
                            // установка ключа безопасности
                            IssuerSigningKey = AuthOptions.GetSymmetricSecurityKey(),
                            // валидация ключа безопасности
                            ValidateIssuerSigningKey = true,
                        };
                    });
 
            services.AddMvc();





public class AuthJWT
    {
        public const string ISSUER = "MyAuthServer"; // издатель токена
        public const string AUDIENCE = "http://localhost:51884/"; // потребитель токена
        const string KEY = "mysupersecret_secretkey!123";   // ключ для шифрации
        public const int LIFETIME = 1; // время жизни токена - 1 минута
        public static SymmetricSecurityKey GetSymmetricSecurityKey()
        {
            return new SymmetricSecurityKey(Encoding.ASCII.GetBytes(KEY));
        }


        public async static Task<ClaimsIdentity> GetIdentity(string username, string password, UserManager<ApplicationUser> userManager)
        {
            
            var user = await userManager.FindByNameAsync(username);
            if (user == null)
                return null;

            var passwordOK = await userManager.CheckPasswordAsync(user, password);
            if (!passwordOK)
                return null;

            if (user!= null)
            {
                var claims = new List<Claim>
                {
                    new Claim(type:ClaimsIdentity.DefaultNameClaimType,value:user.UserName)//,
                    //new Claim(type:ClaimsIdentity.DefaultRoleClaimType, value:user.Role)
                };
                ClaimsIdentity claimsIdentity =
                new ClaimsIdentity(claims, "Token", ClaimsIdentity.DefaultNameClaimType,
                    ClaimsIdentity.DefaultRoleClaimType);
                return claimsIdentity;
            }

            // если пользователя не найдено
            return null;
        }
    }







[Route("api/Account")]
    [ApiController]
    public class AccountApiController : ControllerBase
    {
        readonly UserManager<ApplicationUser> _userManager=null;

        public AccountApiController(UserManager<ApplicationUser> userManager)
        {
            _userManager = userManager;
        }

        [HttpPost("/token")]
        public async Task Token(string username,string password)
        {
            //var username = Request.Form["username"];
            //var password = Request.Form["password"];

            var identity = await AuthJWT.GetIdentity(username, password, _userManager);
            if (identity == null)
            {
                Response.StatusCode = 400;
                await Response.WriteAsync("Invalid username or password.");
                return;
            }

            var now = DateTime.UtcNow;
            // создаем JWT-токен
            var jwt = new JwtSecurityToken(
                    issuer: AuthJWT.ISSUER,
                    audience: AuthJWT.AUDIENCE,
                    notBefore: now,
                    claims: identity.Claims,
                    expires: now.Add(TimeSpan.FromMinutes(AuthJWT.LIFETIME)),
                    signingCredentials: new SigningCredentials(AuthJWT.GetSymmetricSecurityKey(), SecurityAlgorithms.HmacSha256));
            var encodedJwt = new JwtSecurityTokenHandler().WriteToken(jwt);

            var response = new
            {
                access_token = encodedJwt,
                username = identity.Name
            };

            // сериализация ответа
            Response.ContentType = "application/json";
            await Response.WriteAsync(JsonConvert.SerializeObject(response, new JsonSerializerSettings { Formatting = Formatting.Indented }));
        }


    }

var claimsIdentity = this.User.Identity as ClaimsIdentity; 
var #userId = claimsIdentity.FindFirst(ClaimTypes.Name)?.Value;//ClaimTypes.Name - перечисление, мы получаем то что ранее записали в клаймы под флагом этого перечисления




//#TODO проект ProjectRecruting все в файлах AccountApiController(логика взаимодействия) и AuthJWT(вся логика)












#headers #header 
actionContext.HttpContext.Request.Headers.TryGetValue("Authorization", out authorizationToken);

var headers = Request.Headers;

    if (headers.Contains("Custom"))
    {
        string token = headers.GetValues("Custom").First();
    }



$.ajax({
    url: 'api/products/10',
    type: 'GET',
    headers: { 'username': 'test','password':'123' },
    success: function (data) {
        alert(data);
    },
    failure: function (result) {
        alert('Error: ' + result);
    }
});







//логин
$.ajax({
                type: 'POST',
                url: '/token',
                data: loginData
            }).success(function (data) {
                // сохраняем в хранилище sessionStorage токен доступа
                sessionStorage.setItem(tokenKey, data.access_token);
                console.log(data.access_token);
            }).fail(function (data) {
                console.log(data);
            });


//разлогин
sessionStorage.removeItem(tokenKey);


//использование

$.ajax({
                type: 'GET',
                url: '/api/...',
                beforeSend: function (xhr) {
 
                    var token = sessionStorage.getItem(tokenKey);
                    xhr.setRequestHeader("Authorization", "Bearer " + token);
                },
                success: function (data) {
                    alert(data);
                },
                fail: function (data) {
                    console.log(data);
                }
            });














тестирование
#Postman  

#PowerShell

get запросы
Например, в моем случае приложение запускается по адресу http://localhost:51396. Поэтому для тестирования GET-запроса на получение списка объектов от контроллера UsersController я должен ввести в Package Manager Console следующую команду:
Invoke-RestMethod http://localhost:51396/api/users -Method GET


post запросы
Для тестирования POST-запроса необходимо передать объект в формате json с указанием некоторой дополнительной информацией. 
Invoke-RestMethod http://localhost:51396/api/users -Method POST -Body (@{name = "Bob"; age = "35"} | ConvertTo-Json) -ContentType "application/json"
указываем с помощью флага ConvertTo-Json, что объект будет отправляться в формате JSON
Аргумент -Body в этой команде указывает на тело запроса - тот объект, который будет отправляться на сервер


PUT-запросов
Invoke-RestMethod http://localhost:51396/api/users -Method PUT -Body (@{id = "3"; name = "Bob Marley"; age = "44"} | ConvertTo-Json) -ContentType "application/json"


DELETE запросы
Invoke-RestMethod http://localhost:51396/api/users/3 -Method DELETE


программа для тестирования #Fiddler
https://metanit.com/sharp/aspnet5/23.3.php
















#бандлы #bundle #Минификация #mime 
объединение нескольких скриптов в 1 файл и применение mime
уменьшает нагрузку не сервер, сокращает количество запросов
#Grunt, #Gulp. Но рекомендуемым способом именно по отношению к ASP.NET Core является использование расширения Visual Studio - #BundlerMinifier

#bundleconfig.json добавляется просто в проект на уровень startup.cs
[
  {
     // настройки 1-го бандла
  },
  {
    // настройки n-го бандла
  }
]

необязательно исправлять файл вручную. Мы можем также выделить все нужные элементы, нажать на выделенный элемент правой кнопкой мыши и в контекстном меню выбрать пункт Bundler & Minifier -> Bundle and Minify Files



//настройка 1 бандла
{
//путь выходного файла, который будет формироваться в результате объединения файлов
    "outputFileName": "wwwroot/js/site.min.js",
//определяет через запятую набор файлов, которые будут объединяться. То есть в данном случае из файла "wwwroot/js/site.js" будет формироваться файл "wwwroot/js/site.min.js"
    "inputFiles": [
      "wwwroot/js/site.js",
      "wwwroot/js/site.js"
    ],
//указывает, будут ли минифицироваться включаемые в бандл файлы. 
    "minify": {
//Значение enabled: true включает минификацию
      "enabled": true,
//значение "renameLocals": true позволяет сократить имена локальных переменных
      "renameLocals": true
    },
// надо ли генерировать файл-карту сопоставления исходного и выходного файлов
    "sourceMap": false
}




перейдем в меню View -> Other Windows -> Task Runner Explorer. После этого внизу Visual Studio откроется окно Task Runner Explorer. В этом окне нажмем правой кнопкой мыши на пункт Update all files
При открытии контекстого меню нам надо установить привязку с помощью пункта Binding. Здесь имеются четыре типа привязки:
Before Build: бандлы будут собираться перед построением проекта
After Build: бандлы будут собираться после построения проекта
Clean: бандлы будут собираться при очистке проекта
Project Open: бандлы будут собираться при открытии проекта

К примеру выберем опцию Before Build. И далее мы сможем использовать бандлы, подключив стандартным образом:
<link rel="stylesheet" href="~/css/site.min.css" />
<script src="~/js/site.min.js"></script>
Причем не важно, что на данный момент нет таких файлов. Они будут формироваться автоматически при каждом построении проекта.










Microsoft Library Manager -- #Libman. 
Этот менеджер позволяет управлять пакетами клиентских библиотек, замена устаревшему #Bower
#TODO не понял что это
https://metanit.com/sharp/aspnet5/13.7.php

#NPM
https://metanit.com/sharp/aspnet5/13.5.php

#Gulp
https://metanit.com/sharp/aspnet5/13.1.php

#Grunt
https://metanit.com/sharp/aspnet5/13.2.php








Препроцессоры #Less и #Sass
добавим в проект папку, которая будет хранить файлы Less. Пусть эта папка называется Less. Затем в эту папку добавим новый элемент по типу LESS Style Sheet и назовем его styles.less

Файл с кодом less сам по себе ничего не дает. В итоге нам надо его превратить в файл css. Для этого можно использовать менеджеры автоматизации задач, такие как Gulp или Grunt
styles.less->
@base-color:#f7f7fa;
@article-font-size:13px;
@font:Verdana;
 
body{
    font-family:@font;
    background-color:@base-color;
}
h2{font-size:@article-font-size+5;}


https://metanit.com/sharp/aspnet5/13.4.php













#IMemoryCache #Cache #кэш #кеш #MemoryCache

IMemoryCache можно получить через DI

IMemoryCache - класс MemoryCache, который используется по умолчанию, инкапсулирует все объекты кэша в виде словаря Dictionary.

bool TryGetValue(object key, out object value): пытаемся получить элемент по ключу key. При успешном получении параметр value заполняется полученным элементом, а метод возвращает true
object Get(object key): дополнительный метод расширения, который получает по ключу key элемент и возвращает его
void Remove(object key): удаляет из кэша элемент по ключу key
object Set(object key, object value, MemoryCacheEntryOptions options): добавляет в кэш элемент с ключом key и значением value, применяя опции кэширования MemoryCacheEntryOptions


//#AbsoluteExpirationRelativeToNow 
cache.Set(product.Id, product, new MemoryCacheEntryOptions
                {
                    AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5)
                });
Product product = null;
            if (!cache.TryGetValue(id, out product))



ConfigureServices->
//По сути этот сервис устанавливает зависимость для IMemoryCache, создавая объект синглтон services.TryAdd(ServiceDescriptor.Singleton<IMemoryCache, MemoryCache>());
services.AddMemoryCache()








#ResponseCache 
кэширование на стороне клиента
#Cache-Control, #Pragma и #Vary

Основным из них является заголовок Cache-Control, который может принимать следующие значения:
public: ответ будет кэшироваться везде - и на машине клиента, и на промежуточных прокси-серверах
private: ответ будет кэшироваться только на компьютере клиента, но промежуточные прокси-серверы не будут выполнять кэширование
no-cache: ответ нигде не будет кэшироваться
max-age: время кэширования


Для настройки заголовоков ответа атрибут #ResponseCacheAttribute определяет следующие свойства:

Duration: устанавливает максимальное время кэширования в секундах. Является обязательным, если свойство NoStore не равно true. Duration добавляет к заголовку Cache-Control значение max-age с устанавливаемым временным промежутком в секундах
Location: определяет место кэширования. Принимает одно из значений из перечисления ResponseCacheLocation:
	Any: ответ кэшируется везде (в том числе и на прокси-серверах). Является значением по умолчанию
	Client: ответ кэшируется только на компьютере клиента
	None: ответ нигде не кэшируется
NoStore: определяет, будет ли ответ кэшироваться. Если равен true, то ответ не кэшируется, а значения свойств Location и Duration игнорируются. Кроме того, заголовку Cache-Control добавляется значение no-store
VaryByHeader: устанавливает заголовок vary
CacheProfileName: определяет имя профиля кэширования
Order: устанавливает порядок данного атрибута при применении к методу контроллера одновременно нескольких атрибутов

//отключить кеширование
[ResponseCache(NoStore =true, Location =ResponseCacheLocation.None)]
    public IActionResult Index()




#Профили кэширования #CacheProfile
если надо применить к нескольким но не ко всем методам контроллера то можно определить профиль и указывать уже его
//название профиля
[ResponseCache(CacheProfileName = "NoCaching")]
public IActionResult Index()

public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc(options =>
    {
//передается название профиля и собственно профиль
        options.CacheProfiles.Add("Caching",
//Объект профиля устанавливает все те свойства, что и атрибут ResponseCacheAttribute.
            new CacheProfile()
            {
                Duration = 300
            });
        options.CacheProfiles.Add("NoCaching",
            new CacheProfile()
            {
                Location = ResponseCacheLocation.None,
                NoStore = true
            });










Кэширование статических файлов #static #StaticFileResponseContext

 app.UseStaticFiles(new StaticFileOptions()
{
    OnPrepareResponse = ctx =>
    {
        ctx.Context.Response.Headers.Add("Cache-Control", "public,max-age=600");
    }
});
начение "public" указывает, что файл будет кэшироваться как в кэше браузера, так и на промежуточных прокси-серверах.
А параметр max-age задает время кэширования в секундах



если мы изменим, например, содержимое файла css или javascript, то при повторном обращении к приложению браузер продолжит извлекать нужные файлы из кэша
Для решения этой проблемы можно добавлять к статическим файлам версию и при каждом изменении файла соответственно менять версию файла


<link rel="stylesheet" href="/css/site.css?v=123" />
<script src="/js/site.js?v=123"></script>
<img src="/images/banner1.svg?v=123" />

//или

<link rel="stylesheet" href="~/css/site.css" asp-append-version="true" />
<script src="~/js/site.js" asp-append-version="true"></script>
<img src="~/images/banner1.svg" asp-append-version="true" />














#Сжатие ответа #Compression #mime
уменьшает производительность, поэтому лучше не использоваться для данных меньше 1 кб
#mod_deflate #Nginx Microsoft.AspNetCore.#ResponseCompression
если в таком применении не указать явно компрессор то будет использоваться #GzipCompressionProvider


public void ConfigureServices(IServiceCollection services)
        {
            // добавляем сервис компрессии
            services.AddResponseCompression();
//если создавали свой провайдер
services.AddResponseCompression(options =>
    {
        options.Providers.Add(new DeflateCompressionProvider());
    });

//если хотим добавить свой mime тип
options.MimeTypes = ResponseCompressionDefaults.MimeTypes.Concat(new[]
    {
        "image/svg+xml",
        "application/atom+xml"
    }); 
    options.Providers.Add<GzipCompressionProvider>();


//По умолчанию для протокола HTTPS отключено сжатие, но его можно подключить, использовав #EnableForHttps
services.AddResponseCompression(options =>
    {
        options.EnableForHttps = true;
    });




//если надо явно указать компрессор
services.Configure<GzipCompressionProviderOptions>(options =>
    {
        options.Level = CompressionLevel.Optimal;
    });



public void Configure(IApplicationBuilder app)
        {
            // подключаем компрессию
            app.UseResponseCompression();
 
            app.Run(async context =>
            {
                // отправляемый текст
                string loremIpsum = "Lorem Ipsum is simply dummy text ... including versions of Lorem Ipsum.";
                // установка mime-типа отправляемых данных
                context.Response.ContentType = "text/plain";
                // отправка ответа
                await context.Response.WriteAsync(loremIpsum);
            });
        }



На данный момент middleware компрессии поддерживает следующие MIME-типы:

#text/plain
#text/css
#application/javascript
#text/html
#application/xml
#text/xml
#application/json
#text/json





#GzipCompressionProvider

имеет свойство Level, которое устанавливает уровни сжатия и может принимать следующие значения:
CompressionLevel.Fastest: сжатие должно происходить как можно быстрее, даже если оно будет неоптимальным в плане уменьшения объема данных.
CompressionLevel.NoCompression: сжатие не применяется
CompressionLevel.Optimal: данные должны быть максимально сжаты, даже если для этого потребуется больше времени





создание своих провайдеров #ICompressionProvider


//данный провайдер будет срабатывать, если клиент прислал в запросе в заголовке Accept-Encoding значение deflate.
public class DeflateCompressionProvider : ICompressionProvider
    {
//указывает на формат сжатия, который поддерживает клиент. Данный формат содержится в заголовке Accept-Encoding в запросе к серверу, наподобие: Accept-Encoding: gzip, deflate, sdch, br
        public string EncodingName => "deflate";
//поддерживается ли сброс записи в поток
        public bool SupportsFlush => true;
 //возвращает сам поток ответа после сжатия или фактически обертка над изначальным потоком ответа, который передается в качестве параметра в метод. Для сжатия применяется встроенный класс #DeflateStream()
        public Stream CreateStream(Stream outputStream)
        {
            return new DeflateStream(outputStream, CompressionLevel.Optimal);
        }
    }















#test #unit #тестирование 


Фрейморки тестирования
#xUnit.net: фреймворк тестирования для платформы .NET. Наиболее популярный фреймворк для работы именно с .NET Core и ASP.NET Core
MS Test: фреймворк юнит-тестирования от компании Microsoft, который по умолчанию включен в Visual Studio и который также можно использовать с .NET Core
#NUnit: портированный фреймворк с JUnit для платформы .NET


Отдельно стоит сказать о концепции #TDD или разработка через тестирование. TDD представляет процесс применения юнит-тестов, при котором сначала пишутся тесты, а потом уже программный код, достаточный для выполнения этих тестов.
Порядок написания кода при TTD :
Пишем юнит-тест
Запускаем его и видим, что он завершился неудачей (программный код ведь еще не написан)
Пишем некоторое количество кода, достаточное для запуска теста
Снова запускаем тест и видим его результаты


Согласно условностям название проекта юнит-тестов называется [название_приложения].Tests. 
начиная с Visual Studio 2017 специально для тестов были добавлены два типа проектов: xUnit Test Project(.NET Core)(фреймворк xUnit) и Unit Test Project(.NET Core)(MSTest Framework)


дальше алгоритм просто через добавление в решение проекта типа Class Library (.NET Core) + добавление xUnit руками
При создании проекта тестирования нужно указать "добавить в решение", если нужно чтобы тесты были внутри основного проекта
необходимо добавить через NuGet пакеты в таком порядке://первые 3 добавляются автоматически при создании проекта типа xUnit Test Project(.NET Core)
Microsoft.NET.Test.Sdk
xunit: функционал фреймворка тестирования
xunit.runner.visualstudio: обеспечивает интеграцию с Visual Studio
Microsoft.AspNetCore.App

нужно добавить ссылку на главный проект
reference manager->projects->solution->name_proj

После добавления пакетов в проект по типу Class Library или даже при использовании проекта по типу xUnit Test Project(.NET Core) Visual Studio может отображать ошибки пакетов:
Однако это ложные ошибки, их можно игнорировать, на работу проекта тестов они не влияют.




в тестируемом проекте допустим есть этот метод
public class HomeController : Controller
public IActionResult Index()
        {
            ViewData["Message"] = "Hello!";
            return View("Index");
        }


//Для этого в проект тестов добавим новый класс, который назовем HomeControllerTests

#Fact
указывает, что методы представляет тест

#Theory
//#TODO

public class HomeControllerTests
    {
        [Fact]
        public void IndexViewDataMessage()
        {
            // #Arrange
            HomeController controller = new HomeController();
 
            // #Act
            ViewResult result = controller.Index() as ViewResult;
 
            // #Assert

            Assert.Equal("Hello world!", result?.ViewData["Message"]);
//можно не разделять на 3 метода а закинуть одним тестом
//Assert.NotNull(result);
//Assert.Equal("Index", result?.ViewName);
        }
 
        [Fact]
        public void IndexViewResultNotNull()
        {
            // Arrange
            HomeController controller = new HomeController();
            // Act
            ViewResult result = controller.Index() as ViewResult;
            // Assert
            Assert.NotNull(result);
        }
 
        [Fact]
        public void IndexViewNameEqualIndex()
        {
            // Arrange
            HomeController controller = new HomeController();
            // Act
            ViewResult result = controller.Index() as ViewResult;
//ViewResult.Model и тд
            // Assert
//проверяет название вызываемого представления 
            Assert.Equal("Index", result?.ViewName);
        }
    }



запустить тест на выполнение через меню(сверху) Test->Run->All Tests
правой кнопкой в обозревателе решений->выполнить тесты



Модель тестов Arrange-Act-Assert представляет целую парадигму тестирования, которая используется многими фреймворками юнит-тестов:
Arrange: устанавливает начальные условия для выполнения теста, создание объектов и тд
Act: выполняет тест (обычно представляет одну строку кода)
Assert: верифицирует результат теста

Секции Arrange и Act представляют обычный код на языке C#. А секция Assert использует одноименный класс Assert, который определен в библиотеке xUnit.net.

Для проверки результата в классе Assert определено ряд методов, среди которых можно выделить следующие:
All(collection, action): метод подтверждает, что все элементы коллекции collection соответствуют действию action
Contains(expectedSubString, actualString): метод подтверждает, что строка actualString содержит expectedSubString
DoesNotContain(expectedSubString, actualString): метод подтверждает, что строка actualString не содержит строку expectedSubString
DoesNotMatch(expectedRegexPattern, actualString): метод подтверждает, что строка actualString не соответствует регулярному выражению expectedRegexPattern
Matches(expectedRegexPattern, actualString): метод подтверждает, что строка actualString соответствует регулярному выражению expectedRegexPattern
Equal(expected, result): метод сравнивает результат теста в виде значения result и ожидаемое значение expected и подтверждает их равенство
NotEqual(expected, result): метод сравнивает результат теста в виде значения result и ожидаемое значение expected и подтверждает их неравенство
Empty(collection): метод подтверждает, что коллекция collection пустая
NotEmpty(collection): метод подтверждает, что коллекция collection не пустая
True(result): метод подтверждает, что результат теста равен true
False(result): метод подтверждает, что результат теста равен false
IsType(expected, result): метод подтверждает, что результат теста имеет тип expected
IsNotType(expected, result): метод подтверждает, что результат теста не представляет тип expected
IsNull(result): метод подтверждает, что результат теста имеет значение null
IsNotNull(result): метод подтверждает, что результат теста не равен null
InRange(result, low, high): метод подтверждает, что результат теста находится в диапазоне между low и high
IsAssignableFrom<IEnumerable<Phone>>(viewResult.Model); Передается ли в представление в качестве модели объект IEnumerable<Phone>
NotInRange(result, low, high): метод подтверждает, что результат теста не принадлежит диапазону от low до high
Same(expected, actual): метод подтверждает, что ссылки expected и actual указывают на один и тот же объект в памяти
NotSame(expected, actual): метод подтверждает, что ссылки expected и actual указывают на разные объекты в памяти
Throws(exception, expression): метод подтверждает, что выражение expression генерирует исключение exception

//#RedirectToActionResult
var redirectToActionResult = Assert.IsType<RedirectToActionResult>(result);
//#BadRequestResult #NotFoundResult #400 #404
Assert.IsType<BadRequestResult>(result);
Assert.IsType<NotFoundResult>(result);

var viewResult = Assert.IsType<ViewResult>(result);
    var model = Assert.IsType<Phone>(viewResult.ViewData.Model);



#Moq #mock
Moq предназначен для имитации объектов или для создания так называемых фейковых объектов.
добавить через nuget
не зависимо тестируем ли бы post || get метод, все пишется по 1 алгоритму

при таком контроллере
  public class HomeController : Controller
    {
        IRepository repo;
        public HomeController(IRepository r)
        {
            repo = r;
        }
        public IActionResult Index()
        {
            return View(repo.GetAll());
        }
    }


//такое тестирование
// Arrange
//содаем типизированный объект
            var mock = new Mock<IRepository>();//это тот объект который принимает оригинальный контроллер
//устанавливаем метод (GetTestPhones) который будет вызываться вместо метода который используется в контроллере(GetAll)
            mock.Setup(repo=>repo.GetAll()).Returns(GetTestPhones());

//устанавливаем метод(метод в контроллере testPhoneId) и результат
mock.Setup(repo => repo.Get(testPhoneId)).Returns(null as Phone);

//устанавливаем метод(метод в контроллере testPhoneId) GetTestPhones
mock.Setup(repo => repo.Get(testPhoneId)).Returns(GetTestPhones().FirstOrDefault(p => p.Id == testPhoneId));

//создаем контроллер и передаем как DI
            var controller = new HomeController(mock.Object);
//можно создать имитацию ошибки НО в тесте не будет работать проверка if(ModelState.IsValid), потому что в тесте не учитывается механизм привязки модели, а поэтому и ошибок модели в контроллере нет
controller.ModelState.AddModelError("Name", "Required");



#Verify
Assert.Equal("Index", redirectToActionResult.ActionName);
//верифицируем, что метод Create у репозитория точно был вызван
    mock.Verify(r => r.Create(newPhone));




#test #moq #mock #db #ef #core
если надо #имитировать #БД то #UseInMemoryDatabase #InMemoryDatabase

var options = new DbContextOptionsBuilder<ApplicationDbContext>()
                  .UseInMemoryDatabase(Guid.NewGuid().ToString())
                  .Options;
 var context = new ApplicationDbContext(options);//получаем обычный контекст, который уже можно передавать куда угодно  ипользоваться как обычным контекстом
//докинуть using, закрытие using полностью его должно почистить











 #URL #Rewriting #redirect
Rewriting позволяет решить такие стандартные проблемы, как перенаправление с домена с www на домен без www и наоборот или перенаправление с протокола http на #https
URL Rewriting реализуется до того, как запрос попадет в систему маршрутизации, и начнется его непосредственное выполнение в конвейере MVC
вроде как немного похоже на #midleware #TODO возможно стоит ближе к нему перенести
увеличивает накладные расходы на обработку запроса. Поэтому стоит по возможности избегать сложных комплексных правил переопределения строки запроса

nuget-пакете Microsoft.AspNetCore.#Rewrite 
#UseRewriter #RewriteOptions


public void Configure(IApplicationBuilder app)
        {
            // подключаем URL Rewriting
            var options = new RewriteOptions();
            app.UseRewriter(options);





для RouteOptions мы можем задать правила с помощью специальных методов:
#AddRedirect(): выполняет переадресацию с отправкой статусного кода HTTP 301
Метод AddRedirect() в качестве первого параметра принимает регулярное выражение, которому должен соответствовать входящий адрес URL. В качетве адреса в метод AddRedirect передается та часть URL, которая образуется с помощью объединения значений Request.Path и Request.QueryString. То есть, если полный запрошенный адрес http://localhost:1234/home/index?id=4, то в метод AddRedirect передается home/index?id=4

//в данном случае удаляется концевой слеш (например, перенаправляется с "localhost:1234/home/index/" на "localhost:1234/home/index")
var options = new RewriteOptions().AddRedirect("(.*)/$",//любой адрес, который завершается слешем
 "$1");//в качестве адреса для перенаправления будет использоваться та часть исходного URL, которая идет до слеша// То есть "$1" указывает на первую группу в регулярном выражении "(.*)/$"

//перенаправлять с home на home/index
.AddRedirect("[h,H]ome[/]?$", "home/index");

#AddRewrite(): подменяет один адрес другим
Метод AddRewrite() подменяет входящий адрес другим. При этом переадресации как таковой нет, статусный код 301/302 не отправляется клиенту
Первый параметр метода указывает на регулярное выражение, которому должен соответствовать адрес. Второй параметр указывает, на какой адрес надо подменить входящий. Третий параметр - булевое значение устанавливает, надо ли прекратить применение остальных правил, если адрес соответствует выражению из первого параметра.

.AddRewrite(@"home/index/(\d+)", "home/about?id=$1", skipRemainingRules: false)

//Это правило будет траслировать любой запрос типа "product/tablet/23" в запрос в виде "home/products/cat=tablet?id=23
.AddRewrite(@"product/(\w+)/(\d+)", "home/products?cat=$1&id=$2", skipRemainingRules: false);


#AddRedirectToHttps(): выполняет переадресацию на протокол #HTTPS
#AddRedirectToHttpsPermanent(): выполняет переадресацию на протокол HTTPS с отправкой статусного кода HTTP 301 (постоянная переадресация)
//Первый метод в качестве необязательных параметров можно передать статусный код, который будет отправляться, и номер порта (если он отличается от стандартного 443)
.AddRedirectToHttps(301);  // аналогично AddRedirectToHttpsPermanent()


#AddIISUrlRewrite(): в качестве источника правил для переопределения URL использует правила для IIS
#AddApacheModRewrite(): в качестве источника правил для переопределения URL использует правила для Apache
добавим в корень проекта новый xml-файл urlrewrite.xml
<rewrite>
  <rules>
    <rule name="Remove trailing slash">
      <match url = "(.*)/$"/>
      <conditions>
          <add input="{REQUEST_URI}" pattern="(.*)/$" />
      </conditions>
      <action type="Redirect" url ="{R:1}" />
    </rule>
  </rules>
</rewrite>

Все правила определяются в элементе <rules>. Каждое правило, представленное элементом <rule>, состоит из трех частей:
Pattern – выражение, которому должна соответствовать строка запроса и которое задается в элементе <match>
Conditions – различные дополнительные условия, которым должен соответствовать URL-адрес. Например, значения HTTP-заголовков, пути к файлам и т.д.
Action – действие, которое должно выполняться, если строка URL соответствует регулярному выражению в Pattern и условиям Conditions
Мы можем использовать несколько правил одновременно, но их выполнение не всегда обязательно. Поэтому у каждого элемента rule определен атрибут StopProcessing. Если имеет значение true, то после выполнения действия в элементе <action> адрес URL, создаваемый данным правилом, передается в конвейер обработки запроса, а другие правила не будут обрабатываться.


 public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            var options = new RewriteOptions()
                .AddRedirect("[H,h]ome[/]?$", "home/index")
                .AddIISUrlRewrite(env.ContentRootFileProvider, "urlrewrite.xml");
            app.UseRewriter(options);
//при версии >core 2 можно так
using (StreamReader iisReader = File.OpenText("urlrewrite.xml"))
{
    var options = new RewriteOptions().AddIISUrlRewrite(iisReader);
    app.UseRewriter(options);
}





Переопределение URL имеет следующий порядок действий:
Строка запроса сравнивается с выражением в элементе match. Если обнаружится, что запрошенный адрес не соответствует выражению, то модуль URL Rewrite Module прекращает обрабатывать текущее правило и переходит к следующему (если задано несколько правил)
Если строка запроса соответствует выражению в элементе match и при этом не задано никаких дополнительных условий с помощью элемента <conditions>, то URL Rewrite Module выполняет действие, которое определено в правиле с помощью элемента <action>.
Если строка запроса соответствует выражению в элементе match и также определены дополнительные условия, то URL Rewrite Module проверяет эти условия. И если URL соответствует этим условиям, то выполняется действие action





Определение условий

Условия, задаваемые элементом <conditions>, определяют дополнительную логику оценки URL на соответствие правилу. Каждое отдельное условие задается с помощью элемента <add > и настраивается с помощью следующих атрибутов:
input: определяет объект, который будет использоваться условием для оценки. В частности, в примере выше используется input="{REQUEST_URI}", где "REQUEST_URI" представляет переменную сервера, хранящую запрошенный адрес url. Тут также могут использоваться и другие переменные сервера.
pattern: определяет регулярное выражение, которому должен соответствовать объект
matchType: принимает следующие значения:
Pattern: в этом случае объект (в данном случае адрес URL) сопоставляется с выражением в атрибуте pattern. При других значениях атрибут pattern не учитывается
IsFile: определяет, является ли объект (адрес URL) файлом в файловой системе
IsDirectory: определяет, является ли объект (адрес URL) каталогом в файловой системе
ignoreCase: указывает, надо ли игнорировать регистр адреса URL. По умолчанию равно true, поэтому регистр не учитывается
negate: если равно true, то правило применяется, если условие НЕ учитывается. По умолчанию равно false



Определение действий

Если выражение и условия, определяемые правилом, соответствуют объекту (например, адресу URL), то выполняется определенное действие, заданное элементом <action>. Действия могут быть нескольких типов. Тип задается с помощью атрибута type, который принимает следующие значения:
Rewrite: заменяет текущую строку запроса URL другой строкой
Redirect: выполняет редирект, посылая клиенту статусный код 3хх.
CustomResponse: отправляет клиенту определенный статусный код, а также может отправлять специфическое сообщение
AbortRequest: сбрасывает подключение для текущего клиента


Другие атрибуты элемента action:
url: строка, которая будет заменять текущую строку запроса URL
appendQueryString: определяет, должна ли сохраняться та часть строки запроса, которая идет после названия домена и порта. По умолчанию имеет значение true, что значит, что строка запроса со всеми параметрами за исключением названия домена будет сохраняться.
redirectType: статусный код переадресации при использовании типа Redirect (301 – Permanent, 302 – Found, 303 – See other, 307 – Temporary)
statusCode: определяет статусный код в качестве ответа клиенту при использовании типа CustomResponse
subStatusCode: определяет вспомогательный статусный код при использовании типа CustomResponse
statusReason: определяет сообщение, отправляемое клиенту вместе со статусным кодом при использовании типа CustomResponse
statusDescription: определяет сообщение, отправляемое клиенту в теле ответа при использовании типа CustomResponse
statusCode: статусный код в качестве ответа клиенту при использовании типа CustomResponse



Использование переменных сервера

При изменении URL мы можем использовать следующие переменные сервера:
QUERY_STRING: параметры запроса
HTTP_HOST: домен
SERVER_PORT: номер порта
SERVER_PORT_SECURE и HTTPS: указывают, использует ли клиент защищенное подключение
REQUEST_URI: полная строка запроса
URL представляется в следующем виде: http(s)://<host>:<port>/<path>?<querystring>. Допустим, пользователь обращается к URL http://www.somesite.com/home/index?id=2&name=3. Тогда IIS сегментирует ее следующим образом:
path: представляет сегмент home/index. Эта часть затем сравнивается правилом с выражением, определенным в элементе <match>
QUERY_STRING: в данном случае сегмент параметров id=2&name=3
HTTP_HOST: сегмент www.somesite.com
SERVER_PORT: если номер порта не указан, то по умолчанию равен 80.
SERVER_PORT_SECURE равен 0, а HTTPS содержит OFF
REQUEST_URI: сегмент home/index?id=2&name=3
При создании условий для правил мы можем ссылаться на эти переменные через выражение вида "{НАЗВАНИЕ_ПЕРЕМЕННОЙ}". Например, нам нужно условие, согласно которому в строке параметров должен быть числовой параметр id:
<add input="{QUERY_STRING}" pattern="id=([0-9]+)" />
Кроме того, нам доступны заголовки HTTP-запроса, например, строку юзер-агента мы можем получить с помощью выражения "{HTTP_USER_AGENT}".
При использовании заголовков запроса надо учитывать, что все дефисы в названии заголовков (например, User-Agent) заменяются символами подчеркивания. Все строчные буквы заменяются заглавными, а к названию переменных добавляется префикс "HTTP_". Как например, из заголовка User-Agent создается переменная HTTP_USER_AGENT.





Обратные ссылки

Обратные ссылки представляют отдельные сегменты выражений, которые используются в условиях. Например:

<rewrite>
  <rules>
    <rule name="Redirect">
      <match url = "(.*)"/>
      <conditions>
        <add input="{REQUEST_URI}" pattern="([a-z]+)/([a-z]+)/([0-9]+)" matchType="Pattern" />
      </conditions>
      <action type="Redirect" url ="{C:1}/{C:3}" />
    </rule>
  </rules>
</rewrite>



Все обратные ссылки представляют выражения типа {C:N}, где N - число от 0 до 9. При этом значение {C:0} представляет всю попадающую под условие строку.
То есть из строки запроса "home/index/2" генерировались бы три обратных ссылки C:1 = "home", C:2 = "index" и C:3 = "2". И в соответствии с элементом action шла бы переадресация на адрес "home/2".
Кроме условий для создания обратных ссылок могут применяться выражения в элементе match. Все обратные ссылки из выражения match доступны через выражения типа {R:N}, где N - число от 0 до 9. При этом значение {R:0} представляет всю попадающую под условие строку.

Так, рассмотрим другой пример. Допустим, у нас есть правило:

<rule name="Rewrite query" stopProcessing="true">
    <match url="^home/products/([0-9]+)/([_0-9a-z-]+)" />
    <action type="Rewrite" url="home/products?id={R:1}&name={R:2}"  />
</rule>

Например, при запросе http://localhost:50645/Home/Products/2/phones мы получим следующие сегменты:
{R:0} = "Home/Products/2/phones"
{R:1} = "2"
{R:2} = "phones"

В итоге будет формироваться следующая строка URL: http://localhost:50645/Home/Products?id=2&name=phones
//Для тестирования мы можем определить следующий метод:
public IActionResult Products(int id, string name)
    {
        return Content($"{Request.Path.Value}{Request.QueryString.Value}");
    }



Еще один пример - переадресация с домена без www на субдомен www:

<rule name="Redirect to WWW" enabled="true" stopProcessing="true">
    <match url=".*" />
    <conditions logicalGrouping="MatchAll">
        <add input="{HTTP_HOST}" pattern=".*" />
    </conditions>
    <action type="Redirect" url="http://www.localhost:50645/{R:0}" />
</rule>


Или обратное действие - перенаправление с www на домен без www (для домена localhost):

<rule name="Redirect to NonWWW" stopProcessing="true">
    <match url=".*" />
    <conditions logicalGrouping="MatchAll">
          <add input="{HTTP_HOST}" pattern="^localhost" negate="true" />
    </conditions>
    <action type="Redirect" url="http://localhost:50645/{R:0}" />
</rule>










Применение правил для Apache
#htaccess
#RewriteRule

Последующим RewriteRule передается результат предыдущих преобразований
Если надо выполнить переадресацию, то в конце правила используется выражение [R=301] или [R]


Итак, добавим в корень проекта ASP.NET Core новый текстовый файл, который назовем rewrite.txt. Определим в этом файле следующее содержимое
# удаление концевого слеша
#получает запрошенный путь, сравнивает его с регулярным выражением, и если сравнение прошло успешно, то преобразует адрес
RewriteRule (.*)/$ $1 [R=301]
# переадресация  home/index на /
RewriteRule Home/Index$ / [R=301]
# подмена адреса типа Home/Products/2/phones на Home/Products?id=2&name=phones
#никакой переадресации нет, будет просто подмена одного адреса на другой
RewriteRule Home/Products/([0-9]+)/([0-9a-z-]+) Home/Products?id=$1&name=$2




public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            var options = new RewriteOptions()
                .AddApacheModRewrite(env.ContentRootFileProvider, "rewrite.txt");
 
            app.UseRewriter(options);

//при версии >core 2 можно так
using (StreamReader apacheReader = File.OpenText("rewrite.txt"))
{
    var options = new RewriteOptions().AddApacheModRewrite(apacheReader);
    app.UseRewriter(options);
}










определение своих правил с помощью методов или целых классов



 public void Configure(IApplicationBuilder app)
        {
            var options = new RewriteOptions()
                .Add(RewritePHPRequests);//метод определенный в этом же классе
 
            app.UseRewriter(options);


//переопределяет с http://localhost:1234/some.php на http://localhost:1234/html/some.html
static void RewritePHPRequests(RewriteContext context)
        {
            var request = context.HttpContext.Request;
            var response = context.HttpContext.Response;
            var pathValue = request.Path.Value; // запрошенный путь
            // если запрос к папке html, возвращаем ошибку 404
            if (request.Path.StartsWithSegments(new PathString("/html")))
            {
                response.StatusCode = StatusCodes.Status404NotFound;
                context.Result = RuleResult.EndResponse;
                return;
            }
            // если запрос к файлам с расширенем php, переопределяем запрос на папку html
            if (pathValue.EndsWith(".php", StringComparison.OrdinalIgnoreCase))
            {
                string proccedPath = "/html" + pathValue.Substring(0, pathValue.Length - 3) + "html";
                request.Path = new PathString(proccedPath);
            }
        }





если определять  в отдельном классе #IRule #ApplyRule


public class RedirectPHPRequests : IRule
    {
        private readonly string _extension;
        private readonly PathString _newPath;
 
//получаем расширение, которое стоит использовать вместо php, а также путь к документам в рамках проекта
        public RedirectPHPRequests(string extension, string newPath)
        {
            if (string.IsNullOrEmpty(extension))
            {
                throw new ArgumentException(nameof(extension));
            }
            if (!Regex.IsMatch(newPath, @"(/[A-Za-z0-9]+)+?"))
            {
                throw new ArgumentException("Запрошенный путь недействителен", nameof(newPath));
            }
 
            _extension = extension;
            _newPath = new PathString(newPath);
        }
 
        public void ApplyRule(RewriteContext context)
        {
            var request = context.HttpContext.Request;
 
            if (request.Path.StartsWithSegments(new PathString(_newPath)))
            {
                return;
            }
 
            if (request.Path.Value.EndsWith(".php", StringComparison.OrdinalIgnoreCase))
            {
                var response = context.HttpContext.Response;
                var pathValue = request.Path.Value; // запрошенный путь
//устанавливаем постоянную переадресацию
                response.StatusCode = StatusCodes.Status301MovedPermanently;
                context.Result = RuleResult.EndResponse;
                response.Headers[HeaderNames.Location] = _newPath + pathValue.Substring(0, pathValue.Length - 3) + _extension;
            }
        }
    }


применяется вот так
var options = new RewriteOptions()
            .Add(new RedirectPHPRequests(extension:"html", newPath:"/html"));
 
    app.UseRewriter(options);












#Dapper #db  #sql  #IDbConnection  #orm
позволяет выполнять sql код и связывать его с моделями(классами)

#Execute - если не нужен результат
#Query  - если нужен результат

Nuget пакет Dapper

public interface IUserRepository
    {}


 public class UserRepository : IUserRepository
    {
 string connectionString = null;
        public UserRepository(string conn)
        {
            connectionString = conn;
        }
public List<User> GetUsers()
        {
            using (IDbConnection db = new SqlConnection(connectionString))
            {
                return db.Query<User>("SELECT * FROM Users").ToList();
return db.Query<User>("SELECT * FROM Users WHERE Id = @id", new { id }).FirstOrDefault();

///----
var sqlQuery = "INSERT INTO Users (Name, Age) VALUES(@Name, @Age)";
                db.Execute(sqlQuery, user);
 
                // если мы хотим получить id добавленного пользователя
                //var sqlQuery = "INSERT INTO Users (Name, Age) VALUES(@Name, @Age); SELECT CAST(SCOPE_IDENTITY() as int)";
                //int? userId = db.Query<int>(sqlQuery, user).FirstOrDefault();
                //user.Id = userId.Value;
            }
        }




public void ConfigureServices(IServiceCollection services)
        {
            string connectionString = "Server=.\\SQLEXPRESS;Initial Catalog=userstore;Integrated Security=True";
            services.AddTransient<IUserRepository, UserRepository>(provider => new UserRepository(connectionString));
            services.AddMvc();
        }









#swagger

nuget->Swashbuckle.AspNetCore



services.AddSwaggerGen(c =>
            {
                c.SwaggerDoc("v1", new Swashbuckle.AspNetCore.Swagger.Info
                {
                    Version = "v1",
                    Title = "ProjectRecruting",
                    Description = "service for students",
                    TermsOfService = "None",
                    Contact = new Swashbuckle.AspNetCore.Swagger.Contact
                    { Name = "yeap", Email = "@zsuzitor", Url = "" }
                });
                //var xmlFile = "swaggerxmlsettings.xml";
                var xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
                var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
                
//тут подключается файл для записей, его уже создает студия при старте проекта
//по умолчанию называется по названию проекта
//можно изменить так: settings->build(слева в меню)-> output(раздел на странице)->xml documentation file
c.IncludeXmlComments(xmlPath);
            });




app.UseSwagger();

    // Enable middleware to serve swagger-ui (HTML, JS, CSS, etc.),
    // specifying the Swagger JSON endpoint.
    app.UseSwaggerUI(c =>
    {
        c.SwaggerEndpoint("/swagger/v1/swagger.json", "My API V1");
    });


//настройка xml документации
В обозревателе решений щелкните проект правой кнопкой мыши и выберите команду Изменить <имя_проекта>.csproj
Вручную добавьте выделенные строки в файл .csproj:
<PropertyGroup>
  <GenerateDocumentationFile>true</GenerateDocumentationFile>
  <NoWarn>$(NoWarn);1591</NoWarn>
</PropertyGroup>


//пути должны быть как до приложения(http[s], port и тд)
https://localhost:44356/swagger/v1/swagger.json
https://localhost:44356/swagger


//---более детельная настройка через такие комментарии, для их поддержки надо включить поддержку xml для swagger

/// <summary> 
/// описание
/// </summary> 
/// <remarks> 
/// доп уточнения
/// </remarks> 
/// <param name="item"></param> 
/// <returns>New Created Todo Item</returns> 
/// <response code="201">Returns the newly created item</response>
















#img #image #byte #file #IFormFile 

private async Task<string> UploadedFile(IFormFile image)
        {
            string uniqueFileName = null;

            if (image != null)
            {
                string uploadsFolder = Path.Combine(_webHostEnvironment.WebRootPath, "images");
                uniqueFileName = Guid.NewGuid().ToString() + "_" + image.FileName;
                string filePath = Path.Combine(uploadsFolder, uniqueFileName);
                using (var fileStream = new FileStream(filePath, FileMode.Create))
                {
                    await image.CopyToAsync(fileStream);
                }
            }

            return uniqueFileName;
        }




//при множественно загрузке #IFormFileCollection
public async Task<IActionResult> AddFile(IFormFileCollection uploads)
foreach(var uploadedFile in uploads)
    {...}



если байты
byte[] imageData = null;
        // считываем переданный файл в массив байтов
        using (var binaryReader = new BinaryReader(uploadedFile.OpenReadStream()))
        {
            imageData = binaryReader.ReadBytes((int)uploadedFile.Length);
        }



var fileName = ContentDispositionHeaderValue.Parse(((IFromFile)i).ContentDisposition).FileName.Trim('"');

                //получаем формат файла(".jpg"-в таком виде)
                var FileExtension = Path.GetExtension(fileName);


//проверить является ли изображением
NuGet "System.Drawing.Common"
using System.Drawing;
// ...
public bool IsImage(byte[] data)
{
  var dataIsImage = false;
  using (var imageReadStream = new MemoryStream(data))
  {
    try
    {
      using (var possibleImage = Image.FromStream(imageReadStream))
      {
      }
      dataIsImage = true;
    }
    // Here you'd figure specific exception to catch. Do not leave like that.
    catch
    {
      dataIsImage = false;
    }
  }

  return dataIsImage;
}





























































































































