

#TODO


#FromBody


HttpContext context
context.Response.ContentType = "text/html; charset=utf-8";
await context.Response.WriteAsync("Текст: context.Itemstext");

context.Request.Path.Value.ToLower()


//Создание своих сервисов
//https://metanit.com/sharp/aspnet5/2.19.php


#kestrel вместо #iis





Создание движка представлений
https://metanit.com/sharp/aspnet5/7.10.php




#core


#program

public static void Main(string[] args)
    {
        BuildWebHost(args).Run();
    }
 
    public static IWebHost BuildWebHost(string[] args) =>
        WebHost.CreateDefaultBuilder(args)
            .UseStartup<Startup>()          // установка класса Startup как стартового
            .UseWebRoot("static")   // установка папки static, стандартно тут wwwroot
            .Build();





#startup

#IServiceCollection представляет коллекцию сервисов в приложении
services-список уже подключенных сервисов
public void #ConfigureServices(IServiceCollection services)
{
    //регистрируем сервис, если этого не сделать его нельзя будет использовать в методе Configure()/(при условии что проект не подключает его сам)
services.#AddMvc();//указываем что будем использовать mvc архитектуру
}



#IHostingEnvironment: позволяет взаимодействовать со средой, в которой запускается приложение



#middleware - компоненты приложения, которые могут быть внедрены в конвейер обработки HTTP-запроса, подключаются в Configure
строятся согласно паттерну Singleton - создаются только 1 раз при старте приложения

По умолчанию ASP.NET Core предоставляет следующие встроенные компоненты middleware:
Authentication: предоставляет поддержку аутентификации
CORS: обеспечивает поддержку кроссдоменных запросов
Responce Caching: позволяет кэшировать результаты запросов
Responce Compression: обеспечивает сжатие ответа клиенту
URL Rewriting Middleware: предоставляет функциональность URL Rewriting
Routing: определяет маршруты, используемые в приложении
Session: предоставляет поддержку сессий
Static Files: предоставляет поддержку обработки статических файлов



#ILoggerFactory: предоставляет механизм логгирования в приложении
//параметрами могут быть только добавленные сервисы, можно создать свой подключить его в ConfigureServices и тогда можно будет докинуть его в параметры
public void #Configure(IApplicationBuilder app, IHostingEnvironment env)
{
//метод будет вызываться при каждом запросе, но объект класса создается 1 раз


app.#UseStaticFiles();//разрешаем отдавать static файлы

#map
//метод является конечным(дальше вызываться ничего не будет)
//Теперь обращения к приложению типа http://localhost:xxxx/about будут обрабатываться с помощью метода About
app.Map("/index", Index);//Index-делегат который будет возвращать html
    app.Map("/about", About);

//сложенность, Теперь метод About будет обарабатывать запрос не http://localhost:xxxx/about, а http://localhost:xxxx/home/about
app.Map("/home", home =>
    {
        home.Map("/index", Index);
        home.Map("/about", About);
    });


#MapWhen
//метод является конечным(дальше вызываться ничего не будет)
//принимает в качестве параметра делегат Func<HttpContext, bool> и обрабатывает запрос, если функция, передаваемая в качестве параметра возвращает true.
app.MapWhen(context => {
               
        return context.Request.Query.ContainsKey("id") && 
                context.Request.Query["id"] == "5";
    }, Index);




#use
//метод является НЕ конечным(дальше вызываться будет по очереди)
//что то сделает и затем передает обработку запроса следующим компонентам middleware в конвейере, например app.Run
app.Use(async (context, next) =>
    {
        z = x * y;

//рекомендуется вызывать метод next.Invoke после метода Response.WriteAsync()
        await next.Invoke();//если это убрать то на дальше не будет ничего обрабатываться


//так можно
	x = x * 2;
        await next.Invoke();    // вызов app.Run
        x = x * 2;      // 8 * 2 = 16
        await context.Response.WriteAsync($"Result: {x}");

    });


метод расширения для вызова app.UseToken(); в методе Configure, может быть упразднен, тогда вместо app.UseToken();   => app.UseMiddleware<TokenMiddleware>();
public static class TokenExtensions
{
    public static IApplicationBuilder UseToken(this IApplicationBuilder builder)
    {
        return builder. #UseMiddleware<TokenMiddleware>();//так вызываются самописные Middleware
    }
}

//сам класс который будет обрабатывать запрос 

public class TokenMiddleware
{
    private readonly RequestDelegate _next;//#RequestDelegate делегат который будет выполняться следующим
 
    public TokenMiddleware(RequestDelegate next)
    {
        this._next = next;
    }
 //метод должен называться InvokeAsync или Invoke
    public async Task InvokeAsync(HttpContext context)
    {
await _next.Invoke(context);//моно вызвать следующий по очереди метод, если его не вызвать то он не вызовется сам вообще??? TODO
        var token = context.Request.Query["token"];
        if (token!="12345678")
        {
            context.Response.StatusCode = 403;
            await context.Response.WriteAsync("Token is invalid");
        }
        else
        {
            await _next.Invoke(context);
        }
    }
}








#run
//метод является конечным(дальше вызываться ничего не будет)
//данный метод не передает обработку запроса далее по конвейеру, то его следует помещать в самом конце
//В качестве параметра метод Run принимает делегат RequestDelegate. Этот делегат имеет следующее определение:
//public delegate Task RequestDelegate(HttpContext context);

app.Run(async (context) =>
        {
            await context.Response.WriteAsync($"Result: {1}");
        });
}











#IHostingEnvironment
следует помещать ближе к началу  Configure
#ApplicationName: возвращает имя приложения
#EnvironmentName: возвращает описание среды, в которой хостируется приложение
{
может иметь 1 из 3х значений: #Development, #Staging и #Production
В проекте это свойство задается через установку переменной среды ASPNETCORE_ENVIRONMENT. Ее текущее значение можно посмотреть в свойствах проекта на вкладке Debug
Для определения значения этой переменной для интерфейса IHostingEnvironment определены специальные методы расширения:
#IsDevelopment(): возвращает true, если имя среды - Development
#IsStaging(): возвращает true, если имя среды - Staging
#IsProduction(): возвращает true, если имя среды - Production
Configure() класса Startup-> env.EnvironmentName = EnvironmentName.Production;


Configure() класса Startup-> if (env.IsDevelopment()){app.#UseDeveloperExceptionPage();}  -> если не размещено на хостинге то подробное описание ошибки, если на хостинге то нет

}



#UseExceptionHandler #error
Он перенаправляет при возникновении исключения на некоторый адрес и позволяет обработать исключение
следует помещать ближе к началу  Configure

if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    else
    {
        app.UseExceptionHandler("/error");//перенаправляет при возникновении ошибки на адрес "/error"
    }

//обрабатываем ошибку
app.Map("/error", ap => ap.Run(async context =>
    {
        await context.Response.WriteAsync("DivideByZeroException occured!");
    }));



Обработка #ошибок #ошибка HTTP
стандартно статус ошибки можно увидеть только в консоле, сама страница просто будет белой
if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    // обработка ошибок HTTP, благодаря этой строке будет написан код ошибки на странице
  app.UseStatusCodePages();
//{0} - статус ошибки
//app.UseStatusCodePages("text/plain", "Error. Status code : {0}");

//Но теперь при обращении к несуществующему ресурсу клиент получит статусный код 302 / Found. То есть формально несуществующий ресурс будет существовать, просто статусный код 302 будет указывать, что ресурс перемещен на другое место - по пути "/error/404".
//app.#UseStatusCodePagesWithRedirects("/error/{0}");//Здесь будет идти перенаправление по адресу "/error" ErrorStatus.

//app.#UseStatusCodePagesWithReExecute("/error/{0}");//тоже что и UseStatusCodePagesWithRedirects но браузер получит правильный статус

Настройка обработки ошибок в web.config - также можно но значительные ограничения https://metanit.com/sharp/aspnet5/17.1.php








#получение #объекта #зависимости #injection

#[] #attr #FromServices
если не хотим передавать в конструктор контроллера 

///
при services.AddTransient<ITimeService, SimpleTimeService>();
public class HomeController : Controller
{
    private readonly ITimeService _timeService;
 
    public HomeController(ITimeService timeServ)
    {
        _timeService = timeServ;
    }
}


///ТЕОРИЯ что происходит при передаче через конструктор контроллера
Приложение получает запрос к методу контроллера HomeController
Фреймворк MVC обращается к провайдеру сервисов для создания объекта контроллера HomeController
Провайдер сервисов смотрит на конструктор класса HomeController и видит, что там имеется зависимость от интерфейса ITimeService
Провайдер сервисов среди зарегистрированных зависимостей ищет класс, который представляет реализацию интерфейса ITimeService
Если нужная зависимость найдена, то провайдер сервисов создает объект класса, который реализует интерфейс ITimeService
Затем провайдер сервисов создает объект HomeController, передавая в его конструктор ранее созданную реализацию ITimeService
В конце провайдер сервисов возвращает созданный объект HomeController инфраструктуре MVC, которая использует контроллер для обработки запроса

///

то можно так, сам все создаст и закинет
public IActionResult Index([FromServices] IHostingEnviroment env)
#TODO кажется дубликат
#create #зависимость
var env=HttpContext.RequestServices.GetService<IHostingEnvironment>();



для внедрения в вью
@inject MvcViewsApp.Services.IMessageSender MessageSender
@MessageSender.SendMessage()












#Создание своих #сервисов #сервис #внедрение #зависимостей #service

сервис можно передать параметром или получить так TimeService timeService = context.RequestServices.GetService<TimeService>();


Добавим в проект новую папку Services
public interface IMessageSender
{
    string Send();
}
создать несколько классов реализующих интерфейс
EmailMessageSender, SmsMessageSender

в классах можно определить метод расширения
public static void AddTimeService(this IServiceCollection services)
    {
        services.AddTransient<TimeService>();
    }




#AddTransient #Transient
Такие объекты создаются при каждом обращении к ним(к классу, объекту класса).

#AddScoped #Scoped
Метод AddScoped создает один экземпляр объекта для всего запроса. применяется также как и AddTransient

#AddSingleton #Singleton
AddSingleton создает один объект для всех последующих запросов, при этом объект создается только тогда, когда он непосредственно необходим. применяется также как и AddTransient

//подключаем тот класс который будет использоваться(подразумеваться) с интерфейсом
//устанавливаем зависимость
ConfigureServices->
//если метод расширения(static this) не был определен
services.AddTransient<IMessageSender, EmailMessageSender>();
services.AddTransient<TimeService>();//если зависимость устанавливать не нужно, а нужно просто добавить сервис
//services.AddSingleton<ICounter>(new RandomCounter());//объект можно создать самому

//можно передать делегат который будет отвечать за создание
services.AddTransient<IMessageSender>(provider=> {
    if (DateTime.Now.Hour >= 12) return new EmailMessageSender();
    else return new SmsMessageSender();
});


//если метод расширения(static this) был определен
 services.AddTimeService();


// теперь можем указать IMessageSender как подключенный сервис
Configure(IApplicationBuilder app, IHostingEnvironment env, IMessageSender messageSender)
messageSender.Send();//высовется метод того класс зависимость которого установили

теперь данную зависимость можно использовать:
Через конструктор класса (за исключением конструктора класса Startup) - класс может иметь только 1 конструктор который поддерживает параметр зависимости
{
для такого класса нужно подключить сервис services.AddTransient<MessageService>(); тогда его можно будет также использовать в configure в качестве параметра
и нужно внедрить зависимость которую он получает в качестве параметра
}
Через параметр метода Configure класса Startup
Через параметр метода Invoke компонента middleware
Через свойство RequestServices контекста запроса HttpContext в компонентах middleware // HttpContext.RequestServices
Через свойство ApplicationServices объекта IApplicationBuilder в классе Startup




#console внедрение зависимостей в консольном приложении
using Microsoft.Extensions.DependencyInjection;

public class Program 
{
public static void Main(string[] args)
{
//установка зависимостей DI
var serviceProvider = new ServiceCollection()
.AddSingleton<IFooService, FooService>()
.AddSingleton<IBarService, BarService>()
.BuildServiceProvider();






создание объекта  для зависимости (по например интерфесу создать объект)

#HttpContext. #RequestServices
предоставляет доступ к всем внедренным зависимостям с помощью своих методов

#GetService<service>(): использует провайдер сервисов для создания объекта, который представляет тип service. В случае если в провайдере сервисов для данного сервиса не установлена зависимость, то возвращает значение null
#GetRequiredService<service>(): использует провайдер сервисов для создания объекта, который представляет тип service. В случае если в провайдере сервисов для данного сервиса не установлена зависимость, то генерирует исключение

при внедрении такой зависимости services.AddTransient<IMessageSender, EmailMessageSender>();
можно получить объект IMessageSender messageSender = context.RequestServices.GetService<IMessageSender>();



#ApplicationServices

Configure(IApplicationBuilder app)
IMessageSender messageSender = app.ApplicationServices.GetService<IMessageSender>();


Метод #Invoke компонентов #middleware

когда создаем свой класс для использования с app.Use можем также добавить параметр в метод Invoke
 public async Task Invoke(HttpContext context, IMessageSender messageSender)






#error
#InvalidOperationException: Cannot resolve scoped service 'DIApp.TimeService' from root provider. в ConfigureServices
возможно не правильно указаны способы подключения, допустим зависимость - AddScoped а сервис AddTransient, может получиться что они взаимосвязаны но 1 объект создается позже другого
#InvalidOperationException: Cannot consume scoped service 'DIApp.ITimer' from singleton 'DIApp.TimeService
Но суть будет та же самая - мы не можем по умолчанию передавать в конструктор singleton-объекта scoped-сервис.









#path #путь #root #корень
#ContentRootPath: возвращает путь к корневой папке приложения
#WebRootPath: возвращает путь к папке, в которой хранится статический контент приложения, как правило, это папка wwwroot
#ContentRootFileProvider: возвращает реализацию интерфейса Microsoft.AspNetCore.FileProviders.IFileProvider, которая может использоваться для чтения файлов из папки ContentRootPath
#WebRootFileProvider: возвращает реализацию интерфейса Microsoft.AspNetCore.FileProviders.IFileProvider, которая может использоваться для чтения файлов из папки WebRootPath

IHostingEnvironment appEnvironment
_appEnvironment.ContentRootPath

#Combine #TODO
Path.Combine(str1,str2);



#static #files

необходимо в sturtup->config докинуть
app.#UseStaticFiles();//разрешаем отдавать static файлы

по ссылке http://localhost:55234/index.html можно получить статический файл который расположен
wwwroot->index.html
если находится в wwwroot/html/ то http://localhost:55234/html/index.html
если нужно изменить папку с статик файлами то в program.cs внести изменения
public static void Main(string[] args)
    {
        BuildWebHost(args).Run();
    }
 
    public static IWebHost BuildWebHost(string[] args) =>
        WebHost.CreateDefaultBuilder(args)
            .UseStartup<Startup>()          // установка класса Startup как стартового
            .UseWebRoot("static")   // установка папки static, стандартно тут wwwroot
            .Build();



сопоставление каталогов с путями
 app.UseStaticFiles(); // обрабатывает все запросы к wwwroot

//такая перегрузка позволит по запросу http://localhost:56431/pages/index.html обратиться к файлу wwwroot/html/index.html
    app.UseStaticFiles(new StaticFileOptions() // обрабатывает запросы к каталогу wwwroot/html
    {
        FileProvider = new PhysicalFileProvider(
            Path.Combine(Directory.GetCurrentDirectory(), @"wwwroot\html")),
        RequestPath = new PathString("/pages")
    });






// дописав  app.UseDefaultFiles(); перед app.UseStaticFiles(); , можно определить стандартный статический файл который будет отправляться по запросу http://localhost/
названия у файла должно быть: default.htm default.html index.htm index.html
Если файл будет найден, то он будет отправлен в ответ клиенту. Если же файл не будет найден, то продолжается обычная обработка запроса с помощью следующих компонентов middleware
если надо указать стандатный файл с другим именем то 
в configure докинуть в начало
	DefaultFilesOptions options = new DefaultFilesOptions();
        options.DefaultFileNames.Clear(); // удаляем имена файлов по умолчанию
        options.DefaultFileNames.Add("hello.html"); // добавляем новое имя файла
        app.UseDefaultFiles(options); // установка параметров
app.UseStaticFiles();




app.#UseDirectoryBrowser();
докинув в config и докинув  services.AddDirectoryBrowser(); в ConfigureServices
можно позволить пользователям просмотривать файлы на сервере


 using Microsoft.Extensions.FileProviders.
если использовать такую перегрузку то в таком случае путь типа http://localhost:56431/pages/ будет сопоставляться с каталогом "wwwroot\html".
app.UseDirectoryBrowser(new DirectoryBrowserOptions()
    {
        FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), @"wwwroot\html")),
         
        RequestPath = new PathString("/pages")
    });








app.#UseFileServer();
Метод UseFileServer() объединяет(остальные указывать не надо) функциональность сразу всех трех вышеописанных методов UseStaticFiles, UseDefaultFiles и UseDirectoryBrowser

Если нам надо еще включить просмотр каталогов, то
app.UseFileServer(enableDirectoryBrowsing: true);

В этом случае будет разрешен обзор каталога по пути http://localhost:56431/pages/, но при этом путь http://localhost:56431/html/ работать не будет.
app.UseFileServer(new FileServerOptions
{
    EnableDirectoryBrowsing=true,
    FileProvider = new PhysicalFileProvider(Path.Combine(Directory.GetCurrentDirectory(), @"wwwroot\html")),
    RequestPath = new PathString("/pages"), 
    EnableDefaultFiles=false
});





#owin


в configure
//если #UseOwin что то выводит в поток(результат) то все последующее не будет выведено 
- context.Response.WriteAsync("Hello Work!"); ничего не выведет, повторный запуск owin тоже ничего не выведет
app.UseOwin(pipeline =>
            {
                pipeline(next => SendResponseAsync);
            });


public Task SendResponseAsync(IDictionary<string, object> environment)
        {
//из environment мы можем получать объекты запроса и ответа
            // определяем ответ
            string responseText = "Hello ASP.NET Core";
            // кодируем его в массив байтов
            byte[] responseBytes = Encoding.UTF8.GetBytes(responseText);
 
            // получаем поток ответа
            var responseStream = (Stream)environment["owin.ResponseBody"];
            // отправка ответа
            return responseStream.WriteAsync(responseBytes, 0, responseBytes.Length);
        }



Ключи запроса
owin.#RequestBody : объект Stream, представляющий тело запроса
owin.#RequestHeaders : объект IDictionary<string, string[]>, представляющий заголовки запроса
owin.#RequestMethod : объект string, представляющий метод запроса ("GET", "POST")
owin.#RequestPath : объект string, представляет запрошенный путь относительно корня приложения
owin.#RequestPathBase : объект string, содержащий часть запрошенного пути относительно корня приложения
owin.#RequestProtocol : объект string, хранящий название протокола ("HTTP/1.0", "HTTP/1.1")
owin.#RequestQueryString : объект string, хранящий строку запроса, то есть ту часть URI, которая идет после "?" (например, "foo=bar&mes=hello")
owin.#RequestScheme : объект string, хранящий схему URI запроса ("http", "https")
owin.#RequestId : объект string, представляющий уникальный идентификатор запроса (необязательный параметр)

Ключи ответа
owin.#ResponseBody : объект Stream, представляющий поток ответа
owin.#ResponseHeaders : объект IDictionary<string, string[]>, представляющий заголовки ответа
owin.#ResponseStatusCode : объект int, хранящий статусный код HTTP, который посылается в ответе (необязательный параметр)
owin.#ResponseReasonPhrase : объект string, содержащий словесное пояснение к статусному коду (необязательный параметр)
owin.#ResponseProtocol : объект string, хранящий название протокола ("HTTP/1.0", "HTTP/1.1")







#log #логирование #логгирование

в Configure
loggerFactory.AddConsole(); //указываем что логи будут выводиться на консоль
loggerFactory.AddConsole(LogLevel.Warning);//устанавливаем детализацию

там где нужно что то вывести (например app.Run(async (context))
// создаем объект логгера
                var logger = loggerFactory.CreateLogger("RequestInfoLogger");
                // пишем на консоль информацию
                logger.LogInformation("Processing request {0}", context.Request.Path);

вывод сообщений уровня Debug и Trace по умолчанию отключен


#LogLevel

Trace: используется для вывода наиболее детализированных сообщений. Подобные сообщения могут нести важную информацию о приложении и его строении, поэтому данный уровень лучше использовать при разработке, но никак не при публикации
Debug: для вывода информации, которая может быть полезной в процессе разработки и отладки приложения
Information: уровень сообщений, позволяющий просто отследить поток выполнения приложения
Warning: используется для вывода сообщений о неожиданных событиях, например, ошибках, которые не влияют не останавливают выполнение приложения, но в то же время должны быть иследованы
Error: информация об ошибках, вследствие которых приложение должно быть остановлено
Critical: уровень критических ошибок, которые могут быть связаны с какими-то ситуациями извне - ошибками операционной системы, потерей данных в бд, переполнение памяти диска и т.д.
None: вывод информации в лог не применяется



у #LogInformation есть методы 

#LogDebug()
#LogTrace()
#LogInformation()
#LogWarning()
#LogError()
#LogCritical()


иногда не все логи можно увидеть, и это можно исправить в program.cs

public static IWebHost BuildWebHost(string[] args) =>
            WebHost.CreateDefaultBuilder(args)
                .UseStartup<Startup>()
                .ConfigureLogging(logging => logging.SetMinimumLevel(LogLevel.Trace))//устанавливаем минимальный уровень который надо видеть в логах
            .Build();



для использования логов в контроллере
public class HomeController : Controller
{
private readonly ILogger _logger;

public HomeController(ILogger<homecontroller> logger)
{
_logger = logger;
}

public IActionResult Index()
{
_logger.LogInformation("Test Message");

return View();
}
}



------------
еще вариант в контроллере #TODO сравнить оценить мб оставить только один варик

есть инструкция по проще
public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
{
loggerFactory.AddFile(Configuration["Logging:LogFileName"]);
...
в контроллерах:
[ApiController]
public class BaseController : Controller
{
protected readonly ILogger _logger;

public BaseController(
ILogger<basecontroller> logger
)
{
_logger = logger;
}
}
Использование:
_logger.LogInformation("User logged in.");














--------------------
если не в контроллере а где то еще то

Создаём класс:
using Microsoft.Extensions.Logging;
...

internal static class Log
{
internal static ILoggerFactory LoggerFactory { get; set; }
internal static ILogger CreateLogger<t>() => LoggerFactory.CreateLogger<t>();
internal static ILogger CreateLogger(string categoryName) => LoggerFactory.CreateLogger(categoryName);
}

Затем в Startup.cs добавляем сохранение фабрики:

public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
{
...
Log.LoggerFactory = loggerFactory;
....
}

И в нужном классе, в котором надо вести логгирование:
public class CustomClass
{
private readonly ILogger _logger = Log.CreateLogger<customclass>();

public CustomClass()
{
_logger.LogInformation("test message");
}
}





#TODO сздание провайдера логгирования(вывод логов не на консоль а например в файл)
https://metanit.com/sharp/aspnet5/2.10.php







что то типо глабальной переменной для всех middleware

 (IDictionary<object, object>)HttpContext.Items

После завершения запроса все данные из HttpContext.Items удаляются

app.Use(async (context, next) =>
    {
        context.Items["text"] = "Text from HttpContext.Items";}
//и в другом можем получить




#Куки #cookie 



посылаются на сервер с каждым запросом, размер ограничен 4096 байтами
И также по умолчанию куки имеют настройку CookieHttpOnly=true, поэтому они не доступны для клиентских скриптов из браузера
//так можно только получить
if (context.Request.Cookies.ContainsKey("name"))
    string name = context.Request.Cookies["name"];

//для добавления
context.Response.Cookies.Append("name", "Tom");
//удаление
context.Response.Cookies.Delete("name");

коллекция context.Request.Cookies представляет объект #IRequestCookieCollection



using Microsoft.AspNetCore.Http;


#Сессии #Session  #Memory


Для хранения состояния сессии на сервере создается словарь или хеш-таблица, которая хранится в кэше и которая существует для всех запросов из одного браузера в течение некоторого времени. На клиенте хранится идентификатор сессии в куках. Этот идентификатор посылается на сервер с каждым запросом. Сервер использует этот идентификатор для извлечения нужных данных из сессии. Эти куки удаляются только при завершении сессии. Но если сервер получает куки, которые установлены уже для истекшей сессии, то для этих кук создается новая сессия.
название куки в которой хранится ключ сессии по умолчанию - ".AspNet.Session"
все сессии работают поверх объекта #IDistributedCache


в ConfigureServices

services.AddDistributedMemoryCache();
    services.AddSession();


в Configure
вверху app.UseSession();//если не вызвать метод то при обращении будет исключение InvalidOperationException

//читаем 
if(context.Session.Keys.Contains("name"))
//устанавливаем
context.Session.SetString("name", "Tom");


Объект Session определяет ряд свойств и методов, которые мы можем использовать:
Keys: свойство, представляющее список строк, который хранит все доступные ключи
Clear(): очищает сессию
Get(string key): получает по ключу key значение, которое представляет массив байтов
GetInt32(string key): получает по ключу key значение, которое представляет целочисленное значение
GetString(string key): получает по ключу key значение, которое представляет строку
Set(string key, byte[] value): устанавливает по ключу key значение, которое представляет массив байтов
SetInt32(string key, int value): устанавливает по ключу key значение, которое представляет целочисленное значение value
SetString(string key, string value): устанавливает по ключу key значение, которое представляет строку value
Remove(string key): удаляет значение по ключу



переопределение настроик сессии через объект
#SessionOptions:
#CookieName: имя куки
#IdleTimeout: время действия куки в виде объекта TimeSpan
#CookieDomain: домен, для которого устаналиваются куки
#CookieHttpOnly: доступны ли куки только при передаче через HTTP-запрос
#CookiePath: путь, который используется куками


для изменения надо в ConfigureServices(IServiceCollection services)
services.AddDistributedMemoryCache();
    services.AddSession(options =>
    {
        options.CookieName = ".MyApp.Session";
        options.IdleTimeout = TimeSpan.FromSeconds(3600);
    });



хранить в сессии можно только строку, поэтому надо конвертить(можно так)
#json

//context.Session.Get<Person>("person");
//context.Session.Set<Person>("person", person);

using Microsoft.AspNetCore.Http;
using Newtonsoft.Json;
 
public static class SessionExtensions
{
    public static void Set<T>(this ISession session, string key, T value)
    {
        session.SetString(key, JsonConvert.SerializeObject(value));
    }
 
    public static T Get<T>(this ISession session, string key)
    {
        var value = session.GetString(key);
        return value == null ? default(T) : JsonConvert.DeserializeObject<T>(value);
    }
}
















#https #UseHttpsRedirection
при попытке доступа по http будет редиректить на #https

Configure-> app.UseHttpsRedirection();
можно задать параметры переадресации
ConfigureServices просто докинуть->
services.AddHttpsRedirection(options =>
    {
        options.RedirectStatusCode = StatusCodes.Status307TemporaryRedirect;
        options.HttpsPort = 44369;
    });


#UseHsts #Hsts 
из за того что при первом обращении пользователь всегда обращается по http надо не просто редиректить а делать еще и так
Configure-> 
if (env.IsDevelopment()){}else//кидать в такое условие тк могут быть проблемы при разработке тк все кешируется
app.UseHsts();//до UseHttpsRedirection


монжно настроить параметры ( Strict-Transport-Security )
ConfigureServices ->
services.AddHsts(options =>
    {
        options.Preload = true;//устанавливает параметр preload
        options.IncludeSubDomains = true;//устанавливает параметр includeSubDomains
        options.MaxAge = TimeSpan.FromDays(60);//устанавливает параметр max-age
        options.ExcludedHosts.Add("us.example.com");//добавляет сисок доменов, которые надо исключить из действия заголовка
        options.ExcludedHosts.Add("www.example.com");
    });




Strict-Transport-Security: max-age=63072000; includeSubDomains; preload
Заголовок имеет три параметра:

max-age: задает максимальное действие заголовка (обязательный параметр)
includeSubDomains: если этот параметр установлен, то действие применяется ко всем поддоменам
preload: если этот параметр установлен, то будет использоваться специальный preload-список доменов, обращение к которым безопасно.







#bower.json
файл который управляет клиентскими зависимостями(библиотеки js css), которые подключаются через менеджер пакетов bower




#bundleconfig.json
файл который содержит задачи по минификации используемых скриптов и стилей, которые выполняются при построении проекта







#Dependency #Injection
#внедрение #зависимостей #IServiceProvider аналог #Ninject








#IConfiguration #IConfigurationRoot #конфигурация
хранение конфигурации приложения
в версии 2.0++ не обязательно все явно подключать все может подключиться само:
создать файл appsettings.json - обязательно такое имя // #appsettings.json
в контруктор Startup добавить параметр и хранить его
public Startup(IConfiguration config)
        {
            AppConfiguration = config;
        }
        public IConfiguration AppConfiguration { get; set; }
 var color = AppConfiguration["color"];

если делать таким образом то можно докинуть в #Middleware, и дальше уже юзать в нем
public ConfigMiddleware(RequestDelegate next, IConfiguration config)
        {
            _next = next;
            AppConfiguration = config;
        }
        public IConfiguration AppConfiguration { get; set; }

то что выше(передача параметром через фабрику) можно сделать и без файла appsettings.json, если докинуть
ConfigureServices-> services.AddTransient<IConfiguration>(provider => AppConfiguration);//AppConfiguration - название свойства, описано ниже



Microsoft.Extensions.Configuration
Кроме того настройки конфигурации также могут храниться во внешнем файле - json, ini, xml, и в этом случае нам может потребоваться добавить один из пакетов, который позволяет работать с определенным источников конфигурации. В частности, нам доступно несколько источников конфигурации, которые представлены следующими пакетами:
Microsoft.Extensions.Configuration (предоставляет базовую функциональность для конфигурации, а также позволяет задавать параметры конфигурации в памяти)
Microsoft.Extensions.Configuration.Json (позволяет использовать в качестве источников конфигурации файлы json)
Microsoft.Extensions.Configuration.CommandLine (позволяет считывать параметры конфигурации из командной строки с помощью метода AddCommandLine())
Microsoft.Extensions.Configuration.EnvironmentVariables (позволяет получать параметры конфигурации из переменных окружения)
Microsoft.Extensions.Configuration.Ini (использует в качестве источника конфигурации файлы ini)
Microsoft.Extensions.Configuration.Xml (использует в качестве источника конфигурации файлы xml)

#ConfigurationBuilder #IConfiguration




IConfiguration определяет следующие методы:
#GetSection(name): возвращает объект IConfiguration, который представляет только определенную секцию name
#GetChildren(): возвращает все подсекции текущего объекта конфигурации в виде набора объектов IConfiguration
#GetReloadToken(): возвращает токен - объект IChangeToken, который используется для уведомления при изменении конфигурации
#GetConnectionString(name): эквивалентен вызову GetSection("ConnectionStrings")[name] и предназначается непосредственно для работы со строками подключения к различным базам даных
string con = AppConfiguration.GetConnectionString("DefaultConnection");

[key]: индексатор, который позволяет получить по определенному ключу key хранящееся значение






public Startup()
        {
            // строитель конфигурации, необходимо указать место хранения(можно скопировать ниже) 
var builder =...
            
            // создаем конфигурацию./ этот элемент попадает в конфигурацию приложения
            AppConfiguration = builder.Build();
 
        }
        // свойство, которое будет хранить конфигурацию
        public IConfiguration AppConfiguration { get; set; }

//получаем - await context.Response.WriteAsync(AppConfiguration["firstname"]);
//устанавливаем - AppConfiguration["firstname"] = "alice";


#AddInMemoryCollection -хранение в памяти

var builder = new ConfigurationBuilder()
                .AddInMemoryCollection(//указываем место хранения
new Dictionary<string, string>
                {
                    {"firstname", //ключ настройки 
			"Tom"},   // значение
                    {"age", "31"}
                });

#AddJsonFile (class JsonConfigurationExtensions) #json
создать объект json и закинуть туда данные ( {"color": "red"} ), в файле должны быть уникальные ключи
И если во втором файле есть настройки, которые имеют тот же ключ, что и настройки первого файла, то происходит переопределение настроек: настройки из второго файла заменяют настройки первого.


var builder = new ConfigurationBuilder()
                .SetBasePath(env.ContentRootPath)
                .AddJsonFile("conf.json").AddJsonFile("myconfig.json");//можно указать несколько файлов, можно только 1

можно хранить сложные объекты
{
  "color": "red",
  "namespace": { "class": { "method": "AddJson" } }
}
string text = AppConfiguration["namespace:class:method"];
string text = AppConfiguration. #GetSection("namespace").GetSection("class")... .Value;
string text = AppConfiguration. #GetSection("namespace:class:method")... .Value;

#AddXmlFile #xml

добавить новый xml файл
<configuration>
  <color>blue</color>
  <text>Hello ASP.NET</text>
</configuration>

var builder = new ConfigurationBuilder()
                .SetBasePath(env.ContentRootPath);
            builder.AddXmlFile("config.xml");



#AddIniFile #ini
 добавим в проект текстовый файл и переименуем его в conf.ini
color="blue"
text="Hello ASP.NET Core 2.0"
var builder = new ConfigurationBuilder()
                .SetBasePath(env.ContentRootPath)
                .AddIniFile("conf.ini");



#AddEnvironmentVariables
 можно добавить все переменные среды окружения, которые имеются на рабочей машине
AppConfiguration = new ConfigurationBuilder()
        .AddEnvironmentVariables()
        .Build();

string java_dir = AppConfiguration["JAVA_HOME"] ?? "not set";



Объединение источников конфигурации

var builder = new ConfigurationBuilder()
            .SetBasePath(env.ContentRootPath);
        builder.AddJsonFile("conf.json");
        builder.AddEnvironmentVariables();



создание собственного провайдера источника конфигурации #TODO
https://metanit.com/sharp/aspnet5/2.15.php







#IOptions #TOptions
#TODO вообще не понял суть https://metanit.com/sharp/aspnet5/6.3.php



допустим в файле конфигурации appsettings.json сохранен объект класса Person

создаем обычный PersonMiddleware
в конструктор добавляем (, IOptions<Person> options){
Person = options.Value;
}
 public Person Person { get; }
в таком случае в Invoke можем обращаться к объекту person который сохранен в json а в конструктор будет передан автоматически, но надо докинуть то что ниже

public IConfiguration AppConfiguration { get; set; }
ConfigureServices->{
// Настройка параметров и DI, добавляем возможность внедрения зависимостей
            services.AddOptions();
 
            // создание объекта Person по ключам из конфигурации
            services.Configure<Person>(AppConfiguration);

//необязательная часть ConfigureServices

// переопределяем настройки(свойства класса person), имзенятся ли они в файле не понятно #TODO
services.Configure<Person>(opt =>
    {
        opt.Age = 22;
    });

//передача отдельных секций конфигураций(определена в файле appsettings.json)
services.Configure<Company>(AppConfiguration.GetSection("company"));

}
Configure->{
app.UseMiddleware<PersonMiddleware>();
}













#db 
#DefaultConnection #Configuration #GetConnectionString #connection #AddDbContext #context
в ConfigureServices (services)->{
string connection=Configuration.GetConnectionString("DefaultConnection");
//добавление #контекста
services.AddDbContext<MobileContext>(option=>option.UseSqlServer(connection))
}

controller->
MobileContext db;
в контроллер конструктор
public HomeController(MobileContext context){
db=context;
}










#Request #Query
получение переданных параметров get
string altitudeString = Request.Query.FirstOrDefault(p => p.Key == "altitude").Value;


#Form #IFormsCollection
получение переданных параметров post
 string altitudeString = Request.Form.FirstOrDefault(p => p.Key == "altitude").Value;





#attr

#route #HttpGet #get #post
[HttpGet("api/index")]
Index()
[HttpGet("api/index/{id}")]
Index(string id)

[HttpGet]
Index(string id)

#HttpPost #HttpPut #HttpDelete #HttpHead , если не указать явно то будет HttpGet



get
http://localhost:57086/Home/Sum?nums=1&nums=2&nums=3 // передать массив из 3х элементов
Home/Square?a=10&h=3// 2 параметра с разными именами
http://localhost:57086/Home/Square?altitude=10&height=3// передача сложных объектов (указываются атрибуты объекта)

[Route("Home")]
HomeController{}


#ActionName
//localhost:xxxx/Home/Welcome вместо localhost:xxxx/Home/Hellow
[ActionName("Welcome")]
public string Hello()


#NonController
//не сможет обрабатывать запрос и использоваться как контроллер
[NonController]
public class HomeController : Controller

#NonAction
метод пересанет быть доступным как действие контроллера
[NonAction]
public string Hello()








#маршрутизация #routing
#RouterMiddleware
При этом надо учитывать, что RouterMiddleware не передает выполнение запроса дальше, если хотя бы один из определенных маршрутов совпал со строкой запроса.
#AddRouting
ConfigureServices->
services.AddRouting();


#RouteHandler #RouteBuilder 

Configure->
 // определяем обработчик маршрута
            var myRouteHandler = new RouteHandler(Handle);
            // создаем маршрут, используя обработчик
            var routeBuilder = new RouteBuilder(app, myRouteHandler);

//ТУТ надо применить MapRoute


            // строим маршрут, подключает RouterMiddleware в конвейер обработки запроса
            app.UseRouter(routeBuilder.Build());

#MapRoute
MapRoute(string template, RequestDelegate handler): устанавливает маршрут с шаблоном template, который будет обрабатываться делегатом handler
MapRoute(string name, string template): устанавливает маршрут с именем name и шаблоном template
MapRoute(string template, Action<ApplicationBuilder> action): устанавливает маршрут с шаблоном template, для которого будет выполняться действие action
MapRoute(string name, string template, object defaults): добавляет значения по умолчанию в виде объекта defaults
MapRoute(string name, string template, object defaults, object constraints): добавляет ограничения к маршруту в виде объекта constraints
MapRoute(string name, string template, object defaults, object constraints, object dataTokens): добавляет токены в виде объекта dataTokens




//все MapRoute пишутся только для Handle который будет обработчиком запроса

            // само определение маршрута - он должен соответствовать запросу {controller}/{action}
            routeBuilder.MapRoute("default", "{controller}/{action}");

	//id - необязательный параметр
routeBuilder.MapRoute("default", "{controller}/{action?}/{id?}");

	//устанавливаются значения по умолчанию
routeBuilder.MapRoute("default", "{controller}/{action}/{id?}", new { controller = "home", action = "index" });
routeBuilder.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");

//любое количество параметров
routeBuilder.MapRoute("default", "{controller=Home}/{action=Index}/{id?}/{*catchall}");

//указываем константы
routeBuilder.MapRoute("default", "WH/Ru{controller=Home}/{action=Index}-en/{id?}");

//несколько параметров в сегменте-- http://localhost:56130/Store/Order/lumia-2015
routeBuilder.MapRoute("default", "{controller=Home}/{action=Index}/{name}-{year}");


//сразу указываем делегат который будет выполняться
routeBuilder.MapRoute("{controller}/{action}",
                async context => {
                    context.Response.ContentType = "text/html; charset=utf-8";
                    await context.Response.WriteAsync("двухсегментный запрос");
                });

















аналоги MapRoute но для других типов запросов
#MapGet
routeBuilder.MapGet("{controller}/{action}", async (context) =>
{
    await context.Response.WriteAsync("Hello From MapGet!");
});
#MapDelete
см MapGet
#MapPost
см MapGet
#MapPut
см MapGet
#MapVerb
 метод MapVerb() добавляет в качестве первого параметра название типа запроса http, например, "GET" или "POST":
MapVerb(string verb, string template, RequestDelegate handler)
MapVerb(string verb, string template, Action<ApplicationBuilder> action)



#GetRouteData #GetRouteData #RouteData
рядом с configure можно так

private async Task Handle(HttpContext context)
        {
            var routeValues = context.GetRouteData().Values;
            var action = routeValues["action"].ToString();
            var name = routeValues["name"].ToString();
            var year = routeValues["year"].ToString();
            await context.Response.WriteAsync($"action: {action} | name: {name} | year:{year}");
        }











#ограничения

применяется класс #RegexRouteConstraint 

routeBuilder.MapRoute("default", 
        "{controller}/{action}/{id?}", 
        new { action = "Index" },  // параметры по умолчанию
        new { controller = "^H" } // ограничения регулярки
);


routeBuilder.MapRoute("default", 
        "{controller}/{action}/{id?}", 
        null,
        new { controller = new RegexRouteConstraint("^H"), id = new RegexRouteConstraint(@"\d{2}") }
);



#AlphaRouteConstraint: параметр должен состоять только из алфавитных символов английского алфавита

new {controller=new AlphaRouteConstraint()}

#BoolRouteConstraint: параметр должен иметь значение true или false
new {id=new BoolRouteConstraint()}

#DateTimeRouteConstraint: параметр должен предоставлять объект DateTime
new {id=new DateTimeRouteConstraint()}

#DecimalRouteConstraint: параметр должен предоставлять объект decimal
new {id=new DecimalRouteConstraint()}

#DoubleRouteConstraint: параметр должен предоставлять объект double
new {id=new DoubleRouteConstraint()}

#FloatRouteConstraint: параметр должен предоставлять объект float
new {id=new FloatRouteConstraint()}

#GuidRouteConstraint: параметр должен предоставлять объект Guid
new {id=new GuidRouteConstraint()}

#HttpMethodRouteConstraint: запрос должен представлять определенный тип - Get, Post и т.д.


routeBuilder.MapRoute("default",
     "{controller}/{action}/{id?}",
     null,
     new { httpMethod = new HttpMethodRouteConstraint("POST") }
);
В конструктор HttpMethodRouteConstraint передаются названия допустимых типов запросв. В данном случае маршрут будет обрабатываться только для POST-запросов.

#IntRouteConstraint: параметр должен предоставлять объект int
new {id=new IntRouteConstraint()}

#LengthRouteConstraint: строка, представляющая параметр, должна иметь определенную длину
new
{
    controller = new LengthRouteConstraint(4), // точная длина
    action = new LengthRouteConstraint(3,10) // минимальная и максимальная длина
}

#LongRouteConstraint: параметр должен предоставлять объект long
new {id=new LongRouteConstraint()}

#MaxLengthRouteConstraint / #MinLengthRouteConstraint: определяют максимальную и минимальную длину параметра в символах
new
{
    controller = new MaxLengthRouteConstraint(5),
    action = new MinLengthRouteConstraint(3)
}

#MaxRouteConstraint / MinRouteConstraint: определяют максимальное и минимальное числовое значение для параметра
new {id=new MinRouteConstraint(4)} // минимальное значение - 4

#RangeRouteConstraint: параметр должен предоставлять числовое значение int в определенном диапазоне
new {id=new RangeRouteConstraint(3, 100)} // диапазон от 3 до 100

#RegexRouteConstraint: задает регулярное значение, которому должен соответствовать параметр

#OptionalRouteConstraint: определяет ограничение для необязательного параметра. И если параметр имется в запросе, то вступает в силу внутреннее ограничение, задаваемое через свойство InnerConstraint класса OptionalRouteConstraint

#RequiredRouteConstraint: указывает, что параметр должен обязательно иметь какое-нибудь значение




составные ограничения
#CompositeRouteConstraint 


routeBuilder.MapRoute(
    name: "default",
    template: "{controller}/{action}/{id?}",
    defaults: new { controller="Home", action = "Index" },
    constraints: new
    {
        action =  new CompositeRouteConstraint(new IRouteConstraint[] 
        {
            new AlphaRouteConstraint(),
            new MinLengthRouteConstraint(6)
        })
});



Строчный синтаксис ограничений

routeBuilder.MapRoute("default", "{controller:regex(^H.*)}/{action}/{id?}");
routeBuilder.MapRoute("default", "{controller:length(4)}/{action:alpha}/{id:range(4,100)}");

если нужно составное ограничение то через :
routeBuilder.MapRoute(
    name: "default",
    template: "{controller}/{action:alpha:minlength(6)}/{id?}",
    defaults: new { controller="Home", action = "Index" });



int Соответствие числу
{id:int}

bool Соответствие значению true или false
{active:bool}

datetime Соответствие дате и времени
{date:datetime}

decimal Соответствие значению decimal
{price:decimal}

double Соответствие значению типа double 
{weight:double}

float Соответствие значению типа float 
{height:float}

guid Соответствие значению типа Guid
{id:guid}

long Соответствие значению типа long
{id:long}

minlength(value) Строка должна иметь символов не меньше value
{name:minlength(3)}

maxlength(value) Строка должна иметь символов не больше value 
{name:maxlength(20)}

length(value) Строка должна иметь ровно столько символов, сколько определено в параметре value
{name:length(10)}

length(min, max) Строка должна иметь символов не меньше min и не больше max
{name:length(3, 20)}

min(value) Число должно быть не меньше value
{age:min(3)}

max(value) Число должно быть не больше value
{age:max(20)}

range(min, max) Число должно быть не меньше min и не больше max
{age:range(18, 99)}

alpha Строка должна состоять из одно и более алфавитных символов
{name:alpha}

regex(expression) Строка должна соответствовать регулярному выражению expression
{phone:regex(^\d{{3}}-\d{{3}}-\d{{4}}$)}

required Параметр является обязательным, и его значение должно быть определено
{name:required}





#IRouteConstraint 
создание своих ограничений

public interface IRouteConstraint
{
    bool Match(HttpContext httpContext,
            IRouter route,
            string routeKey,
            IDictionary<string, object> values,
            RouteDirection routeDirection);
}

public class CustomConstraint : IRouteConstraint
{
    private string uri;
    public CustomConstraint(string uri)
    {
        this.uri = uri;
    }
 
    public bool Match(HttpContext httpContext, IRouter route, string routeKey, 
            RouteValueDictionary values, RouteDirection routeDirection)
    {
        return !(uri == httpContext.Request.Path);


string[] positions = new[] { "admin", "director", "accountant" };
//Теперь для соответствия маршруту параметр id должен иметь одно из следующих значений: "admin", "director" или "accountant", при id = new CustomConstraint()
//values-содержит набор значений маршрута
 return positions.Contains(values[routeKey]?.//получаем параметр маршрута, для которого действует ограничение
ToString().ToLowerInvariant());
    }
}

//применение собственного ограничения
routeBuilder.MapRoute("default", 
    "{controller}/{action}/{id?}",
    null,//по умолчанию
    new { myConstraint = new CustomConstraint("/Home/Index/12") }//для граничения того что включено в "{controller}" new { id = new CustomConstraint() });
);





Создание inline-ограничений

ConfigureServices->
//устанавливают сопоставление ограничения "position" с классом PositionConstraint
services.Configure<RouteOptions>(options => 
                options.ConstraintMap.Add("position", typeof(PositionConstraint)));
            services.AddRouting();


Configure->
//все как при обычном ограничении, но меняем
routeBuilder.MapRoute(
                "default", 
                "{controller}/{action}/{id:position?}");






Создание своего маршрута
#IRouter

public interface IRouter 
{
    Task #RouteAsync(RouteContext context);//предназначен для обработки входящих запросов
    VirtualPathData #GetVirtualPath(VirtualPathContext context);//применяется для генерации ссылок в соответствии с данным маршрутом
}


public class AdminRoute : IRouter
    {
        public VirtualPathData GetVirtualPath(VirtualPathContext context)
        {
            throw new NotImplementedException();
        }
 
        public Task RouteAsync(RouteContext context)
        {
            string url = context.HttpContext.Request.Path.Value.TrimEnd('/');
            if (url.StartsWith("/Admin", StringComparison.OrdinalIgnoreCase))
            {
//блокируем дальнейшее выполнение (НЕ будет передаваться дальше по списку маршрутов и компонентов middleware), установив делегат для выполнения
                context.Handler = async ctx =>
                {
                    ctx.Response.ContentType = "text/html;charset=utf-8";
                    await ctx.Response.WriteAsync("Привет admin!");
                };
            }
            return Task.CompletedTask;
        }
    }



применение
configure->
var routeBuilder = new RouteBuilder(app);
 
            routeBuilder.Routes.Add(new AdminRoute());
 
            routeBuilder.MapRoute("{controller}/{action}",
                async context => {
                    context.Response.ContentType = "text/html;charset=utf-8";
                    await context.Response.WriteAsync("двухсегментный запрос");
                });
 
            app.UseRouter(routeBuilder.Build());


















#tag #razor #html #helper

Если необходимо вывести значение переменной без каких-либо html-элементов, то мы можем использовать специальный снипет <text>:
<text>@i</text>
//вывод строки в конструкции
@if (isEnabled)
{
    @: Добро пожаловать
}


#functions
создание функции в представлении
@functions
{
    public int GetFactorial(int n)
    {
        int result = 1;
        for (int i = 1; i <= n; i++)
            result *= i;
        return result;
    }
}
<div>Факториал числа 6 равен: @GetFactorial(6)</div>









#AnchorTagHelper
actionlink->
<a asp-controller="Home" asp-action="Contacts" asp-route-id="5" asp-route-data='new Dictionary<string,string>(){{"id","5"}}'>контакты</a>

asp-host - указывает на домен сайта
asp-protocol - определяет http or https
asp-all-route-data - устанавливает набор значений для параметров
asp-fragment - определяет ту часть хэш ссылки которая идет после символа #


#labelTagHelper #InputTagHelper #TextAreaTagHelper
<form asp-action="Create" asp-anti-forgery="true">
<label asp-for="Name"></label>
<input type="text" asp-for="Name"></input>

<select asp-for"vl" asp-items="ViewBag.Companies">
<option selected="selected"> базовое значение</option>
</select>

<form>


asp-
controller
action
area - указывает название области в которой будет вызываться контроллер для обработки формы
anti-forgery - если имеет значение true то для этой формы будет генерироваться  antiforgery token
route - название маршрута
all-route-data устанавливает набор значений для параметров
route-[название параметра] определяет значение для определенного параметра
for указывает для какого свойства модели создается элемент
format устанавивает формат ввода для элемента например для input label ="{0:dd-MM-yyy}"



#validate
#data-#valmsg #TODO хз что это
<span data-valmsg-for="Name" data-valmsg-replace="true">...

asp-#validation-#summary

<div asp-validation-summary="ModelOnly">...
{
None - ошибки валидации не отображаются
ModelOnly - отображается только шибка валидации уровня модели, ошибки для отдельных свойств не отображаются
All - отображает все ошибки
}




#ScriptTagHelper #js #script
<script asp-src-include="~/js/**/*.js" asp-scr-exclude="~/js/util/**/*.js"></script>


#LinkTagHelper  #css #link

<link asp-href-include="~/css/**/*.css"/>

? - любой символ кроме слеша
* - любое количество сомволов кроме слеша
** - любое количество символов включая слеш

для таких подключаемых блоков

asp-append-version если имеет значение true то к пути к файлу скрипта добавляется номер версии
asp-fallback-(scr|href) - указывает вспомогательный путь к скрипту, который используется если загрузка скрипта указанного в утрибудет src пройдет неудачно
asp-fallback-text - определяет выражение, которое тестирует загрузку основного скрипта из атрибута src (для link доступны -class -property -value)
asp-(src|href)-include - определяет шаблон подключаемых файлов через запятую можно задать несколько шаблонов

asp-(src|href)-exclude - определяет через запятую набор шаблонов для тех файлов которые следует исключить из загрузки
asp-fallback-(src|href)-include - определяет через запятую набо шаблонов файлов которые подключаются в том случае если загрузка основного скрипта из атрибута src прошла неудачно
asp-fallback-(src|href)-exclude - определяет через запятую набо шаблонов файлов которые следует исключить из загрузки в том случае если загрузка основного скрипта из атрибута scr прошла неудачно














#mvc
ConfigureServices->
services.AddMvc();


Configure->
app.UseMvc(routes =>
        {
            routes.MapRoute(
                name: "default",
                template: "{controller=Home}/{action=Index}/{id?}");
        });



папка Controllers

public class HomeController : Controller
    {
        public IActionResult Index()
        {
            return View();
        }
    }


папка Views-> папка Home ->Razor View







#db  #context #ef #entity #framework


public class MobileContext : DbContext
    {
        public DbSet<Phone> Phones { get; set; }
        public DbSet<Order> Orders { get; set; }
 
        public MobileContext(DbContextOptions<MobileContext> options)
            : base(options)
        {
            Database.EnsureCreated();//создаст БД если ее нет
        }
    }


в appsettings.json->
добавить в внешние скобки "ConnectionStrings": 
{
"ConnectionStrings": {
    "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=mobilestoredb;Trusted_Connection=True;MultipleActiveResultSets=true"
  },
.....
}


Startup.cs. В нем нам надо изменить метод ConfigureServices()
public void ConfigureServices(IServiceCollection services)
        {
            string connection = Configuration.GetConnectionString("DefaultConnection");
            services.AddDbContext<MobileContext>(options => options.UseSqlServer(connection));
            services.AddMvc();
        }




#initial #инициализация #seed #Initialize

//просто класс
public static class SampleData
    {
        public static void Initialize(MobileContext context)
        {
//db.entr.Add();
            context.entr.Add();
        }
    }



Program->Main

//CreateWebHostBuilder(args).Build().Run();
            var host = CreateWebHostBuilder(args).Build();
 
            using (var scope = host.Services.CreateScope())
            {
                var services = scope.ServiceProvider;
                try
                {
                    var context = services.GetRequiredService<MobileContext>();
                    SampleData.Initialize(context);
                }
                catch (Exception ex)
                {
                    var logger = services.GetRequiredService<ILogger<Program>>();
                    logger.LogError(ex, "An error occurred while seeding the database.");
                }
            }
 
            host.Run();







#пути
#css
из папки wwwroot/lib/bootstrap/dist/css/
<link rel="stylesheet" href="~/lib/bootstrap/dist/css/bootstrap.css" />
#a <a href="~/Home/Index" class="navbar-brand">Главная</a>






#_Layout #Layout
#_ViewStart #ViewStart
_ViewStart.cshtml - установка мастер страницы по умолчанию/ устанавливает общую мастер-страницу

_Layout.cshtml - мастер страница по умолчанию
если мастер страницу не нужно использовать в представлении то вверху страницы
@{
    Layout = null;
}
//явно указваем
@{
    Layout = "~/Views/_Layout.cshtml";
}


для создания файла мастре страницы надо создать файл с типом "MVC View Layout Page"

#RenderBody
рендерит тело представления


#RenderSection

<footer>@RenderSection("Footer")</footer>
//если не определено то не отрисует
<footer>@RenderSection("Footer", false)</footer> 


в представление которой будет использовать мастер страницу добавить секцию 

@section Footer {
    Все права защищены. Site Corp. 2016.
}

#IsSectionDefined
@if (IsSectionDefined("Footer"))
    {
        @RenderSection("Footer")
    }
    else
    {
        <span>Содержание элемента footer по умолчанию.</span>
    }








#_ValidationScripsPartial #ValidationScripsPartial
частичное представление, которое подключает скрипты валидации формы

#Error
использутся для отображения ошибок



#_ViewImports #ViewImports
тип файла "MVC View Imports Page"
устанавливает некоторые общие для всех представлений пространства имен

если добавить такую строку, то юзинг будет применен для всех представлений
@using MvcViewsApp.Models


если необходимо добавить using только для определенных представлений то
создать папку в папке Views например Other , добавить туда _ViewImports.cshtml
теперь все директивы и выражения из файла Views/Other/_ViewImports.cshtml будут применяться к представлениям только из папки Views/Other. Кроме того, ко всем представлениям во всех папках продолжит применяться глобальный файл Views/_ViewImports.cshtml








#ActionResult #IActionResult #result



создание
добавим в проект папку Util

public class HtmlResult : IActionResult
    {
        string htmlCode;
        public HtmlResult(string html)
        {
            htmlCode = html;
        }
        public async Task ExecuteResultAsync(ActionContext context)
        {
            string fullHtmlCode = "<!DOCTYPE html><html><head>";
            fullHtmlCode += "<title>Главная страница</title>";
            fullHtmlCode += "<meta charset=utf-8 />";
            fullHtmlCode += "</head> <body>";
            fullHtmlCode += htmlCode;
            fullHtmlCode += "</body></html>";
            await context.HttpContext.Response.WriteAsync(fullHtmlCode);
        }
    }





public HtmlResult GetHtml()
    {
        return new HtmlResult("<h2>Привет ASP.NET Core</h2>");
    }





#ContentResult: пишет указанный контент напрямую в ответ в виде строки
return Content($"Площадь треугольника с основанием {altitude} и высотой {height} равна {square}");

#EmptyResult: отправляет пустой ответ в виде статусного кода 200
public IActionResult GetVoid()
{
    return new EmptyResult();
}
Аналогичен следующему методу:
public void GetVoid()
{
}
#NoContentResult: во многом похож на EmptyResult, также отправляет пустой ответ, только в виде статусного кода 204
public IActionResult GetVoid()
{
    return new NoContentResult();
}
#FileResult: является базовым классом для всех объектов, которые пишут набор байтов в выходной поток. Предназначен для отправки файлов
#FileContentResult: класс, производный от FileResult, пишет в ответ массив байтов
#VirtualFileResult: также производный от FileResult класс, пишет в ответ файл, находящийся по заданному пути
#PhysicalFileResult: также производный от FileResult класс, пишет в ответ файл, находящийся по заданному пути. Только в отличие от предыдущего класса использует физический путь, а не виртуальный.
#FileStreamResult: класс, производный от FileResult, пишет бинарный поток в выходной ответ
#StatusCodeResult: результат действия, который возвращает клиенту определенный статусный код HTTP
#UnauthorizedResult: класс, производный от StatusCodeResult. Возвращает клиенту ответ в виде статусного кода HTTP 401, указывая, что пользователь не прошел авторизацию и не имеет прав доступа к запрошенному ресурсу.
#NotFoundResult: производный от StatusCodeResult. Возвращает клиенту ответ в виде статусного кода HTTP 404, указывая, что запрошенный ресурс не найден
#NotFoundObjectResult: производный от ObjectResult. Также возвращает клиенту ответ в виде статусного кода HTTP 404 с дополнительной информацией
#BadRequestResult: производный от StatusCodeResult. Возвращает статусный код 400, тем самым указывая, что запрос некорректен
#BadRequestObjectResult: производный от ObjectResult. Возвращает статусный код 400 с некоторой дополнительной информацией
#OkResult: производный от StatusCodeResult. Возвращает статусный код 200, который уведомляет об успешном выполнении запроса
#OkObjectResult: производный от ObjectResult. Возвращает статусный код 200 с некоторой дополнительной информацией
#CreatedResult: возвращает статусный код 201, который уведомляет о создании нового ресурса. В качестве параметра принимает адрес нового ресурса
#CreatedAtActionResult: возвращает статусный код 201, который уведомляет о создании нового ресурса. В качестве параметра принимает название метода и контроллера, а также параметров запроса, которые вместе создают адрес нового ресурса
#CreatedAtRouteResult: возвращает статусный код 201, который уведомляет о создании нового ресурса. В качестве параметра принимает название маршрута, который используется для создания адреса нового ресурса
#ChallengeResult: используется для проверки аутентификации пользователя
#JsonResult: возвращает в качестве ответа объект или набор объектов в формате JSON
return Json(user);

#PartialViewResult: производит рендеринг частичного представления в выходной поток
#RedirectResult: перенаправляет пользователя по другому адресу URL, возвращая статусный код 302 для временной переадресации или код 301 для постоянной переадресации зависимости от того, установлен ли флаг Permanent.
#RedirectToRouteResult: класс работает подобно RedirectResult, но перенаправляет пользователя по определенному адресу URL, указанному через параметры маршрута
#RedirectToActionResult: выполняет переадресацию на определенный метод контроллера
#LocalRedirectResult: перенаправляет пользователя по определенному адресу URL в рамках веб-приложения
#ViewComponentResult: возвращает в ответ сущность ViewComponent
#ViewResult: производит рендеринг представления и отправляет результаты рендеринга в виде html-страницы клиенту











#RedirectResult, #LocalRedirectResult, #RedirectToActionResult 

//временная
return Redirect("~/Home/About");
return Redirect("http://microsoft.com")

#RedirectPermanent
//постоянная

Для обращения к локальным адресам в нашей системе мы можем использовать класс #LocalRedirectResult. Для создания временной переадресации применяется метод #LocalRedirect(), а для создания постоянной переадресации - метод #LocalRedirectPermanent
return LocalRedirect("http://microsoft.com");// исключение




#RedirectToRouteResult. Для переадресации он использует маршруты. Для создания объекта этого класса имеются два метода: #RedirectToRoute и #RedirectToRoutePermanent (соответственно для временной и постоянной переадресации).

return RedirectToRoute("default", new { controller = "Home", action = "Square", height = 2, altitude = 20});
при routes.MapRoute(
        name: "default",






отправка #статуса #кода #StatusCode 
#404 #200 #500
#StatusCodeResult

 return StatusCode(401);
 Response.StatusCode = 404;

#HttpNotFoundResult #HttpNotFoundObjectResult #NotFound
посылает код 404, уведомляя браузер о том, что ресурс не найден. Второй класс в дополнении к статусному коду позволяет отправить доплнительную информацию, которая потом отобразится в браузере.
return NotFound("Ресурс в приложении не найден");



#UnauthorizedResult
//вернет 401-не авторизован
return Unauthorized();


#BadResult и #BadObjectResult
//400 - запросс не корректный
return BadRequest("Не указаны параметры запроса");


#OkResult и #OkObjectResult
// 200, уведомляя об успешном выполнении запроса
return Ok("Запрос успешно выполнен");




















#FileResult #PhysicalFileResult #PhysicalFile

#FileContentResult: отправляет клиенту массив байтов, считанный из файла

#VirtualFileResult: представляет простую отправку файла напрямую с сервера по виртуальному пути

#FileStreamResult: создает поток - объект System.IO.Stream, с помощью которого считывает и отправляет файл клиенту

#PhysicalFileResult: также отправляет файл с сервера, но для отправки используется реальный физический путь


"application/octet-stream" -- универсальный тип файлов, если не можем определить правильный
"application/mp4";

#file 
public IActionResult GetFile()
        {
            // Путь к файлу
            string file_path = Path.Combine(_appEnvironment.ContentRootPath, "Files/book.pdf");//см path
            // Тип файла - content-type
            string file_type = "application/pdf";
            // Имя файла - необязательно
            string file_name = "book.pdf";
            return PhysicalFile(file_path, file_type, file_name);
        }

#byte


// Отправка массива байтов
string path = Path.Combine(_appEnvironment.ContentRootPath, "Files/book.pdf");
    byte[] mas = System.IO.File.ReadAllBytes(path);
    string file_type = "application/pdf";
    string file_name = "book2.pdf";
    return File(mas, file_type, file_name);



// Отправка потока
public FileResult GetStream()
{
    string path = Path.Combine(_appEnvironment.ContentRootPath, "Files/book.pdf");
    FileStream fs = new FileStream(path, FileMode.Open);
    string file_type = "application/pdf";
    string file_name = "book3.pdf";
    return File(fs, file_type, file_name);
}




VirtualFileResult работает похожим образом, только возвращает файл по виртуальному пути. Здесь надо учитывать, что по умолчанию все пути к файлам в данном случае будут сопоставляться с папкой wwwroot. То есть нам надо помещать папки с файлами или отдельные файлы в каталог wwwroot:
В данном случае предполагается, что файл "hello.txt" располагается в папке "wwwroot/Files/".
public VirtualFileResult GetVirtualFile()
{
    var filepath = Path.Combine("~/Files", "hello.txt");
    return File(filepath, "text/plain", "hello.txt");
}















#controller

public class HelloBaseController : Controller{}



все метод с атрибутом [NonAction] и являются альтернативой фильтрам действий
Метод #OnActionExecuting() выполняется при вызове метода контроллера до его непосредственного выполнения.

Метод #OnActionExecuted() выполняется после выполнения метода контроллера.

Метод #OnActionExecutionAsync() представляет асинхронную версию метода OnActionExecuting().


создаем класс(но можно и не создавать, а переопределить сразу в нужном контроллере)
Также мы бы могли переопределить какие-либо другие действия или определить новые общие для всех действия
public abstract class HelloBaseController : Controller
{
    public override void OnActionExecuting(ActionExecutingContext context)
    {
        if (context.HttpContext.Request.Headers.ContainsKey("User-Agent") &&//проверяем, установлен ли заголовок "User-Agent":
//содержит ли этот User-Agent MSIE 8.0 (то есть юзерагент для IE 8)
            Regex.IsMatch(context.HttpContext.Request.Headers["User-Agent"].FirstOrDefault(), "MSIE 8.0"))
        {
//переопределяется результат метода в виде переадресации:
            context.Result = Content("Internet Explorer 8.0 не поддерживается");
        }
        base.OnActionExecuting(context);
    }
}


теперь делаем так и теперь до начала работы метода Index будет срабатывать метод OnActionExecuting(), определенный в базовом классе HelloBaseController
public class HomeController : HelloBaseController
{
    public IActionResult Index()
    {
        return Content("Запрос успешно выполнен");
    }
    // остальные методы контроллера
}

















#ControllerContext #context

свойства класса ControllerContext
#HttpContext: содержит информацию о контексте запроса

#ActionDescriptor: возвращает дескриптор действия - объект ActionDescriptor, который описывает вызываемое действие контроллера

#ModelState: возвращает словарь ModelStateDictionary, который используется для валидации данных, отправленных пользователем

#RouteData: возвращает данные маршрута

обращение к 1 и тому же свойству
var ctx1 = ControllerContext.HttpContext;
var ctx2 = HttpContext;

Объект HttpContext инкапсулирует всю информацию о запросе. В частности, он определяет следующие свойства:
#Request: содержит собственно информацию о текущем запросе. #HttpRequest , можно получить через свойство Request класса Conroller
#Response: управляет ответом #HttpResponse , можно получить через свойство Response класса Conroller
#User: представляет текущего пользователя, который обращается к приложению
#Session: объект для работы с сессиями


Request---

#Body: объект Stream, который используетя для чтения данных запроса
#Cookies: куки, полученные в запросе
#Form: коллекция значений отправленных форм
#Headers: коллекция заголовков запроса
#Path: возвращает запрошенный путь - строка запроса без домена и порта
#Query: возвращает коллекцию переданных через строку запроса параметров
#QueryString: возвращает ту часть запроса, которая содержит параметры. Например, в запросе http://localhost:52682/Home/Index?alt=4 это будет ?alt=4

Получим значения определенных заголовков:
string userAgent = Request.Headers["User-Agent"].ToString();
string referer = Request.Headers["Referer"].ToString();



Response---

#Body: объект Stream, который применяется для отправки данных в ответ пользователю
#Cookies: куки, отправляемые в ответе
#ContentType: MIME-тип ответа
#Headers: коллекция заголовков ответа
#StatusCode: статусный код ответа

с его помощью можем отправить ответ
 Response.StatusCode = 404;
            Response.WriteAsync("Ресурс не найден");




#PartialView #Partial #RenderPartialAsync
частичное представление
@Html.Partial("_GetMessage")
@Html.Partial("_GetMessage", new List<string> { "Lumia 950", "iPhone 6S", "Samsung Galaxy s 6", "LG G 4" })

тоже самое что и @{await Html.RenderPartialAsync("_GetMessage");}

 public ActionResult GetMessage()
    {
        return PartialView("_GetMessage");
    
















































