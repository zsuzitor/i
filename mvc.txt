записать 
надо
https://metanit.com/sharp/tutorial/9.2.php
https://metanit.com/sharp/tutorial/11.2.php  +дальше все про потоки
 https://metanit.com/sharp/tutorial/12.2.php +дальше все про task
https://metanit.com/sharp/tutorial/13.4.php   обработка исключений
https://metanit.com/sharp/tutorial/13.6.php
https://metanit.com/sharp/tutorial/14.2.php  вся глава про рефлексию даже не читал
https://metanit.com/sharp/tutorial/15.1.php   тут все методы linq надо бы записать + дальше
https://metanit.com/sharp/tutorial/16.2.php   xml
так

https://metanit.com/sharp/tutorial/7.4.php
https://metanit.com/sharp/tutorial/18.1.php  процессы


https://metanit.com/sharp/tutorial/7.5.php




#TODO
при отрисовке формы генерится токен и при отправки формы он проверяется на серве уже, так можно исключить отправку запроса пользователя без отрисовки страницы
@Html.AntiForgeryToken()


ToFrequency -?
FrornFrequency -?


#TODO

#PredicateBuilder.False<Foo>(); #where #linq #or #Predicate



AppDomain.CurrentDomain.BaseDirectory

ar a=(RolesProject)Enum.Parse(typeof(RolesProject), "", true);

#for #html
<label><input type="checkbox">Some text</label>





скорее всего треугольники с закругленными концами
div - before-font-size: 225px; content: "\E90E";



System.Numerics. #Complex.







#Layout = null;





#TypeDescriptor
val- eventArgs - мб только для событий
foreach(var i in TypeDescriptor.GetProperties(val)){

i.DisplayName();
i.GetValue();

}







#full text search
если не обновляется индекс
//пытаемся достроить недостающие записи
--ALTER FULLTEXT INDEX on FETexts START UPDATE POPULATION; 

--отключить автоматическое отслеживание 
--ALTER FULLTEXT INDEX ON FETexts SET CHANGE_TRACKING MANUAL;
//полностью перестраиваем
ALTER FULLTEXT INDEX ON FETexts START FULL POPULATION; 







#iis #https #ssl

C:\Users\zsuz\Documents\IISExpress\
включение iis manager  https://www.youtube.com/watch?v=kLhhvCE2IZg
панель управления-> удаление программ->слева "включение или отключение компонентов windows"-> найти "internet information services (Службы IIS)" и включить то что нужно
Убедитесь, что вы выбрали поддержку ASP.NET. Для этого раскройте узел Службы Интернета --> Компоненты разработки приложений --> ASP.NET (Internet Information Services --> World Wide Web Services --> Application Development Features --> ASP.NET):
Если вы хотите использовать поддержку IIS в Visual Studio, которая позволяет вам создавать виртуальные каталоги IIS непосредственно в диалоговом окне New Web Site, вам нужно выбрать пункт «Совместимость управления IIS 6» в разделе «Средства управления веб-сайтом» (Web Management Tools --> IIS 6 Management Compatibility).


Нажмите клавишу Windows и введите "Свойства Windows", выберите первую запись. Включите или выключите функции Windows.
IIS #manager #диспетчер #служб должен вернуться в Панель управления >\Все элементы панели управления\> Администрирование

https://docs.microsoft.com/en-us/iis/manage/configuring-security/how-to-set-up-ssl-on-iis

иконка в центре сертификаты сервера
создать самоподписанный,  
сайт слева выбрал дефолтный
для этого сайта справа bindings
добавить, имя не указывать , выбрать сертификат, указать https


в проекте visual
нажать на название проекта в solution explorer? снизу появятся настройки\свойства(properties) там включить ssl
проект(сверху)->свойства там базовую страницу поменять на ту которая отрисовалась в предыдущем пункте в строке https 





#professorweb #диспетчер #служб #iis #certificate #sertificate
http://professorweb.ru/my/ASP_NET/sites/level3/3_1.php



















#html

#отображать #div #текст как он есть  #html #pre>
#<pre></pre>


#html #div #size #% #width
div1-width 30%
и
div1-width 70%
не умещаются по ширине(перенос на новую строку) в внешний элемент
дивы не умещаются в див
.parent {
/*внешний див В который не умещаются*/
    font-size: 0;
}

.child {
/* это надо для восстановления шрифта к вложенным дивам (которые не умещаются)*/
    font-size: 16px;
}





























#c#


#struct

в структуре нельзя создать конструктор по умолчанию(он генерируется системой В ЛЮБОМ СЛУЧАЕ даже если мы определим другие, в отличии от класса)
если в конструкторе не инициализировать поля то комплятор НЕ сгенерирует им значения, а в классе сгенерирует
в структуре нельзя инициализировать переменные в месте их объявления
в структуре можно засунуть индексатор и статик конструктор
не ссылочный тип данных
не наследуется от класса и от структур и не может быть родителем для них, но может от интерфейса
нельзя определять деструкторы
члены структуры нельзя указывать как abstract virtual protected
объект может быть создан через new(но может и без него)
struct b{}
b perem;perem.val=10;//не вызывая конструктор







#class  
полностью хранится в куче(то что объявлено в классе тоже)
#constructor
если класс наследуется , при вызове конструктора вызывается сначала конструктор родителя(даже если не применили слово #base)
public class cl{
}
cl perem=new cl();
cl perem=new cl(){val=10};//#инициализация
//такая инициализация может быть более сложной и вложенной new cl(){val=new cl2(){valt=10;};}
cl perem=new cl{val=10};//вызывается конструктор без параметров это скомпилируется в тот же код если бы мы создали объект и дальше через точку проставляли бы свойства

x:y{
public x():base(){//передаем в конструктор y
в конструкторе нельзя вызывать метод экземпляра
this.method();//#TODO нельзя???
}
public x():this(){//передаем в другой конструктор x
}
}
В классе Subclass должны быть "повторно определены" любые конструкторы, которые необходимо открыть



???подкласс может иметь меньшую доступность, чем базовый класс, но не большую
public class TopLevel 
{ 
puЬlic class Nested { / / Вложенный класс 
public enum Color { Red, Blue, Tan } / / Вложенное  перечисление 
Вложенный тип
}
Он может получать доступ к закрытым членам включающего типа и ко всему остальному, к чему имеет доступ включающий тип.
• Он может быть объявлен с полным диапазоном модификаторов доступа, а не только public и internal.
• Стандартной доступностью вложенного типа является private, а не internal.
• Доступ к вложенному типу извне требует указания имени включающего типа (как при обращении к статическим членам).
Например, для доступа к члену Color.Red извне класса 
TopLevel необходимо записать так: 
TopLevel.Color color = TopLevel.Color.Red; 
Все типы могут быть вложенными, однако содержать вложенные типы могут только классы и структуры.



Любой совместимый метод экземпляра всегда будет иметь преимущество над расширяющим методом - даже когда параметры 
расширяющего метода дают более точное соответствие по типам.

правило более специфичных параметров TODO







#модификаторы #modificators

#virtual - для возможности переопределения в наследниках
#override - для переопределения чего либо

#sealed - если перед class то запретить наследование
если перед методом то только перед тем для которого должны были указать override - запретит переопределение через override,но метод будет унаследован
class Subclass1 : Base {
   public sealed override void Test() { ... }
}
class Subclass2 : Subclass1 {
   public override void Test() { ... } // Does not compile!
   // If `Subclass1.Test` was not sealed, it would've compiled correctly.
}



#static
если для класса то нельзя создавать экземпляры 
все что в классе должно быть помечено как static
для получения доступа к чему либо в нем className.Meth();






#readonly
только для чтения, можно задать в конструкторе или при объявлении

структуры гарантирующие свою неизменяемость
могут содержать только readonly-поля и get-свойства
public readonly struct ImmutableStruct





#const
только для чтения, константа, можно задать только при объявлении

#volatile
значение поля может быть изменено параллельно выполняющимися потоками, значение не кешируется в потоках=> всегда будет актуальным

#extern
1-метод предоставляется внешним кодом
2- псевдоним для внешней сборки








#checked  #unchecked
исключения при переполнении
что из этого используется по умолчанию нельзя сказать тк зависит от компилятора
существует 2 формы
checked((byte)(int_1*int_2))
checked{(byte)(int_1*int_2)}







#case #switch

#goto case х (переход на другую конструкцию case); 
 goto defaul t
switch 
{ 
case 13: 
//если тут нет кода то можно пропустить break; и 2 case объединятся
case 12: 
break;

case 12 when(y<10): 
break;

case int val: 
break;

default:
break;

case null:
break;

}



#if #else







#get #set
нельзя просто объявить свойство в методе
можно в классе, интерфейсе
public int Response { get; }
public int Maximum { get; } = 999;
Свойство только для чтения public decimal Worth => currentPrice * sharesOwned;
указать для каждого ключевого слова отдельно уровень доступа нельзя
public int Response { get;private set; }//но то что в скобках может быть только более ограничивающим


public int Response { get{
return val;
}
set{
val=value;
} }


#types



#object
главный тип, от него наследуется все остальные

#упаковка #распаковка
в объект типа object можем упаковать объект любого другого типа, и распаковать обратно в тот же тип или в тип родителя того класса который упаковывали
object tt=new object();
a tta=new a();
a ttb=new b();
tt=ttb;
tta=(a)tt;
при упаковке ссылка object == той ссылке которую упаковали(если упаковывали ссылочный тип)

если упаковываем не ссылочный тип
создается объект
значение в объекте это копия!! исходного значения

при распаковке
значение по ссылке копируется, после распаковки нет связи ссылки с распакованным значением




#enum

[:int]- тип перечисления
enum apple[:int]{val1,val2,val3,val4=10}
enum apple:int{val1,val2,val3,val4=10}
(int)apple.val1;//0
(int)apple.val4;//10

for(apple i=apple.val1;i<apple.val4&&(i)<20;++i)
console.writeline(i);//val1...

//#role
foreach (RolesProject roleName in (RolesProject[])Enum.GetValues(typeof(RolesProject)))
                var role = new IdentityRole { Name = roleName.ToString() };

парсим из строки
RolesProject role = (RolesProject)Enum.Parse(typeof(RolesProject), roleNameString, true);

BorderSide b = (BorderSide) 12345; //даже если в BorderSide нет такого числа
Console.WriteLine (b)//12345




[Flags] 
public enum BorderSides 
{ 
None= O, 
Left=l, Right=2, Тор=4, Bottom=8, 
LeftRiqht = Left | Riqht, 
TopBottom = Тор | Bottom, 
All = LeftRiqht | TopBottom
}
BorderSides leftRight = BorderSides.Left | BorderSides.Right; 
if ((leftRight & BorderSides.Left) ! = О) 
Console.WriteLine ("Includes Left"); //Includes Left 
string formatted = leftRight.ToString() ;//"Left, Right" 
BorderSides s = BorderSides.Left; 
s |= BorderSides.Right; 
Console.WriteLine (s == leftRight); / / True

то что применяется к enum
+= -
! = < > <= >= + 
++ sizeof




#dynamic
#Динамическое #связывание противоположность #статического #связывания #статическое
проверка типа откладывается до выполнения
Среде CLR о dynamic ничего не известно — любые
случаи использования dynamic в коде транслируются в тип object, к которому соответствующим образом применен атрибут #DynamicAttribute

dynamic val;
val="";

void meth(object o);
void meth(dynamic o);//перегрузить не получится, тк  dynamic считается object

typeof (dynamic) == typeof (object) //true

dynamic х = 2;
var у= х * 3; // Статическим типом у является dynamic 



#IDynamicMetaObjectProvider #IDMOP #TODO
#Специальное связывание


Класс Duck в действительности не имеет метода Quack.
Вместо этого он использует специальное связывание для перехвата и интерпретации всех обращений к методам. 
puЬlic class Duck: DynamicObject
{
puЬlic override bool TryinvokeMember( InvokeMemЬerBinder binder, object[] args, out object result)
Console.WriteLine (binder.Name + "was called");
result = null;
return true; 
}
}
d.Quack(); // Выводит Quack was called
d.Waddle(); // Выводит Waddle was called



при вызове например метода которого нет(для обычного dynamic) выбросится исключение #RuntimeBinderException




#ExpandoObject
//такое
dynamic expando = new ExpandoObject();
IDictionary<string, object> dictionary = expando;
expando.First = "value set dynamically";
Console.WriteLine(dictionary["First"]);
dictionary["Second"] = "value set with dictionary";
Console.WriteLine(expando.Second);
//
dynamic expando = new ExpandoObject();
expando.AddOne = (Func<int, int>) (x => x + 1);
Console.Write(expando.AddOne(10));







статическое- #TODO
В простейшем случае компилятор осуществляет связывание за счет поиска в типе метода который необходимо вызвать с указанными параметрами.
Если не найдено то компилятор распространяет поиск на методы, принимающие необязательные параметры,
методы базовых классов  и расширяющие методы, которые принимают этот тип в своем первом параметре. Если ничего из этого
не найдено, возникает ошибка компиляции. Независимо от того,
к какому методу произведено связывание, суть в том, что связывание делается компилятором, и оно полностью зависит от 
статических сведений о типах операндов (в данном случае d). Именно
поэтому такой процесс называется статическим связыванием.





#DLR
dynamic language runtime








#Single представляет тип #float



#decimal
static Add
static Divide
static Myltiply
static Negate
static MaxValue
#TODO M







#double


const -
Epsilon


double.Negativeinfinity
double.NaN
#NaN
Not а Number - не число
+оо, -оо и -0



Console.WriteLine ( 1.0 /О.О);// Бесконечность 
Console.WriteLine (-1.0 /О.О);// Минус бесконечность 
Console.WriteLine ( 1.0 / -0.0); // Минус бесконечность 
Console.WriteLine (- 1.0 / -0.0); // Бесконечность
Console.Write (О.О/ О.О); //NaN
Console.Write ( (1.0 / О.О) - (1.0 /О.О)); //NaN

NaN==NaN;//false
object.Equals (0.0/0.0, double.NaN);//true
для проверки на NaN
(fload|double).IsNaN();







#int














#array
Char[]off=new Char[]{a,s}
Char[]off={a,s}
Int[,]cf={{0,3},{}}
char [] vowels = {'а', 'е', 'i', 'о', 'u'};
int[][] matrix = 
{ 
new int [] {О, 1, 2}, 
new int [] { 3, 4, 5} }
new []{1,2 }

длина массива #Length 
размерность массива #Rank
#Createinstance динамическое создание массива
#GetValue #SetValue извлечение и установка элементов независимо от типа массива????
#GetLength
matrix.GetLength(0); //Метод GetLength массива возвращает длину для заданного измерения (начиная с 0):

System.Array.#CopyTo-- глубокое копирование
#clone-- поверхностное копирование



см также -collection
IsFixedSize - если фиксированного размера
IsSynchronized - если можно использовать в многопоточной среде
Rank - размерность массива
SyncRoot - объект для синхронизации доступа к массиву

если отсортированный и одномерный то
BinarySearch поиск эелемента по применению как IndexOf
IndexOf
Clear -очищает, размер остается
Clone - не полная копия(если внутри ссылки то будут ссылаться на теже элементы)
Find...
ForEach
GetValue
Reverse
Exist





#Range
#Enumerable
//не создает  коллекцию но выдает в подходящие моменты времени от 0 до 9 включительно -- 0 1 2...9
//отложенное выполнения
//к такой штуке можно применить например Reverse
foreach(var i in Enumerable.Range(0,10)){}









#collection #array #list #interface


#приведение #типов #Необобщенное в #обобщенное #object
var classicList = new System.Collections.ArrayList(); 
classicList.AddRange ( new int[] { 3, 4, 5} ) ; 
IEnumerable<int> sequencel = classicList. #Cast<int>()//когда встретит не int элемент(не сможет привести через is) то сгенерит исключение
IEnumerable<int> sequencel = db.users.Cast<int>()
IEnumerable<int> sequencel = classicList. #OfType<int>()//когда встретит не int элемент(не сможет привести через is) то пропустит элемент




инициализация
List<char> lst = new List<char>() { 'С', 'А', 'Е', 'В', 'D', 'F' };
lst1=new SortedList<int, string>() { {1, "один"}, {2, "два" }, {3, "три"} };
такая инициализация интерпретируется как lst.Add();//=> нельзя так закидывать значения в коллекции в которых нет public Add



В среде .NET Framework поддерживаются пять типов коллекций: необобщенные,
специальные, с поразрядной организацией, обобщенные и параллельные
необобщенные- хранят только object
Специальные коллекции - оперируют данными конкретного типа или же делают это каким-то особым образом//--- #CollectionsUtil  #HybridDictionary  #ListDictionary #NameValueCollection #OrderedDictionary #StringCollection #StringDictionary
с поразрядной организацией-BitArray
Обобщенные коллекции-храниться только такие элементы данных,которые совместимы по типу с данной коллекцией. Благодаря этому исключается случайное несовпадение типов
Параллельные коллекции-  поддерживают многопоточный доступ к коллекции

должны реализовавывать IEnumerator и IEnumerable,  IEnumerator<T> и IEnumerable<T>




#перечислитель
#итератор

#IEnumerable
для #foreach,
IEnumerator GetEnumerator()
 IDictionaryEnumerator GetEnumerator()//если словарь
public IEnumerator GetEnumerator() {
return this;//так можно но лучше на надо смотри  IEnumerator
}
public void Reset() { idx = -1; }









#IEnumerator

для #foreach, 
любое изменение коллекции делает перечислитель недействительным

bool MoveNext() //true- если есть след элемент
Reset // устанавливает перечислитель в конец(не на последний элемент)(элемент перед первым, для получения первого после reset -MoveNext())
свойство
Current

очень нежелательно реализовывать сразу и IEnumerator и IEnumerable в 1 классе (через GetEnumerator(){return this;})тк тогда нельзя будет 
запустить сразу несколько foreach



тк желательно реализовать и обобщенную версию и нет, но просто так это не сделать нужно

class CountingEnumerable: IEnumerable<int>
{
public IEnumerator<int> GetEnumerator()
{

return new CountingEnumerator();
}
IEnumerator IEnumerable.GetEnumerator()
{

return GetEnumerator();
}
}
class CountingEnumerator : IEnumerator<int>
{
int current = -1;

public bool MoveNext()
{
current++;
return current < 10;
}
public int Current { get { return current; } }

object IEnumerator.Current { get { return Current; } }
public void Reset()
{

current = -1;
}
public void Dispose() {}
}



...
CountingEnumerable counter = new CountingEnumerable();
foreach (int x in counter)
{
Console.WriteLine(x);
}



















#IQueryable : IEnumerable
удаленные бд принимает expression при запросе происходит оптимизация




#IList : ICollection , IEnumerable
this[int index] { get; set; }
Add
Clear
Contains
IndexOf
Insert
Remove
RemoveAt
свойства
IsFixedSize
IsReadOnly



#ICollection: IEnumerable


int Count { get; }
bool IsReadOnly { get; }








#IDictionary: ICollection , IEnumerable
пустые ключи не допускаются
V this[T key] { get; set; }
Add
Clear
Contains
GetEnumerator
Remove
bool TryGetValue(TKey key, out TValue value) пытается извлечь по key и засунуть в value. если все норм то true. Если key не найден, value =значение выбираемое по умолчанию
свойства
IsFixedSize
IsReadOnly
Keys
Values



#IComparer 
int Compare(T х, T у)
(x>y) вернет положительное число



 #IEqualityComparer
bool Equals(T х, T у)
int GetHashCode(T obj)


#ISet<T>

: IEnumerable, IEnumerable<T>,ICollection<T>



#struct
#DictionaryEntry
коллекции словарей(вроде только не обобщенных) хранят в такой структуре key value
public DictionaryEntry(T key, T value)

#KeyValuePair<TKey, TValue>
коллекции словарей(вроде только обобщенных) хранят в такой структуре key value

class

абстрактные классы
 CollectionBase, ReadOnlyCollectionBase и DictionaryBase


#ArrayList , обобщенная форма называется #List
Определяет динамический массив, т.е. такой массив, который может при необходимости увеличивать свой размер

: ICollection, IList, IEnumerable , ICloneable

AddRange
BinarySearch
static #FixedSize Заключает коллекцию list в оболочку типа ArrayList с фиксированным размером и возвращает результат 
#InsertRange
static Readonly Заключает коллекцию list в оболочку типа ArrayList, доступную только для чтения
#SetRange Заменяет часть вызывающей коллекции  элементами коллекции переданной
Sort
 static Synchronized Возвращает синхронизированный вариант коллекции 
#TrimToSize Устанавливает значение свойства Capacity равным значению свойства Count(обрезает массив до количества элементов в нем)

свойства
Capacity - максимальный размер массива на данный момент, можно устанавливать но нельзя установить меньше чем количество элементов в массива сейчас




#Hashtable Определяет хеш-таблицу для пар “ключ-значение”   обобщенная форма называется #Dictionary
ключ хешируется=> скорость работы не зависит от количества элементов внутри
:IDictionary, ICollection, IEnumerable, ISerializable, IDeserializationCallback ,ICloneable



public Hashtable()
public Hashtable(IDictionary d)
public Hashtable(int capacity)
public Hashtable(int capacity, float loadFactor=1)
loadFactor - коэффициент заполнения(от 0,1 до 1,0)
Он определяет степень заполнения хеш-таблицы до увеличения ее размера. В частности, таблица расширяется, Count> loadFactor*емкость_таблицы


ContainsKey
ContainsValue
Synchronized


#Dictionary см Hashtable
:IDictionary,IDictionary<TKey, TValue>, ICollection, ICollection<KeyValuePair<TKey,TValue>>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>,ISerializable , IDeserializationCallback

//вызов метода #Add 2 раза
var dict = new Dictionary<int, string>()
{
{ 5 , " f i ve" } ,
{ 10, "ten" }
}; 
Или в случае версии С# 6: 
var dict = new Dictionary<int, string>()
{
[3] = "three",
}; 




теория--
Инициализация происходит либо при создании (если передана начальный размер коллекции), либо при добавлении первого элемента, причем в качестве размера будет выбрано ближайшее простое число (3). 
При этом создаются 2 внутренние коллекции — int[] buckets и Entry[] entries. 
Первая будет содержать индексы элементов во второй коллекции, а она, в свою очередь, — сами элементы


При добавлении элемента вычисляется хэшкод его ключа и затем — индекс корзины в которую он будет добавлен по модулю от величины коллекции:

проверяется нет ли уже такого ключа в коллекции, если есть — то операция Add выбросит исключение, а присваивание по индексу просто заменит элемент на новый. 
Если достигнут максимальный размер словаря, то происходит расширение (выбирается новый размер ближайшим простым числом).
Сложность оперции соответственно — O(n).
Если происходит коллизия (то есть в корзине с индексов bucketNum уже есть элемент), то новый элемент добавляется в коллекцию, его индекс сохраняется в корзине, а индекс старого элемента — в его поле next. 
Таким образом получаем однонаправленный связный список. 
Данный механизм разрешения коллизий называется chaining. Если при добавлении элемента число коллизий велико (больше 100 в текущей версии), 
то при расширении коллекции происходит операция перехэширования, перед выполнением которой случайным образом выбирается новый генератор хэшкодов.
Сложность добавления O(1) или O(n) в случае коллизии.


При удалении элементов мы затираем его содержимое значениями по умолчанию, меняем указатели next других элементов при неоходимости и сохраняем индекс этого элемента во внутреннее поле freeList, 
а старое значение — в поле next. Таким образом, при добавлении нового элемента мы можем повторно использовать такие свободные ячейки:
Сложность снова O(1) или O(n) в случае коллизии.


-----
Внутреннее устройство простейшего hash map со списком коллизий чрезвычайно примитивно: имеется массив T[N], каждый элемент которого — это список. 
Входом в таблицу (индексом) является хеш-значение ключа. Все ключи с одним и тем же хешем (по модулю N) попадают в один и тот же список, называемый списком коллизий.
=>
есть массив массивов ms[i][i2]
i- хэш элементов, если у некоторых элементов одинаковый хэш, они записываются в массив ms[i]->[i2_0],[i2_1],[i2_2]





#KeyValuePair
Определяет пару "ключ-значение", которая может быть задана или получена
обычный словарь можно переписать под список-, аналог для словаря с dict[1] = "one"; , но ключи для обращения это индексы в списке а не значения key
List<KeyValuePair<int, string>> listKVP = new List<KeyValuePair<int, string>>();
listKVP.Add(new KeyValuePair<int, string>(1, "one"));

Console.Write( "key:" + listKVP[0].Key + "value:" + listKVP[0].Value );









#SortedDictionary см Dictionary
IDictionary,IDictionary<TKey, TValue>, ICollection, ICollection<KeyValuePair<TKey,TValue>>, IEnumerable , IEnumerable<KeyValuePair<TKey, TValue>>



#SortedList см List



#HashSet
динамическая коллекция
множество уникальных значений, можно использовать пересечение, объединение и разноименность
: ICollection<T>, ISet<T>, IEnumerable,IEnumerable<T>, ISerializable, IDeserializationCallback

RemoveWhere
SymmetricExceptWith - разноименность с множеством
UnionWith - объекдинение множеств
ExceptWith - вычитание множеств

public IEqualityComparer<T> Comparer { get; }



#SortedSet






#Queue Определяет очередь, или список, действующий по принципу "первым пришел — первым обслужен"
ICollection, IEnumerable и ICloneable
при увеличении для создания места под 1 элемент, увеличивается  на коэффициент роста(по умолчанию 2)
public Queue (int capacity, float growFactor=2)//growFactor=от  1,0 до 10,0

Enqueue - поместить в очередь
Dequeue извлечь и удалить 1 объект в очереди
Рееk извлечь но не удалять след объект в очереди
TrimToSize



#SortedList Определяет отсортированный список пар "ключ-значение"
пары "ключзначение" хранятся в порядке, отсортированном по значению ключей. 
IDictionary, ICollection, IEnumerable ,ICloneable

GetBylndex
GetKeyList
GetValueList
IndexOfKey
SetBylndex
Synchronized
TrimToSize


#Stack Определяет #стек, или список, действующий по принципу "первым пришел — последним обслужен”
ICollection, IEnumerable и ICloneable
Peek() - вершина стека
Pop() -  вершина стека с удалением
Push()
Synchronized()





#LinkedList
двунаправленный список
:ICollection, ICollection<T>,IEnumerable, IEnumerable<T>, ISerializable , IDeserializationCallback

ссылки на предыдущий и следующий элемент хранятся в #LinkedListNode
LinkedListNode-
public LinkedListNode<T> Next { get; }//null если дальше пусто
public LinkedListNode<T> Previous { get; }
public LinkedList<T> List { get; }
public T Value { get; set; }

-
public LinkedListNode<T> First { get; }
public LinkedListNode<T> Last { get; }

AddAfter
AddBefore
AddFirst
AddLast
Find
Remove




#BitArray
хранит биты а не объекты, для хранения bool как 1 бит а не 1 байт



#SynchronizedCollection<T>
#SynchronizedReadOnlyCollection<T>
#KeyedByTypeCollection<T>




параллельные коллекции #parallel #collection
#BlockingCollection<T> Предоставляет оболочку для блокирующей реализации интерфейса IProducerConsumerCollection<T>
#ConcurrentBag<T> Обеспечивает неупорядоченную реализацию интерфейса IProducerConsumerCollection<T>, которая оказывается наиболее пригодной в том случае, когда информация вырабатывается и потребляется в одном потоке
#ConcurrentDictionary<TKey, TValue> Сохраняет пары "ключ-значение”, а значит, реализует параллельный словарь
#ConcurrentQueue<T> Реализует параллельную очередь и соответствующий вариантинтерфейса IProducerConsumerCollection<T>
#ConcurrentStack<T> Реализует параллельный стек и соответствующий вариант интерфейса IproducerConsumerCollection<T>





#var 
неявная типизация

Объявляемая переменная является локальной, но не статическим полем или полем экземпляра.
• Переменная инициализируется в виде части объявления.
• Выражение инициализации не является группой методов или анонимной функцией (без приведения).
• Выражение инициализации не дает в результате null.
• В операторе объявлена только одна переменная.
• Тип, который нужно назначить переменной, является типом выражения инициализации на этапе компиляции.
• В выражении инициализации не задействована объявляемая переменная







#bool
хранится как 1 байт
для хранения битом #BitArray




#string 
ссылочный тип но передается по значению
не изменяемый(при попытыке изменения создает новую строку)
нет конструктора без параметров


#$ $"text{val}"
#интерполяция строки($"")

#@ @"\text"-> "\\text"
если применять вместе то в порядке
$@"ffg"
скобки дублировать
$@"she{{x1}}"




#Интернирование строк — это механизм, при котором одинаковые литералы представляют собой один объект в памяти.
в рамках процесса (именно процесса, а не домена приложения) существует одна внутренняя хеш-таблица, ключами которой являются строки, а значениями – ссылки на них. 
Во время JIT-компиляции литеральные строки последовательно заносятся в таблицу (каждая строка в таблице встречается только один раз). На этапе выполнения ссылки на литеральные строки присваиваются из этой таблицы. 



#Конкатенация  #Concat
String.Concat(s3, "!!!");//"123"+"332"
IndexOf
public int IndexOfAny(char[] anyOf)  индекс первого символа который равен символу из массива
StartsWith
contains
#Split(,#StringSplitOptions)
Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
string[] words = text.Split(new string[] { "," }, StringSplitOptions.RemoveEmptyEntries);

#Trim([params char[] trimChars]) - удаляет в начале и в конце символы из массива, если ничего не передали то удалит пробелы
функция TrimStart обрезает начальные символы, а функция TrimEnd обрезает конечные символы

Join
public string #PadLeft(int totalWidth) заполнит с начала пробелами что бы общая длина строки была==totalWidth
public string #PadLeft(int totalWidth, char paddingChar)
public string #PadRight(int totalWidth)
public string #Insert(int startIndex, string value)
public string Remove(int startIndex, int count)
public string Replace(string oldValue, string newValue)
public string #ToLower()
public string #ToUpper()
public string #Substring(int startIndex, int length)//вернет строку которая начинается с startIndex

#Compare Сравнение строк
Если первая строка по алфавиту стоит выше второй, то возвращается число меньше нуля. В противном случае возвращается число больше нуля. И третий случай - если строки равны, то возвращается число 0.
int result = String.Compare(s1, s2);

// обрезаем начиная с третьего символа #Substring
text = text.Substring(2);
// обрезаем сначала до последних двух символов
text = text.Substring(0, text.Length - 2);


public static string #Format(string format, params object[] args)
 String.Format("{0:F2}", v);//0-позиция аргумента
string str = 189.99.ToString("С");//тоже форматирование














#datetime #время #дата 
структура

#DateTimeRange
создание коллекции
 DateTime startDate = new DateTime(2008, 05, 1, 10, 2, 3, 4, DateTimeKind.Utc);
var dates = new DateTimeRange(startDate, endDate);
var dates = new DateTimeRange(SampleData.Start, SampleData.End);
var query = from date in dates
join defect in SampleData.AllDefects
on date equals defect.Created.Date
into joined
select new { Date = date, Count = joined.Count() };










#StringComparer: IComparer
CurrentCulture - с учетом регистра и культурной среды
CurrentCultureIgnoreCase - без учета регистра и культурной среды
InvariantCulture - с учетом регистра без культур
InvariantCultureIgnoreCase
OrdinalIgnoreCase - порядковое сравнение без учета регистра







#BitConverter
класс для преобразования базовых типов данных в байты










#? #?? #null #Nullable
структура  тип Nullable<T>
//эквивалент
Nullable<bool> val;
bool? val;
val=null;
val=false;

val.HasValue//проверить установлено ли значение
val.Value//получить значение, только для чтения, если null то исключение
#GetValueOrDefault()возвращает значение Value, если HasValue равно true, и результат new Т () или заданное стандартное значение в противном случае

var test=val??true;//если val==null то вернет 2 член(true) если не null то вернет val
var test=val??method();//если val!=null то method не вызовется

можно сравнивать но если хотя бы 1== null то
< > <= >= -всегда false
true||null -true
null||null -null
!null - null
общее правило- если необходимо сравнить null значит будет null, если можно получить результат без сравнения то он будет получен


Когда Т? упаковывается, упакованное значение в куче содержит Т, а не Т?, тк object-ссылочный тип




#Random








#GC #мусор #сборка




#params #param #method
void func(params int[] ints){}
func();
func(1);
func(1,2);
func(new int[]{1,2,3});

если метод в 1 строку можем сделать так, с 17 студии кажется
int Foo (int х) => х * 2;



#необязательные #параметры
void func(int gg,int asd=10){}
Foo<T>(T value = default(T))
необязательные параметры(asd) должны быть указаны в виде константного выражения или конструктора без параметров для типа значения( это эквивалентно применению операции default(...)).  не могут быть помечены посредством ref или out.

Все необязательные параметры должны располагаться после обязательных параметров. Исключением является массив
параметров (объявленный с помощью модификатора params), который по-прежнему следует помещать в конец списка параметров, но он может находиться после необязательных параметров.
Массив параметров нельзя объявлять как необязательный параметр — если в вызывающем коде
значения для него не указаны, будет применяться пустой массив. 


 Всегда можно использовать константы: числовые и строковые
литералы, null, члены const, члены перечислений и операцию default(Т). Должно быть доступным неявное преобразование типа
указанного значения в тип параметра, но оно не может быть преобразованием, определяемым
пользователем.






#позиционные



//порядок вызова
//сначала выполняется func1()
func(a,b){};
func(func1(),func2());
func(a:func1(),b:func2());
func(b:func1(),a:func2());



#именованные параметры
порядок вызова смотре для "позиционные
Foo (х:1, у:2);
bool success = int.TryParse("10", result: out number);


void func(int x){}

func(10);
x-параметр
10-аргумент






#Tuple #кортеж

Tuple<t1,t2,t3>
static Create
Tuple<string, string, string, string> t= Tuple.Create("", "", "", "");
t.Item1 t.Item2

кортеж

var tuple = (5, "tre");
или 	 (int, string) tuple = (5, "tre");
tuple.Item1 += 26;

var tuple = (count:5, sum:10);
tuple.count=5;

var (name, age) = ("Tom", 23);
 Console.WriteLine(name);

var tuple = GetValues();
private static (int, int) GetValues()
{
    var result = (1, 3);

private static (int sum, int count) GetNamedValues()
{
    var result = (sum:0, count: 0);


 var (name, age) = GetTuple(("Tom", 23), 12);
private static (string name, int age) GetTuple((string n, int a) tuple, int x)
{
    var result = (name: tuple.n, age: tuple.a + x);











есть утиная тапизация

когда делаем так
List<int> val=new List<int>(){10,20};
будет вызван метод Add 2 раза, но
Тот факт, что тип должен реализовывать интерфейс IEnumerable, никогда не используется
компилятором.
• Метод Add() находится только по имени — в интерфейсе нет требований о его указании.




#foreach
foreach(T val in IEnumerable<T>){}
нужны IEnumerable и IEnumerator
сразу(даже перед 1 итерацией) вызывает сначала MoveNext() а потом Current
если есть dispose у Enumerator то вызывается



можно также без интерфейсов, просто докинуть #итератор  #yield #iterator
код останавливает выполнение метода, возвращает значение и при вызове метода еще раз(MoveNext) продолжает с того же места
Оператор yield return не разрешено использовать внутри блока try при наличии любых блоков catch
не допускается применять оператор yield return или yield break в блоке finally.
если используется в try то при преждевременной остановке итерационного цикла(foreach) при вызове Dispose выполнение итерации продолжится
и то что транслируется в try - (using) -- Скит стр 206

метод который принимает ref out не может содержать yield



public IEnumerator<T> GetEnumerator() {
foreach(T ch in chrs)
yield return ch;
}


#итератор  #yield #return
при создании итератора класс автоматически реализует IEnumerator(не нужно явно указывать)

yield break; // прерывание итератора #TODO






//такая конструкция необходимо потому что метод  с итератором не будет вызван пока не будет вызван метод MoveNext, 
но в таком случае сразу будет обработка ошибки а потом уже ждет вызов метода MoveNext

public static IEnumerable<T> Where<T>(IEnumerable<T> source, Predicate<T> predicate)
{
//проверяем данные и передаем в след метод
return WhereImpl(source, predicate);
}
private static IEnumerable<T> WhereImpl<T>(IEnumerable<T> source, Predicate<T> predicate)
{
foreach (T item in source)
{
if (predicate(item))
{
yield return item;
}
}
}












именованный итератор

public IEnumerable имя_итератора(список_параметров) {
// ...
yield return obj;
}
public IEnumerable MyItr(int end) {
for(int i=0; i < end; i++)
yield return (char) (ch + i);
if (i==5) 
yield break;//заканчивает вызов, далее вызываться не будет(преждевременное завершение )
}

Итератор должен возвращать один из следующих четырех интерфейсов (иначе компилятор сгенерирует сообщение об ошибке):
System.Collections.IEnumerable
System.Collections.IEnumerator
System.Collections.Generic.IEnumerable<T>-наиболее часто
System.Collections.Generic.IEnumerator<T>





#Finalize и #Dispose #IDisposable #Деструктор
освобождения неуправляемых ресурсов

если наследуем от класса с IDispose то тоже надо реализовать
private bool IsDisposed = false;
 
    protected override void Dispose(bool disposing)
    {
        if (IsDisposed) return;
        if (disposing)
        {
            // Освобождение управляемых ресурсов
        }
        IsDisposed = true;
        // Обращение к методу Dispose базового класса
        base.Dispose(disposing);
    }





public class SomeClass: IDisposable
{
    private bool disposed = false;
 
    // реализация интерфейса IDisposable.
    public void Dispose()
    {
        Dispose(true);
        // подавляем финализацию
        GC.SuppressFinalize(this);
    }
 
    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            if (disposing)
            {
                // Освобождаем управляемые ресурсы
            }
            // освобождаем неуправляемые объекты
            disposed = true;
        }
    }
 
    // Деструктор
    ~SomeClass()
    {
        Dispose (false);
    }
}






















c#

#Параллельное #программирование #TPL
#Task
System.Threading.Tasks


после того, как задача завершена, она не может быть перезапущена. => для повторного запуска нужно пересоздать

при возникновении исключения(можно узнать по свойствам, но выбросится на await)
Свойство Status задачи получает значение Faulted, когда асинхронная операция отказала
(и свойство IsFaulted возвращает true).
• Свойство Exception возвращает объест AggregateException, содержащий все (потенциально множественные) исключения, которые привели к отказу задачи, или null, если
задача не отказывала.
• Метод Wait() сгенерирует исключение AggregateException, если задача находится в
состоянии отказа.
• Свойство Result класса Task<T> (который также ожидает завершения) аналогичным образом сгенерирует исключение AggregateException

для того что бы выбрасывать исключения сразу а не через await
static Task<int> ComputeLengthAsync(string text)//метод не объявляется асинхронным!
{
//если надо выбрасываем исключения до вызова
return ASYNCMETHOD();//можно обернуть в асинхронную лямбду и вызвать ее+вернуть ее результат
}






public delegate void Action()
public Task(Action действие)
public Task(Func<TResult> функция)
public Task(Func<Object, TResult> функция, Object состояние) //задача принимает аргумент состояние


public Task<TResult> StartNew(Func<TResult> функция)
public Task<TResult> StartNew(Func<Object,TResult> функция, Object состояние)
public Task StartNew(Action<Object> action, Object состояние, CancellationToken признак_отмены)


public int Id { get; }
public static Nullable<int> CurrentID { get; }


в методе который передается в task при условии передачи в метод токена отмены параметром
cancelTok.ThrowIfCancellationRequested();//установит IsCanceled и выбросит исключение AggregateException
IsCanceled


Dispose().//только для завершенной задачи, если задача не завершена то InvalidOperationException

исключения
ObjectDisposedException.  если задача освобождена посредством вызова метода Dispose()
AggregateException,  если задача сама генерирует исключение или же отменяется


//1 способ

Task task = new Task(() => Console.WriteLine("Hello Task!"));
task.Start();
//2 способ
//	
Task task = Task.Factory.StartNew((Action action);
//3 способ
Task task = Task.Run(() => Console.WriteLine("Hello Task!"));

//получить результат
Task<int> task1 = new Task<int>(()=>Factorial(5));
        task1.Start();
//эта строка будет ждать завершения выполнения задачи
var f=task1.Result

//остановит поток до выполнения задачи
 task.Wait();
//остановит поток до выполнения всех задач в массиве  tasks
Task.WaitAll(params Task[] tasks)
//остановит поток до выполнения хотя бы 1 задачи в массиве  tasks
Task.WaitAny(params Task[] tasks)

//task2 начнет выполнение после завершения task1

public Task ContinueWith(Action<Task> действие_продолжения)
 Task task2 = task1.ContinueWith(Display);
void Display(Task t)
        {}
||
Task task3 = task1.ContinueWith((Task t) =>
    {
        Console.WriteLine("Id задачи: {0}", Task.CurrentId);
    });




//массивы
Task[] tasks1 = new Task[3]
foreach
 t.Start();
||
for (int i = 0; i < tasks2.Length; i++)
    tasks2[i] = Task.Factory.StartNew(() => Console.WriteLine($"Task {j++}"));

Класс Task имеет ряд свойств, с помощью которых мы можем получить информацию об объекте. Некоторые из них:
AsyncState: возвращает объект состояния задачи
CurrentId: возвращает идентификатор текущей задачи
Exception: возвращает объект исключения, возникшего при выполнении задачи
Status: возвращает статус задачи

#TaskCreationOptions #AttachedToParent
//вложенные задачи и из за параметра внешняя будет "ждать внутреннюю"
var outer = Task.Factory.StartNew(() =>      // внешняя задача
    {
var inner = Task.Factory.StartNew(() =>  // вложенная задача
        {}, TaskCreationOptions.AttachedToParent);
    });
outer.Wait(); // ожидаем выполнения внешней задачи(блокирует поток)--!! надо применять await




#delay

var taskDelay = Task.Delay(3000);//создаем delay(это не остановит таск, выполнение продолжится)
//выполнение
//останавливаем таск если время еще не прошло
await taskDelay;






#Параллельное #программирование #TPL
#Parallel
#thread
теория
Отличия в многозадачности на основе процессов и потоков могут быть сведены к
следующему: многозадачность на основе процессов организуется для параллельного
выполнения программ, а многозадачность на основе потоков — для параллельного выполнения отдельных частей одной программы.



public delegate void ThreadStart()
public delegate void ParameterizedThreadStart(object obj)

public Thread(ThreadStart запуск) //создание потока
newThrd.Start([object param]);//запуск потока, можно передать параметр, если параметр передан то конструктор(ниже)
public Thread(ParameterizedThreadStart запуск)//принимает только тип object=> функция тоже должна принимать object
var th11=new Thread(new ParameterizedThreadStart(method));
th11.Start((object)10);

Name - имя потока, можно задать
public bool IsAlive { get; }
public void Join() //ждет завершения потока, можно указать время
public bool IsBackground { get; set; } //сделать поток фоновым


установить приоритетность потока(чем выше тем чаще получает доступ к цп)
public ThreadPriority Priority{ get; set; }//ThreadPriority-enum


применять в особых случаях
public void Abort() //прервать выполнение потока
Thrd.Abort();
Thrd.Join(); //ожидать прерывания или выполнения
Thrd.Abort (object a);
в методе который в потоке
try {
//первая строка метода

//последняя строка метода
} catch(ThreadAbortException exc) {
Console.WriteLine("Поток прерван, код завершения " +
(int)exc.ExceptionState);//object a

//отменяем прерывание
Thread.ResetAbort();
}



состояния потока 
public ThreadState ThreadState{ get; }


получить текущий поток
public static Thread CurrentThread{ get; }









#Process
public static Process Start(string имя_файла)
//"просит" закрыться
public void Close()
public bool CloseMainWindow() //Если процесс является приложением Windows с графическим пользовательским интерфейсом, true-сообщение получено,false-приложение не имеет главного окна
//закрывает
неконтролируемому прерыванию процесса. Любые несохраненные данные, связанные с прерываемым процессом, будут, скорее всего, потеряны.
public void Kill()
//ждать закрытия
public void WaitForExit()
public bool WaitForExit(int миллисекунд)// false, если он все еще выполняется.





новое


//попытается распараллелить методы, вызывающий поток останавливается и ждет результаты
public static void Invoke(params Action[] actions)

#for
public delegate void Action<in T>(T obj)
public static ParallelLoopResult For (int fromInclusive, int toExclusive, Action<int> body)
первый параметр задает начальный индекс элемента в цикле, а второй параметр - (конечный индекс не включая , i<toExclusive). 
Третий параметр - делегат Action - указывает на метод, который будет выполняться один раз за итерацию
Parallel.For(1, 10, Factorial);
void Factorial(int x)
{}

break так же как в обычном for
public static ParallelLoopResult For(int fromInclusive, int toExclusive, Action<int, ParallelLoopState> body)
public delegate void Action<in T1, in T2>(T argl, T2 arg2)//T1-int T2-ParallelLoopState

#ParallelLoopState
public void Break()//все шаги до вызова выполнятся, несколько может выполниться и после вызова
Stop()//если не волнует выполнение шагов

#ParallelLoopResult-
public bool IsCompleted { get; }//определяет, завершилось ли полное выполнение параллельного цикла
public Nullable<long> LowestBreakIteration { get; }//если выполнение прервется, то будет содержать переменную-итертор на которой все прервалось(возвращает индекс, на котором произошло прерывание работы цикла)


есть также формы -
 указывать метод, вызываемый по завершении потока каждого цикла.
др.



#ForEach
public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, Action<TSource> body)
public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, Actior<TSource, ParallelLoopState> body)
ParallelLoopResult result = Parallel.ForEach<int>(new List<int>() { 1, 3, 5, 8 },
                Factorial);

остальное см For










 
//остановить задачу #cancel #CancellationTokenSource #CancellationToken
//вне задачи объявить
 CancellationTokenSource cancelTokenSource = new CancellationTokenSource();
    CancellationToken token = cancelTokenSource.Token;
//остановить 
cancelTokenSource.Cancel();
cancelTokenSource.CancelAfter(TimeSpan.FromSeconds(1));
await Task.Delay(TimeSpan.FromSeconds(1.5), source.Token);//#TODO #delay
//в task
if (token.IsCancellationRequested)
            {
                return;//отменить задачу
            }

//если операция внешняя передавать ссылку на токен
Task task1 = new Task(() => Factorial(5, token));
void Factorial(int x, CancellationToken token)
{



//прерывание операции в цикле
//также объявить токен и в любом потоке также отменить
//в другом потоке где нужны циклы
try
    {   
        Parallel.ForEach<int>(new List<int>() { 1,2,3,4,5,6,7,8}, 
                                new ParallelOptions { CancellationToken=token}, Factorial);
        // или так
        //Parallel.For(1, 8, new ParallelOptions { CancellationToken = token }, Factorial);
    }
    catch(OperationCanceledException ex)
    {
        Console.WriteLine("Операция прервана");
    }
    finally
    {
        cancelTokenSource.Dispose();
    }


Асинхронные делегаты
public delegate int DisplayHandler();
//выполняем в ассинхронном режиме
//Первый параметр представляет делегат System.AsyncCallback  AsyncCallback указывает на метод, который будет выполняться в результате завершения работы асинхронного делегата
//Второй параметр представляет произвольный объект, с помощью которого мы можем передать дополнительную информацию в метод завершения, указанный в предыдущем параметре. 
IAsyncResult resultObj = handler.BeginInvoke(null, null);
//ждет выполнения
int result = handler.EndInvoke(resultObj);


//с параметрами
// добавляем параметр в делегат и в сам метод
 public delegate int DisplayHandler(int k);
int Display(int k)
        {}
//метод который будет вызываться по завершению
static void AsyncCompleted(IAsyncResult resObj)
        {
            string mes = (string)resObj.AsyncState;//Асинхронные вызовы
}
DisplayHandler handler = new DisplayHandler(Display);
 //1- параметр в метод 2- метод после завершения 3-параметр для метода после завешения
            IAsyncResult resultObj = handler.BeginInvoke(10, new AsyncCallback(AsyncCompleted), "Асинхронные вызовы");

            int res = handler.EndInvoke(resultObj);






#async и #await

ассинхронные методы -суффикс Async

await. Их нельзя применять в блоках catch или finally, в неасинхронных
анонимных функциях, в теле оператора lock или в небезопасном коде

var w=async ()=>return 1;

async void DisplayResultAsync()
    {
//возращает int тк есть await если его нет то возвращает task
int result = await FactorialAsync(num);
}
static Task<int> FactorialAsync(int x)
    {
return Task.Run(() =>
        {});

//вызвать метод
DisplayResultAsync();
||
Task t = DisplayResultAsync();
    t.Wait();
||
//.GetAwaiter(), который остановит выполнение в вызывающем потоке, пока задача не завершится, и .GetResult(), который возвращает результат
DisplayResultAsync().GetAwaiter().GetResult();

//ждать выполнение всех задач
 Task<int> t1 = FactorialAsync(num1);
await Task.WhenAll(new[] { t1, t2, t3 });
 var gg=t1.Result



#GetAwaiter #TaskAwaiter #GetResult
Task<TResult>.GetAwaiter() возвращает объект TaskAwaiter<TResult>, который имеет метод GetResult(), возвращающий TResult

#TODO
Task.Yield(), который возвращает структуру YieldAwaitable она имеет метод GetAwaiter(), возвращающий структуру Yield
Awaitable.YieldAwaiter, которая содержит метод GetResult(), возвращающий void
await Task.Yield();



#ef #core нужно использовать async только там где происходит реальная работа с данными(например FirstOrDefaultAsync или SaveChangesAsync), 
но НЕ надо использовать там где ее нет(например Add Remove)







#PLINQ #Parallel #LINQ
Основу PLINQ составляет класс #ParallelEnumerable



при возникновении ошибки в 1 потоке прерываются все

#AsParallel выполение запроса разбивая задачу на потоки
//будет обрабатывать коллекцию не по порядку если так будет быстрее и если не быстрее то обработает как обычно
var factorials = numbers.AsParallel().Select(x => Factorial(x));

#ForAll
.ForAll(n => Console.WriteLine(n));
ForAll выполняет действие в каждом потоке для той части которая находится в нем
без ForAll происходит склейка данных в 1 потоке и потом действие для всех элементов

#AsOrdered()
public static ParallelQuery<TSource> AsOrdered<TSource>(this ParallelQuery<TSource> source)
.AsParallel().AsOrdered()
разделяем на потоки и потом выставляем в том порядке как было бы если бы не разделяли
#TODO

#AsUnordered()
разупорядочивание , если мы упорядочили но дальше какие то операции которые не требуют порядка, ускорит все


AsUnordered(). Делает упорядоченный запрос неупорядоченным; если упорядоченные результаты нужны только в первой части запроса, то этот метод позволит последующим этапам
запроса выполняться более эффективно.
#WithCancellation(). Указывает маркер отмены для использования с этим запросом. Маркеры отмены применяются в Parallel Extensions, позволяя отменять задачи в безопасной и
контролируемой манере.
#WithDegreeOfParallelism(). Позволяет указывать максимальное количество параллельных задач, используемых для выполнения запроса. Этот метод можно применять для ограничения количества используемых потоков во избежание перегрузки машины работой или
наоборот — увеличения числа потоков в случае, если запрос не задействует интенсивно... указать максимальное количество процессоров, выделяемых для обработки запроса
центральный процессор.
#WithExecutionMode(). Может применяться для принудительного выполнения запроса в
параллельном режиме, даже если Parallel LINQ считает, что запрос будет выполняться быстрее в однопоточном режиме.
когда PLINQ должен по умолчанию поддерживать последовательное выполнение, передать методу в качестве параметра признак ParallelExecutionMode.ForceParallelism.

#AsSequential()//запросить последовательное выполнение части параллельного запроса
#WithMergeOptions(). Позволяет подстраивать буферизацию результатов. Отключение буферизации сокращает промежуток времени перед возвращением первого результата, но также
уменьшает пропускную способность; полная буферизация обеспечивает наивысшую пропускную способность, но результаты не будут возвращаться до тех пор, пока запрос не выполнится полностью. Стандартная настройка является компромиссом между этими двумя случаями.




обработка ошибок 
catch (AggregateException ex)
{
    foreach (var e in ex.InnerExceptions)
    {
        Console.WriteLine(e.Message);
    }
}

отмена параллельной операции #cancel #CancellationTokenSource
CancellationTokenSource cts = new CancellationTokenSource();
 cts.Cancel();// установить токен для отмены
try{
numbers.AsParallel().WithCancellation(cts.Token)
}
catch(OperationCanceledException ex)
    {
        Console.WriteLine("Операция была прервана");
    }

foreach(var v in mass.AsParallel())//цикл прервется если в другом потоке Cancel();



#TODO  #IOrderedEnumerable<T> #ParallelQuery



#Range #ParallelEnumerable

ParallelEnumerable.Range() лучше чем -
Enumerable.Range().AsParallel();// но работают оба






#синхронизация


#Interlocked
тоже самое что и lock но быстрее и проще, для блокировки простых типов, аналог атомарных операций
CompareExchange()	Безопасно проверяет два значения на эквивалентность. Если они эквивалентны, изменяет одно из значений на третье
public static int Decrement(ref int location)	Безопасно уменьшает значение на 1
Exchange()	Безопасно меняет два значения местами
public static int Increment(ref int location)	Безопасно увеличивает значение на 1
//+возвращает это же число
int newVal = Interlocked.Increment(ref intVal);
Interlocked.Exchange(ref mylnt, 83);










#Monitor
Monitor.Enter(obj);
Monitor.Exit(rnd);
у monitor есть метод TryEnter-- он заставляет ждать определенное время а не бесконечность

//эти методы могут вызываться только из заблокированного фрагмента кода(блок lock например)
//временно блокирует поток но  освобождает заблокированный объект пока не продолжит выполнение
поток продолжит выполнение когда другой поток войдет в аналогичное состояние блокировки,  вызывает метод Pulse() или PulseAll()
obj-объект разблокировку которого ожидаем
//останавливает поток и заставляет ждать пока для obj не вызовется Pulse из другого потока
public static bool Wait(object obj) 
public static bool Wait(object obj, int миллисекунд_простоя)
//разрешает заблокировать уже заблокированный obj тому кто следующий в очереди
public static void Pulse(object obj)  возобновляется выполнение первого потока ожидающего своей очереди на получение блокировки
public static void PulseAll(object obj) сигнализирует о снятии блокировки всем ожидающим потокам

#lock преобразуется в monitor
private object obj = new object();
lock (obj)
{
   // синхронизированная область для obj
}
//преабразуется в
bool acquired = false;
object tmp = listLock; 
try
{
Monitor.Enter(tmp, ref acquired);//Запрос блокировки внутри блока try
list.Add("item");
}
finally
{
if (acquired)//Условное освобождение блокировки
{
Monitor.Exit(tmp);
}
}



if (Monitor.TryEnter(lockObject, 300)) {  
    try {  
        // Place code protected by the Monitor here.  
    }  
    finally {  
        Monitor.Exit(lockObject);  
    }  
}  
else {  
    // Code to execute if the attempt times out.  
}



#spinlock #SpinWait, #SemaphoreSlim и #CountdownEvent, #TODO




#Mutex #мьютекс

public Mutex()
public Mutex(bool initiallyOwned)//если true то им завладевает вызывающий поток

public bool WaitOne(); // блокирует выполнение вызывающего потока до тех пор, пока не станет доступным указанный мьютекс
public void ReleaseMutex() //освобождает

создание именованного(виден не только в текущем процессе)
public Mutex(bool initiallyOwned, string имя)// если true, то владение мьютексом запрашивается
public Mutex(bool initiallyOwned, string имя, out bool createdNew) // createdNew будет иметь логическое значение true, если владение мьютексомбыло запрошено и получено, и логическое значение false, если запрос на владениебыл отклонен


в потоке, получившем мьютекс, допускается вызывать несколько WaitOne() перед вызовом метода
ReleaseMutex(), все эти вызовы будут произведены успешно. => дополнительные вызовы метода WaitOne() не будут блокировать
поток, который уже владеет мьютексом. Но количество вызовов метода WaitOne()
должно быть равно количеству вызовов метода ReleaseMutex() перед освобождением мьютекса.











#семафор  #Semaphore

разрешает доступ к участку не 1 потоку а количеству которое указали в конструкторе
при блокировке -- при икременте ++, если 0 то ждет пока станет >0

public Semaphore(int initialCount, int maximumCount)
initialCount - количество первоначально доступных разрешений
maximumCount — максимальное значение данного счетчика, т.е. максимальное количество разрешений, которые может дать семафор.

см мьютекс
WaitOne()
//return  подсчитанное количество разрешений, существовавших до высвобождения
public int Release()
public int Release(int releaseCount)


именованный семафор
public Semaphore(int initialCount, int maximumCount, string имя)
public Semaphore(int initialCount, int maximumCount, string имя,
out bool createdNew)










#event
1 поток ждет пока вызовется событие в другом потоке
public #ManualResetEvent(bool initialState)//если true, то о событии первоначально уведомляется
WaitOne()//ждем если объект "не активен"
Set()//в другом потоке вызываем событие, "активирует" объект
 Reset()//после вызова события объект события делаем "не активным", для разблокировки надо снова вызывать Set()



public #AutoResetEvent(bool initialState)
все как у ManualResetEvent но метод WaitOne() после того как дождался очереди вызывает Reset()







#Barrier Вынуждает потоки ожидать появления всех остальных потоков в указанной точке, называемой барьерной
#CountdownEvent Выдает сигнал, когда обратный отсчет завершается
#ManualResetEventSlim Это упрощенный вариант класса ManualResetEvent
#SemaphoreSlim Это упрощенный вариант класса Semaphore






attr #TODO
блокировка всего метода экземпляра(this). Если же метод относится к типу static, то блокируется его тип
[MethodImplAttribute(MethodImplOptions.Synchronized)]
применять очень аккуратно перечитать как и тд





#Synchronization]
#[Synchronization]
тоже синхронизация но такое





#ReaderWriterLock
блокировка только на запись













#Lazy

Lazy<Library> library = new Lazy<Library>();
library.Value;//создаст объект только тут!











#рефлексия #reflection

#Nameof - строковое представление метода
WriteLine(nameof(person.Address.ZipCode)); // prints "ZipCode"

#typeof #GetType
получить тип
Type myType = typeof(className);
Type myType = object.GetType();
//1- полное название с namespace 2-генерить ли исключение если не найдено 3-учитывать ли регистр у 1 параметра
Type myType = Type.GetType("TestConsole.User", false, true);

Туре а1 = typeof (А<>)
Console.Write (a1.GetGenericArguments().Count())




myType.IsAbstract();
myType.IsClass();


Type: #MemberInfo
DeclaringType //тип класса или интерфейса в котором объявляется отражаемый член
MemberType //возвращает перечисление .тип члена. является ли член полем\методом\свойством\событием\конструктором
MetadataToken //
Name //имя файла
ReflectionType //тип отражаемого объекта

абстрактные методы
GetCustomAttributes // получить список спец атрибутов
IsDefined // проверить есть ли такой атрибут

ConstructorInfo[] GetConstructors() // получить список конструкторов
GetEvents()
GetFields()
GetMembers() //список членов
GetMethods()
GetProperties //список свойств

свойства только для чтения
Attribures //получить атрибуты
BaseType //получить непосредственный базовый тип 
FullName
IsAbstract
IsArray
IsClass
IsEnum
IsGenericType //если обобщенный
Namespace


var mth=GetMethods([BindingFlags fl1|BindingFlags f2|...]);//fl-перечисление которое сообщает какие именно методы нужны

BindingFlags.  //если указан 1 значение перечисление и метод не возвращается, указать еще через | но те которые не противоречат
DeclaredOnly: получает только методы непосредственно данного класса, унаследованные методы не извлекаются
Instance: получает только методы экземпляра
NonPublic: извлекает не публичные методы
Public: получает только публичные методы
Static: получает только статические методы


foreach(var i in mth){
//вызов метода
i.Invoke(reflect_obj,args)//reflect_obj - объект для которого будет вызываться метод
i.Invoke(null,args)//reflect_obj - static метод
i.Invoke(null,null)//reflect_obj - static метод, не передаем параметры
i.ReturnType.Name
i.Name
var prms=i.GetParameters();
foreach(var p in prms){
p.ParameterType.Name
p.Name
}
}

var cons=GetConstructors();
foreach(var i in cons){
(object)i.Invoke(args);
}


var instance = FormatterServices.GetUninitializedObject(Type a);//создать объект сам достанет конструктор и вызовет, даже если у него есть параметры





ОБОБЩЕНИЯ
typeof(List<>)//вернет List'1[Т] , где 1 -количество параметров
typeof(Dictionary<,>)//Dictionary'2[ТКеу,TValue]
typeof(List<X>)//List'1[System.Int32]
typeof(Dictionary<string,X>

//такое, все вернет true
string listTypeName = "System.Collections.Generic.List'1";
Type defByName = Type.GetType(listTypeName);
Type closedByName = Type.GetType(listTypeName + "[System.String]");
Type closedByMethod = defByName.MakeGenericType(typeof(string));
Type closedByTypeof = typeof(List<string>);
Console.WriteLine(closedByMethod == closedByName);
Console.WriteLine(closedByName == closedByTypeof);
Type defByTypeof = typeof(List<>);
Type defByMethod = closedByName.GetGenericTypeDefinition();
Console.WriteLine(defByMethod == defByName);
Console.WriteLine(defByName == defByTypeof);


обобщенные методы
public static void PrintTypeParameter<T>()
{
Console.WriteLine(typeof(T));
}
...
Type type = typeof(Snippet);
MethodInfo definition = type.GetMethod("PrintTypeParameter");
MethodInfo constructed = definition.MakeGenericMethod(typeof(string));
constructed.Invoke(null, null);









#Assembly
если есть exe\dll то все тоже самое можно делать с помощью этого

var a=Assembly.LoadFrom(string path)
a.GetTypes();
//дальше просто с помощью рефлексии можно делать что угодно





#LINQ
для параллельного выполнения см PLINQ
применяется для IEnumerable<T>  (реализованы как методы расширения в System.Linq.EnumeraЫe)

формирование запроса
var t=from n in nums where n>0 select n;
var t=nums.where(x1=>x1>0);
выполнение запроса
t.Count();
t.ToList();
//изменить nums
t.ToList();//другой результат


//результат-каждый элемент mass1 с каждым элементом mass2
from x1 in mass1
from x2 in mass2
select new{x1,x2};



если команда применяется к data типу, то она не вернет null (int[]).FirstOrDefault(x1=>)==null//не правильно тк null не вернется
что бы не 0 возвращалось 
int? nullableId = GetNonNullableInts().Cast<int?>().FirstOrDefault();


//#TODO хз можно ли так
var people = db.People.Where("it.Name LIKE @searchTerm", new ObjectParameter("searchTerm", searchTerm));
//не получилось вызвать like
from c in dc.Organization where #SqlMethods.Like(c.Hierarchy, "%/12/%") select *;



#Select: определяет проекцию выбранных значений, если написать Select(x1=>x1); то это будет удалено компилятором но только если запрос не состоит только из него
#Where: определяет фильтр выборки, если использовать несколько то результатом будет последовательность элементов в который ВСЕ удовлетворяют ВСЕМ предикатам



#OrderBy: упорядочивает элементы по возрастанию
#OrderByDescending: упорядочивает элементы по убыванию
#ThenBy: задает дополнительные критерии для упорядочивания элементов возрастанию
метод OrderBy() принимает на себя ответственность за первичный контроль над упорядочением, тогда как метод ThenBy() служит средством для выполнения одного или более последующих упорядочений. В LINQ to Objects метод
ThenBy() определен только как расширяющий для интерфейса IOrderedEnumerable<T>, который представляет собой тип, возвращаемый методом OrderBy() (и самим методом ThenBy(),
чтобы позволить дальнейшее выстраивание в цепочку).




#ThenByDescending: задает дополнительные критерии для упорядочивания элементов по убыванию
#Join: соединяет две коллекции по определенному признаку
#GroupBy: группирует элементы по ключу
#ToLookup: группирует элементы по ключу, при этом все элементы добавляются в словарь
#GroupJoin: выполняет одновременно соединение коллекций и группировку элементов по ключу
#Reverse: располагает элементы в обратном порядке
#All: определяет, все ли элементы коллекции удовлятворяют определенному условию
#Any: определяет, удовлетворяет хотя бы один элемент коллекции определенному условию
#Contains: определяет, содержит ли коллекция определенный элемент
#Distinct: удаляет дублирующиеся элементы из коллекции
#Except: возвращает разность двух коллекций, то есть те элементы, которые содератся только в одной коллекции
#Union: объединяет две однородные коллекции
#Intersect: возвращает пересечение двух коллекций, то есть те элементы, которые встречаются в обоих коллекциях
#Count: подсчитывает количество элементов коллекции, которые удовлетворяют определенному условию
#Sum: подсчитывает сумму числовых значений в коллекции
#Average: подсчитывает cреднее значение числовых значений в коллекции
#Min: находит минимальное значение
#Max: находит максимальное значение
#Take: выбирает определенное количество элементов
#Skip: пропускает определенное количество элементов
#TakeWhile: возвращает цепочку элементов последовательности, до тех пор, пока условие истинно
#SkipWhile: пропускает элементы в последовательности, пока они удовлетворяют заданному условию, и затем возвращает оставшиеся элементы
#Concat: объединяет две коллекции
#Zip: объединяет две коллекции в соответствии с определенным условием
Избыточные элементы в любой из входных последовательностей игнорируются. Операция Zip не поддерживается в запросах к базам данных.
int[] numbers = { 3, 5, 7 }; string[] words = { "three", "five", "seven", "ignored" }; 
nurnbers.Zip (words, (n, w) => n + "=" + w); 
приводит к получению последовательности со следующими элементами: 
З=three 
S=five 
7=seven


#First: выбирает первый элемент коллекции
#FirstOrDefault: выбирает первый элемент коллекции или возвращает значение по умолчанию
#Single: выбирает единственный элемент коллекции, если коллекция содердит больше или меньше одного элемента, то генерируется исключение-- генерируют исключение при наличии более одного совпадения
#SingleOrDefault: выбирает первый элемент коллекции или возвращает значение по умолчанию--генерируют исключение при наличии более одного совпадения
#ElementAt: выбирает элемент последовательности по определенному индексу
#ElementAtOrDefault: выбирает элемент коллекции по определенному индексу или возвращает значение по умолчанию, если индекс вне допустимого диапазона
#Last: выбирает последний элемент коллекции
#LastOrDefault: выбирает последний элемент коллекции или возвращает значение по умолчанию
#FindAll - вернет все элементы которые удовлетворяют условию(делегату pridicate который передаем)





#into

group val by val.column into val_ where val_.count()>2 select val_;  
select с. ToUpper () into upper //и дальше с upper что хотим делаем
from name in names 
group name.ToUpper() bу name.Length into grouping 
where grouping.Count() == 2 
select new { Assignee = grouping.Key, Count = grouping.Count() };




#let

from str in strs
let val=str.ToCharArray()

var query = from user in SampleData.AllUsers
let length = user.Name.Length
orderby length
select new { Name = user.Name, Length = length };

//такая конструкция транслируется в select
SampleData.AllUsers
.Select(user => new { user, length = user.Name.Length })
.OrderBy(z => z.length)
.Select(z => new { Name = z.user.Name, Length = z.length })




#linq #join

тк коллекция указанная справа буферизируется, а для левой организуется поток => справа желательно должна быть наименьшая коллекция

var phones = db.Phones.Join(db.Companies, // второй набор
        p => p.CompanyId, // свойство-селектор объекта из первого набора
        c => c.Id, // свойство-селектор объекта из второго набора
        (p, c) => new // результат
        {
            Name=p.Name, 
            Company = c.Name, 
            Price=p.Price
        });

from val_a in mass_a
join val_b in mass_b
on val_a = val_b;// = == equals












#деревья   #Expressions
используются для обращения к бд
см delegate

для деревьев есть встроенный визуализатор в студии


Expressions<Func<int,int,bool>> IsDel=(n,d)=>n==d;
Func<int,int,bool> t=IsDel.Compile();
t(10,20);



получение числа 5 с помощью построения дерева

Expression firstArg = Expression.Constant(2);
Expression secondArg = Expression.Constant(3);
Expression add = Expression.Add(firstArg, secondArg);
Func<int> compiled = Expression.Lambda<Func<int>>(add).Compile();
Console.WriteLine(compiled());








#TODO #linq #where #PredicateBuilder #Predicate #or

var query = collection.Where( c => c.A == 1 || c.B == 2 );
//ниже эквивалент
есть 2 версии обе с nuget
//using Mono.Linq.Expressions;  - не разобрался как работать
using Binbin.Linq;   - ставить не последние версии тк они не ставятся на .net framework 4.5-6, использование как ниже

var predicate = PredicateBuilder.False<Foo>();//False- в данном случае уже идет как первое условие=> если для такого предиката добавлять только через AND то он не вернет ничего=>если нужно OR то юзать false если AND то юзать true
 predicate = predicate.Or( f => f.A == 1 );
 if (allowB)
 {
    predicate = predicate.Or( f => f.B == 1 );
 }

 var query = collection.Where( predicate );










#xml #linq
#XAttribute

var users = new XElement("users",
SampleData.AllUsers.Select(user => new XElement("user",
new XAttribute("name", user.Name),
new XAttribute("type", user.UserType)))
);
Console.WriteLine(users);
// Вывод
<users>
<user name="Tim Trotter" type="Tester" />
</users>



#XElement #XmlSampleData
XElement root = XmlSampleData.GetElement();
var query = root.Element("users").Elements().Select(user => new   // первую часть можно переписать так root.Descendants("user")
{
Name = (string) user.Attribute("name"),
UserType = (string) user.Attribute("type")
});



from project in root.Element("projects").Elements()
from subscription in project.Elements("subscription")
select subscription


root.Element("projects").Elements().Elements("subscription")

Ниже перечислены осевые методы, используемые непосредственно для запрашивания одиночного узла, каждый из которых возвращает подходящую реализацию IEnumerable<T>:
• Ancestors
• AncestorsAndSelf
• Annotations
• Attributes
• Descendants
• DescendantsAndSelf
• DescendantNodes
• DescendantNodesAndSelf
• Elements
• ElementsAfterSelf
• ElementsBeforeSelf
• Nodes











#linq #rx
#Range #IObservable
#Observable.Range() создание наблюдаемого диапазона
. Каждый раз, когда какой-то наблюдатель подписывается па
диапазон, этому наблюдателю будут выдаваться числа при вызове им метода OnNext(), за которым следует OnCompleted().

“холодный” наблюдаемый объект: он остается бездействующим до тех пор, пока какой-либо наблюдатель не подпишется на него, после чего будет выдавать значения этому отдельному наблюдателю. Если вдобавок
подпишется еще один наблюдатель, он будет видеть другую копию диапазона. Это совсем не похоже на обычное событие вроде щелчка на кнопке, когда множество наблюдателей может быть
подписано на одну и ту же действительную последовательность значений, и значения могут выдаваться независимо от того, существуют какие-то наблюдатели или нет. (В конце концов, щелкать
на кнопке можно даже при отсутствии присоединенных к ней обработчиков событий.) Последовательности подобного рода носят название “горячих” наблюдаемых объектов


не существует методов
Reverse() и OrderBy()

var observable = Observable.Range(0, 10);
observable.Subscribe(x => Console.WriteLine("Received {0}", x),
e => Console.WriteLine("Error: {0}", e),
() => Console.WriteLine("Finished"));


var numbers = Observable.Range(0, 10);
var query = from number in numbers
where number % 2 == 0
select number * number;
query.Subscribe(Console.WriteLine);

















#namespace
//можно объявить несколько с одинаковым именем(сложатся в 1), 
namespace name{}
//можно вложить namespace в namespace
namespace name{
namespace name1{}}
//2 способ объявить вложенность
namespace name.name1{}



#using #примитивы 
using name_namespace;
using псевдоним=имя;
using new_name=name_namespace.classname;
using static System.Console;//будут доступны все статическое класса


using(var tmp=){
//раскладывается как блок try с .Dispose() в finally части
}//вызовется метод disposing, если его нет- ошибка


#::
если есть одноименный класс(например) в нескольких пространствах имен и мы подключаем оба то можно устранить неопределенность
name_namespace1::class_name val=new name_namespace1::class_name ();
//из глобального пространства имен
#global
для global нельзя определить псевдоним
global::class_name val=new global::class_name ();


если определено пространство имен Win и класс Win
и необходимо сослаться на пространство имен то Win::val






#препроцессор #предпроцессор

#define
#define name_ind//объявить
#undef name_ind//удалить

#region//просто для удобства
#endregion

#pragma

#error name error//прервать компиляцию и показать ошибку


#if name_ind
..
#else
..
#elif
..
#endif//относится только к if



#line
#warning name error//показать предупреждение при компиляции






#public
публичный
#private
частный
при наследовании, наследуется но к нему есть доступ только через методы которые тоже были унаследованы(this.val не получится) и у которых был доступ к этому полю, если мы их не переопредляем
#protected
тоже самое что private но при наследовании мы можем использовать(this.val)
#internal
доступно только в пределах сборки
protected internal: совмещает функционал двух модификаторов. Классы и члены класса с таким модификатором доступны из текущей сборки и из производных классов.
private protected: такой член класса доступен из любого места в текущем классе или в производных классах, которые определены в той же сборке.



#immutable 
Это значит, что данные, хранящиеся в переменной, не могут быть изменены. При этом  значение переменной может быть изменено - путём отказа от использования старых данных, которые могут быть изменены.
 Оригинальные данные остаются в памяти, а новые значения создаются вновь, в новой области памяти. Пример тип String.




#partial
можно разбить что либо на несколько кусков
оба должны быть с 1 модификатором доступа
если спользуются обобщения то ограничения для параметров должны быть во всех версиях
но можно в 1 версии указать интерфейс а в 2 класс-родителя




partial class a{
math1}
partial class a{
math2}


если применили к методу
то можно не реализовывать(при вызове такого метода(не реализованного) не произойдет вообще ничего, он будет проигнорирован)
ограничения- обязательно возвращают void, не могут быть virtual, в них нельзя использовать out, не может быть модификатора доступа
partial void meth();
partial void meth(){}








#is 
вернет bool если можно\нельзя привести тип
(bool)(val is classname)


#TODO не совсем понял/ доступно с 17 студии
if(x is int i)


#as
//приведет тип если можно и если нет то вернет null
(val is classname)











#вспомогательный класс
// c# 1
Все члены являются статическими (кроме закрытого конструктора).
• Класс унаследован напрямую от object(неявно), явных родителей нет
• Обычно состояние не поддерживается, если только не задействовано кеширование или шаблон с единственным экземпляром.
• Видимые конструкторы отсутствуют.
• Класс является запечатанным, если разработчик не забыл сделать это.

//c# 2++
объявлен как static
• Он не может быть объявлен как абстрактный (abstract) или запечатанный (sealed), хотя неявно является тем и другим.
• Невозможно указывать любые интерфейсы для реализации.
• Нельзя указывать базовый тип.
• Невозможно включать любые нестатические члены, в том числе конструкторы.
• Нельзя определять любые операции.
• Невозможно включать любые члены protected или protected internal.













#деконструкторы #Deconstruct
class Person
{
public void Deconstruct(out string name, out int age)
    {
        name = this.Name;
}}
(string name, int age) = person;


#Индексаторы #[]
могут быть перегружены
class Library
{
    Book[] books;
 public Book this[int i, int j]{}
 public Book this[int index]
    {
        get
        {
            return books[index];
        }
        set
        {
            books[index] = value;
        }
    }






#обработка #ошибки
#try #catch #finaly #throw


try{}
catch{

throw new Exception();//выбросить новое исключение
}
catch(Exception e){
throw e;//пробросить исключение дальше, но  свойство StackTrace исключения больше не будет отражать исходную ошибку
throw;//пробросить исключение дальше
}
catch(Exception e)if(e.Source==""){
}



#Exception


свойства Exception
Message - характер ошибки
StackTrace - строка в вызовами стека из за которых случилась ошибка
TargetSite - объект-метод сгенерировавший исключение
InnerException - внутренее исключение
методы
ToString

конструкторы
public Exception()
public Exception(string сообщение)
public Exception(string сообщение,Exception внутреннее исключение)
protected Exception(System.Runtime.Serialization.SerializationInfo информация,System.Runtime.Serialization.StremingContext контекст)


создание своих исключений
class name:Exception{
//нужно просто реализовать все конструкторы
public name():base(){}
//....
}


#cath #try #finally
должны ловить исключения от частного к общему(сначала идет последний ребенок, потом его родитель, потом Exception)








#Сериализация #serialize #serealize
[Serializable]
class Person
{
[NonSerialized]
    public string accNumber;
//точно также можно делать и с массивом и тд
 // создаем объект #BinaryFormatter
            BinaryFormatter formatter = new BinaryFormatter();
            // получаем поток, куда будем записывать сериализованный объект
            using (FileStream fs = new FileStream("people.dat", FileMode.OpenOrCreate))
            {
                formatter.Serialize(fs, person);
            }
 
            // десериализация из файла people.dat
            using (FileStream fs = new FileStream("people.dat", FileMode.OpenOrCreate))
            {
                Person newPerson = (Person)formatter.Deserialize(fs);
            }

#SOAP. #SoapFormatter
https://metanit.com/sharp/tutorial/6.3.php

#XML. #XmlSerializer
https://metanit.com/sharp/tutorial/6.4.php

#JSON. #DataContractJsonSerializer

using Newtonsoft.Json;
data = JsonConvert.DeserializeObject<AllData>(upload_text);
//mass ---- var g= JsonConvert.DeserializeObject<test_t[]>(json);
str=JsonConvert.SerializeObject(section);
// через потоки

DataContractJsonSerializer jsonFormatter = new DataContractJsonSerializer(typeof(Person[]));
 
            using (FileStream fs = new FileStream("people.json", FileMode.OpenOrCreate))
            {
                jsonFormatter.WriteObject(fs, people);
            }
 
            using (FileStream fs = new FileStream("people.json", FileMode.OpenOrCreate))
            {
                Person[] newpeople = (Person[])jsonFormatter.ReadObject(fs);

            }


если не известен класс но знаем поля
using Newtonsoft.Json;  //JSON.NET
using Newtonsoft.Json.Linq;
var o = JObject.Parse(json);
var accessToken = (string)o["access_token"]; // "13a85707de16fbb1c290250872f30e0b"
var errorCode = (int)o["error"]["code"];     // 0
var duration = TimeSpan.FromSeconds((double)o["duration"]);


разрешить ответ на get запрос #json
return Json(data, JsonRequestBehavior.AllowGet);




#расширение #расширения #extension #extends

Любой совместимый метод экземпляра всегда будет иметь преимущество над расширяющим методом - даже когда параметры расширяющего метода дают более точное соответствие по типам. 
если 2 метода с одинаковой сигнатурой то вызывать как обычный static метод
 если один расширяющий метод имеет более специфичные аргументы, то ему будет отдаваться предпочтение
//создать static class 
//подключить это namespase к месту где будет использовать этот метод

при методе расширения можно вызвать расширяющий метод на ссылке которая == null!!! тк она передает параметром
если это ломает логику то нужно генерить NullReferenceException


public static class StringExtension
{
//this перед тем параметром к которому это будет применяться
    public static int WordCount(this string str, char c)
    {}
((string)str).WordCount((char)c);















#delegate #делегаты
-объект инкапсулирующий методы

1. Событие нельзя запустить вне класса, в котором оно было объявлено=> больше защищенность 
2. События могут быть помещены в интерфейс.(делегаты только как свойства могут быть помещены, вроде)
3. И событие и делегат можно объявить полем класса, но в отличие от делегата, событие не может быть локальной переменной метода 

Делегаты являются неизменяемыми, так что при использовании операции+= или -= фактически создается новый экземпляр делегата, который присваивается существующей переменной.
если делегат содержит только 1 метод то это обычный делегат, если методов больше то это уже multicast делегат 
Если делегат имеет возвращаемый тип  вернется значение из последнего вызванного метода. возвращаемые значения Предшествующих методов  отбрасываются.
Все типы делегатов : System.MulticastDelegate: System.Delegate. Операции+, -, += и -=, транслируются в статические методы #Combine и Remove класса System.Delegate.


delegate возвращаемый_тип name_del(type param1,type param2)

можно закинуть любой метод(статика \функцию\метод экземпляра и что угодно)
могут быть обобщенными

name_del name_del_obj=new name_del([meth]);//объявление
name_del name_del_obj=meth;//объявление, сокращение для new a(meth)

name_del_obj=meth;//убрать все методы и добавить новый
name_del_obj+=meth;//добавить новый метод, добавлять также можно и делегат, сахар для метода Combine
name_del_obj-=meth;//удалить новый метод, удалять также можно и делегат, сахар для метода Remove

name_del_obj();//сокращение для name_del_obj.Invoke();

если параметр передавать через ref то он будет передаваться в каждый метод и измененный после него идти в след метод

его можно объявить в классе(не создать объект а именно объявить)
delegate void Dl(); 
delegate void D2(); 
Dl dl = Methodl; 
D2 d2 = dl; / / Ошибка на этапе компиляции 
Тем не менее, следующее разрешено: 
D2 d2 = new D2 (dl); 
Экземпляры делегатов считаются равными, если они имеют один и тот же целевой метод (методы). Для групповых делегатов важен порядок следования целевых методов.



#combine
при null трактуется как пустой делегат
вернет новый делегат-результат, старые не могут изменяться
Delegate.Combine(del1,del2);//лучше использовать +=
Delegate.Remove(delSource,delValue);//лучше использовать -=


 #standart #стандартные
//стандартные делегаты не надо объявлять они уже есть

#Action
public delegate void Action<T1,T2,....T16>(T obj1,T obj2... T obj16)
Action<int, int> op=(a,b)=>{return;};

#Predicate
Predicate<int> isPositive =  (int x)=>{ return x > 0; };

#Func
//последний параметр всегда выходной
Func<T> isPositive
Func<T1, T2,... T16,TResult>
Func<int> isPositive=()=>{return 1;}
 Func<int, int> retFunc =( x)=>{return x;}





#ковариантность #контрвариантность #контравариантность для делегатов
delegate X name_del(Y param)

Y:X

X meth1(X o);
Y meth2(Y o);

name_del delobj;

#ковариантность
возвращаемый тип может быть наследником
delobj=meth2;


#контрвариантность #контравариантность
тип параметра может быть базовым
delobj=meth1;
//чет вроде не правильно delobj(X);
delobj(Y);//Y:X
тк тк мы потом будем передавать в метод который будет в делегате происзодное от базового(X) и он приведется к базовому(к X)


#Инвариантность
 позволяет использовать только заданный тип


#вариантность для обобщенных делегатов
#ковариантность
out-- выходное значение
delegate T name_del<out T>()
можно присвоить метод где параметр будет T или ребенком T
T не может использоваться в парметрах методов


#контрвариантность
in-- входные параметры
delegate bool name_del<in T>(T obj)
можно присвоить метод где параметр будет T или родителем T
и объект T не может возвращаться





#Converter<,>
#TODO - скит 434







#анонимные #anonim #anonymous

//только для чтения
var f=new{x1,x2,x3.Id};//x1 x2 Id
var f=new{val1=x1,val2=x2};


коллекция анонимных типов(можно через dynamic)
// create the first list by using a specific "template" type.
var list = new [] { new { Name="", Phones=new[] { "" } } }.ToList();
// clear the list.  The first element was just an example.
list.Clear();
// start adding "actual" values.
list.Add(new { Name = "Krishna", Phones = new[] { "555-555-5555", "666-666-6666" } });










#анонимные #функции  #anonim #anonymous #function  #=> #лямбда

если пишется в типе значения то нельзя использовать this
доступ к базовому члену внутри анонимного метода можно получить через base

name_del delobj=delegate{/*код функции*/};
delobj=delegate(type val){/*код функции*/};
особенность такой штуки в том что можно присвоить объекту делегата который 
принимает параметры такой анонимный метод без параметров(можно использовать когда параметры не нужны или например нужна просто заглушка)


через лямбды
скобки нужны если несколько параметров, параметров нет, или если явно указываем тип параметра
если есть =>{} то невозможно создать expression и называется лямбда оператор если нет то лямбда выражение

delobj=(type val)=>{/*код функции*/};
delobj=(val)=>{/*код функции*/};
delobj=val=>{/*код функции*/};
delobj=()=>{/*код функции*/};
{
delobj=(type val)=>/*код функции в 1 строку без return*/;
delobj=val=>val+2;
}
del myDelegate = x => x * x;  

// #древо выражений #деревья #дерево
 #Expression<del> myET = x => x * x; 

в /*код функции*/
можно использовать return
{#замыкание #захват
можно захватывать внешние переменные по ссылке, которые не будут уничтожены пока не уничтожатся все методы которые захватывают+ не будет других ссылок на нее
захватывают значения по ссылки, если захватить итерационную переменную в foreach то с версии 5 все будет хорошо, в ранних версиях все делегаты будут ссылаться на 1 и туже переменную
если переменная создается в цикле и захватывается - то это как бы 1 переменная но захватываются РАЗНЫЕ экземпляры


пример
method(){
int t=10;
delobj=delegate{t++;}
}
delobj();//увеличит на 1 и станет 11
delobj();//увеличит на 1 и станет 12
}




#event  #TODO
см delegate

могут быть объявлены в интерфейсах, 
могут быть абстрактными(только если без аксессоров),
могут быть virtual и sealed
event делегат_события имя_события;
delegate void Hand();
event Hand EventName;


События могут быть виртуальными, переопределенными, абстрактными или запечатанными. Они также могут быть статическими.

С# обеспечивает безопасность в отношении потоков во время обновления делегата, если это переопределить то будет не потокобезопасно
event Hand EventName{
add{
priceChanqed += value; 
}
remove{
priceChanqed -= value; 
}
}



EventName evt+=method;
if(evt!=null)
evt();



рекомендованная структура событий(уже есть предопределенные делегаты) #EventHandler #EventsArgs
class MyEventsArgs:EventsArgs{}
EventsArgs.Empty

delegate void Delname(object source,MyEventsArgs arg)

public event EventHandler<MyEventArgs> someEvent;//без обобщения если EventsArgs не переопределяем






#перегрузка

#operator #перегрузка #операторов
при перегрузке не должны изменяться те объекты, которые передаются в оператор через параметры
class Counter
{
public static возвращаемый_тип operator оператор(параметры)
{  }
public static Counter operator +(Counter c1, Counter c2)

зависимые друг от друга(противоположные) надо перегружать оба сразу
public static bool operator (>||<)(Counter c1, Counter c2) 
public static Counter operator ++(Counter c1)
{
    return new Counter { Value = c1.Value + 10 };
}
для if()
public static bool operator true(Counter c1)
  public static bool operator false(Counter c1)  

логические
public static bool operator (|,!,&)(Counter c1, Counter c2) 

укороченные логические
нужно перегрузить true false
нужно перегрузить(возможно) !
нужно перегрузить |, & - возвращаемый тип -объект для которого if(объект) -true
public static Counter operator (|)(Counter c1, Counter c2) 





#приведение #типов #перегрузка
#explicit-явное (type)obj  #implicit-не явное
public static implicit|explicit operator Тип_в_который_надо_преобразовать(исходный_тип param){
return new Тип_в_который_надо_преобразовать(param);
}



#интерфесы #interface 
все внутри без уровня доступа
при реализации, методы от интефейса не должны быть override
interface IName{
//свойство не будет самореализуемым(надо будет в классе хотя бы скопировать то что объявлено тут), get\set тоже без уровня доступа
int nm{
get;
set;
}

return_type this[type val]{
get;set;
}

void methodname(){}
}

явная реализация метода
class g: IName{
void IName.methodname1(){}//без уровня доступа
public void methodname(){}

}
g g_=new g();
IName g1=new g();
g_.methodname1();//нельзя, надо сначала упаковать
g1.methodname1();


class g: IName{
void virtual methodname1(){}//разрешаем переопределение для наследников
void virtual IName.methodname1(){}//так нельзя
}


public interface IUndoable { void Undo();
public class TextBox : IUndoabe
{
void IUndoabe.Undo()=> Console. WriteLine ( "TextBox. Undo") ; 
}
public class RichTextBox TextBox, IUndoabe
{
public new void Undo()=> Console.WriteLine ("RichTextBox.Undo"); //при вызове из класса вызовется этот метод, при вызове из интерфейса тоже
}




#ковариантность #контрвариантность
можно применить(указать ключевые слова in out) только интерфейсам или делегатам(нельзя к классам и тд даже если они как бы подходят) - это ограничение clr

любое преобразование которое ЭТО использует - это ссылочное преобразование, те после преобразования возвращается таже самая ссылка, преобрзование не создает новй объект
из за того что преобразование ссылочное, так делать нельзя
• IEnumerable<int> в IEnumerable<object> — упаковывающее преобразование:
• IEnumerable<short> в IEnumerable<int> — преобразование типа значения;
• IEnumerable<string> в IEnumerable<XName> — преобразование, определяемое пользователем.



#ковариантность
out-- выходное значение
interface IMyInt<out T>{
//можно T применять только для возвращаемого типа, нельзя использовать для ограничения(where X:T)
//может ПРИСВОИТЬ ссылку на любой класс производный от T или сам T
T GetObj();
}
//при реализации интерфейса ключевое слово не указывается(ни в class ни в методах)
class Myclass<T>:IMyInt<T>{}
но указывается при наследовании только в ребенке интерфейса
interface Myclass<out T>:IMyInt<T>{}

class a{}
class b:a{}
IMyInt<a> alp=new Myclass<a>();//доступно в любом случае
alp=new Myclass<b>();//доступно из за ковариантности
ВЫВОД- позволяет засунуть в объект родителя объект ребенка но только эта иерархия не на сам класс а на обобщенный тип, и этот обобщенный тип применяется только к return type методов


#контрвариантность
in-- входные параметры
interface IMyInt<in T>{

void GetObj(T obj);
}
//при реализации интерфейса ключевое слово не указывается(ни в class ни в методах)
class Myclass<T>:IMyInt<T>{}
но указывается при наследовании только в ребенке интерфейса
interface Myclass<in T>:IMyInt<T>{}

class a{}
class b:a{}
IMyInt<a> alp=new Myclass<a>();//доступно в любом случае
IMyInt<b> bet=new Myclass<b>();//доступно в любом случае
bet=new Myclass<a>();//доступно из за контрвариантности
bet=alp;//доступно из за контрвариантности
ВЫВОД- позволяет засунуть в объект ребенка объект родителя но только эта иерархия не на сам класс а на обобщенный тип, и этот обобщенный тип применяется только к параметрам методов
в метод можем передать родителя T












#IEquatable IEquatable<T> - Equals
для сравнения(определения равенства)



#IComparable - CompareTo
IComparable<T>
для сравнения(для определения порядка следования)


#Sort()
//не обобщенная версия надо приводить к типам
public interface IComparable
{
    int CompareTo(object o);
}
//обобщенная, приводить к типу не надо
IComparable<Person>
 public int CompareTo(Person p)
    {}

Меньше нуля. Значит, текущий объект должен находиться перед объектом, который передается в качестве параметра
Равен нулю. Значит, оба объекта равны
Больше нуля. Значит, текущий объект должен находиться после объекта, передаваемого в качестве параметра

PeopleComparer--- класс которые реализует интерфейс #IComparer<Person>
Array.Sort(new[]Person, new PeopleComparer());




#сравнение #равенство #IComparer
IComparer<Person>
interface IComparer
{
    int Compare(object o1, object o2);
}

если первый объект больше второго, то возвращается число больше 0, если меньше - то число меньше нуля; если оба объекта равны, возвращается ноль.




//правильная реализация отдельного класса для сравнения #Comparer


public static class PartialComparer
{
public static int? Compare<T>(T first, T second)
{
return Compare(Comparer<T>.Default, first, second);
}
public static int? Compare<T>(IComparer<T> comparer,
T first, T second)
{
int ret = comparer.Compare(first, second);
return ret == 0 ? new int?() : ret;//почему тут при ==0 возвращается null не понимаю
}
public static int? ReferenceCompare<T>(T first, T second)
where T : class
{
return first == second ? 0
: first == null ? -1
: second == null ? 1
: new int?();
}
}










#TODO
#IEqualityComparer 
что то типа IComparer











#ICloneable #clone()
//сам интерфейс
public interface ICloneable
{
    object Clone();
}
//реализация через #MemberwiseClone--поверхностное копирование(если есть ссылки внутри то останутся ссылками на те же объекты)
public object Clone()
    {
        return this.MemberwiseClone();
    }



#IConvertible
преобразования типов



#IFormatProvider #IFormattable #TODO





#IObservable<T> #IObserver<T>
паттерн #наблюдатель
IObserver<T> - тот кто подписывается
Subscribe - подписать
OnNext отправить данные наблюдателю
OnError отправить сообщение об ошибке
OnCompleted - указывает на то что наблюдаемый объект прекратил отправку сообщений








#abstract


В интерфейсе все методы (свойства и т.д.) абстрактны и не имеют реализации. В абстрактном классе некоторые методы могут быть реализованы. 
В интерфейсе члены не могут иметь модификатора видимости (все они являются public по умолчанию), а в абстрактном классе члены могут иметь модификатор видимости.


Абстрактный класс — класс, который имеет хотя б 1 абстрактный метод; его обозначают abstract.
Интерфейс — такой же абстрактный класс,только в нем нет свойств и не определены тела у методов.

Таким образом, функционально любой интерфейс является абстрактным классом, но абстрактный класс не является интерфейсом.

в абстр классе пишем override для абс метода, для интерфейса нет
Основные отличия интерфейса и абстрактного класса
•	абстрактный класс может содержать свойства
•???	интерфейс не содержит свойств(полей)
•	абстрактный класс может содержать тела методов
•	интерфейс не содержит тел методов, только их объявление
•	абстрактный класс наследуется (etxends)
•	интерфейс реализуется (implements)
•	наследник имеет только одного родителя (абстрактный класс)
•	наследник может реализовывать методы нескольких интерфейсов
•	наследник не обязан содержать реализацию методов абстрактного класса-родителя(в таком случае сам должен быть абстрактным)
•	наследник обязан содержать реализацию всех методов реализуемого интерфейса




















#ref 
таким модификатором нельзя пометить необязательные параметры

ref local

int x = 5;
ref int xRef = ref x;

будет ссылаться на элемент массива
ref int numberRef = ref Find(4, numbers);
static ref int Find(int[] numbers)
{
return ref numbers[0];//будет ссылаться на элемент
}


#out
обязательно должна быть установлена, в целом применяется как ref
в новой версии можно объявить так(при вызове метода)
meth(out var x,(int)10);






#in
работает как ref, но гарантирует, что эту ссылку не поменяют. Ещё одно отличие — можно задавать значение по умолчанию
public void Test(in string s = "")
Test();
string test = "42";
Test(in test);
Test(in "42");//так нельзя







#обобщения  #обобщение #<>
могут быть обобщенные классы, интерфейсы, структуры,методы,делегаты
хранятся в обобщенной форме , а по мере необходимости создаются конкретные экземпляры классов cl<int> cl<string> - разные классы


ограничения:
свойства, операторы, индексаторы и события не могут быть обобщенными, но могут использовать в обобщенном классе с параметрами обобщенного типа этого класса
к обобщенному методу нельзя применять модификатор extern
типы указателей нельзя использовать в аргументах типа

class BaseTypeOfDynamic : dynamic
• class DynamicTypeConstraint<T> where T : dynamic
• class DynamicTypeConstraint<T> where T : List<dynamic>
• class DynamicInterface : IEnumerable<dynamic>
Но следующие объявления будут допустимыми:
• class GenericDynamicBaseClass : List<dynamic>
• IEnumerable<dynamic> variable;



если в обобщенном классе есть поле static то оно свое для каждого типа класса(cl<int> cl<string>-разные, cl<string> cl<string> -одно поле)

параметр обобщенного типа можно сравнивать(== и =!) только с null, но если есть ограничения(например class) то можно и друг с другом


при перегрузке типов
Обобщенные типы могут быть перегружены на основе количества параметров типов, так что
допустимо определять МуТуре, МуТуре<Т>, MyType<T,U>, МуТуре<Т, U, V> и так далее, причем в рамках одного и того же пространства имен. При перегрузке имена параметров типов во
внимание не принимаются — важно только их количество. Эти типы не связаны друг с другом
за исключением имени — например, стандартное преобразование одного типа в другой не существует. 


class Transaction<T> where T: Account
{
    public T FromAccount { get; set; }
}
class Transaction<T> 
{
    public T FromAccount { get; set; }
}
Transaction<Account> transaction1 = new Transaction<Account>
        {
}

//ограничение- должен быть тип значения
//ограничение должно быть 1 по порядку
class Account<T> where T : struct
{}
//ограничение- должен быть ссылочный тип
//ограничение должно быть 1 по порядку
class Transaction<T> where T : class
{}

//есть конструктор без параметров
//должно идти последним по порядку, использовать можно только конструктор без параметров, нельзя использовать с ограничением типа значения
//нельзя указать конструктор с параметрами
class Transaction<T> where T : new()
{}

class Transaction<U, V>
        where U : Account<int>
        where V : struct
{}
class Transaction<U, V>
        where U : V{}
public static void Transact<T>(T acc1, T acc2, int sum) where T : Account<int>{}

public void nameMeth<T>(int g,T t) where T:class{}
//оба вызова норм, тип он сам подставит
nameMeth<string>(10,"");
nameMeth(10,"");

если одновременное ограничение типа на класс и на интерфейс то сначала указывается класс


delegate void name<T>();
name<int> nameObj=;



при обобщенном интерфейсе
ограничения интерфейса нужно продублировать ограничениями в класс который его реализует


при перегрузке не должно быть так, тк n<int,int>- все сломает
class n<T,V>{
void nnn(V a);
void nnn(T a);
}






where T:VAL__
VAL__ - не может быть типом значения, запечатанным классом(sealed)(string), или : Object, Enum,ValueType,Delegate






#default

obj=default(тип);
при обобщении
obj=default(T);










#exception #exeption #try #catch #finally
после try обязательно catch или finally или оба
более "узкие\специфичные" обработчики должны идти сначала
перехватить можно не все исключение вроде, #TODO какие если true
try{
throw new Exception("Длина строки больше 6 символов");
}
catch(... ex){
ex.Message
}
catch(Exeption ex) when (y==0){
ex.Message
}
catch{
throw;//пробрасываем исключение дальше
}
finally{
//выполняется всегда
}


-----------------------------



-----------------------------


#error #точка #останова #pdb 
не работает точка останова  удалить все файлы в проекте .pdb




#image #uploadImage #img

отображение из байтов 
 <div class="div_image_standart" style="background:url( data:image/jpeg;base64,@Convert.ToBase64String(a.Data)) no-repeat;background-size: cover;">
        </div>

растянет очень криво но ничего не обрежет, и пустых мест не будет
<div id="main_tag_one_img_id_@a.Id" class="class_image_standart" style="background:url( data:image/jpeg;base64,@Convert.ToBase64String(a.Data)) no-repeat;background-size: 100% 100%;"> 
</div>

растянет не криво, но только по 1 краю(пропорции остаются), есть пустые места
<div id="main_tag_one_img_id_@a.Id" class="class_image_standart" style="background:url( data:image/jpeg;base64,@Convert.ToBase64String(a.Data)) no-repeat"> 
</div>
.class_image_standart{
    background-position: center;
    background-size: contain;
}

<img src="data:image;base64,@System.Convert.ToBase64String(Model.Image)" />


загрузка картинок на сервер сюда код формы метод для преобразования картинок в байты и тд
@using (Html.BeginForm("Add_new_image", "Home", FormMethod.Post, new { enctype = "multipart/form-data" }))
                    {
                        @Html.Hidden("from", "Personal_record")
                        @Html.Hidden("for_what", "main_img")

                        <input type="file" name="uploadImage[0]" />
                            <input type="submit" class="submit" value="Поделиться" />
                    }



#ajax

var files;
    $('input[type=file]').change(function () {
        files = this.files;
    });
var data = new FormData();
        $.each(files, function (key, value) {
            data.append('uploadImage', value);
        });

        data.append('obj.Text','this is test text');

        $.ajax({
            url: '/Physic/Create',
            type: 'POST',
            data: data,
            cache: false,
            dataType: 'json',
            processData: false, // Не обрабатываем файлы (Don't process the files)
            contentType: false, // Так jQuery скажет серверу что это строковой запрос
            success: function (respond, textStatus, jqXHR) {

                var ttt = 10;
            }
        });











 public ActionResult AddMemePerson(string id_user, HttpPostedFileBase[] uploadImage,string text)
{  
var list_img_byte = Get_photo_post(uploadImage);
}

public static List<byte[]> Get_photo_post(HttpPostedFileBase[] uploadImage)
        {

            /* сохранение картинок как файл ...
              HttpPostedFileBase image = Request.Files["fileInput"];
            
            if (image != null && image.ContentLength > 0 && !string.IsNullOrEmpty(image.FileName))
            {
                string fileName = image.FileName;
                image.SaveAs(Path.Combine(Server.MapPath("Images"), fileName));
            }
             
             * */
            List<byte[]> res = new List<byte[]>();
            if (uploadImage != null)
            {
                foreach (var i in uploadImage)
                {
                    try
                    {
                        byte[] imageData = null;
                        // считываем переданный файл в массив байтов
                        using (var binaryReader = new BinaryReader(i.InputStream))
                        {
                            imageData = binaryReader.ReadBytes(i.ContentLength);
                        }
                        // установка массива байтов
                        res.Add(imageData);
                    }
                    catch
                    {}
                }

            }

            return res;
        }








#uploadfile #upload #file
//получить текст файла
FunctionName(HttpPostedFileBase file) 
{ 
string result = new StreamReader(file.InputStream).ReadToEnd(); 
}


#image #byte #img

//image from byte
public static Image byteArrayToImage(byte[] byteArrayIn)
        {
            MemoryStream ms = new MemoryStream(byteArrayIn);
            Image returnImage = Image.FromStream(ms);
            return returnImage;
        }




#image to byte
//baseFormat = (Image)imageIn.RawFormat
public static byte[] ImageToByteArray(System.Drawing.Image imageIn, ImageFormat baseFormat)
        {
            using (var ms = new MemoryStream())
            {
                //var encoder = GetEncoderInfo("image/jpg");
                imageIn.Save(ms, baseFormat);//System.Drawing.Imaging.ImageFormat.Jpeg 
                return ms.ToArray();
            }
        }




#resize
//меняем размер картинки

 private static Image ResizeImage(int newSize, Image originalImage)
        {
            if (originalImage.Width <= newSize)
                newSize = originalImage.Width;

            var newHeight = originalImage.Height * newSize / originalImage.Width;

            if (newHeight > newSize)
            {
                // Resize with height instead
                newSize = originalImage.Width * newSize / originalImage.Height;
                newHeight = newSize;
            }

            return originalImage.GetThumbnailImage(newSize, newHeight, null, IntPtr.Zero);
        }








#io  #file #load #byte

#потоки 

#stream
методы
close
flush - заставляет вывести все, если не юзнуть то данные выводятся блоками
readByte
Read
seek  - установить положение в потоке
writebyte
write

свойства
canread
canseek
canwrite
length - длина потока
position текущее положение доступно и для чтения и для записи
readtimeout
writetimeout

#BufferedStream:stream - заключает в оболочку байтовый поток и добавляет буферизацию

#StreamReader #StreamWriter #TODO


#UnmanagedMemoryStream:stream - байтовый поток который использует неупраляемую память для хранения

!!!символьные потоки
#TextReader #TextWriter
методы TextReader
...
close
int peek - получает следующий символ из потока но не удаляет его, возвращает -1 если нет доступных символов
#OpenText(filename); создает объект TextReader

методы TextWriter
close
flush



вывод текст
в streamWriter: TextWriter заключается filestream(или другой наследник stream)
public streamWriter(Stream)
public streamWriter(string путь)
public streamWriter(string путь,bool append)//если true то в конец



#BinaryReader #BinaryWriter
для работы с байтами, лучше использовать как оболочку для другого байтового потока

void write
--
bool readboolean()
...



#MemoryStream:stream - байтовый поток который использует память для хранения
конструкторы 
MemoryStream(byte[] buf)
можно засунуть в оболочку и использовать как обычный поток

#StringReader:textReader StringWriter:textWriter - тоже что и MemoryStream но для хранения в строке
конструкторы
StringReader(string buf)
StringWriter()//не указываем строку в которой будет хранить но можно ее получить методом ToString()



!!!!
#FileStream:stream - байтовый поток для ввода вывода
конструкторы
FileStream(string путь, FileMode режим)
FileStream(string путь, FileMode режим, FileAccess доступ) - ограничивает доступ, только для чтения и тд
new FileStream(FilePathOld, FileMode.Open, FileAccess.Read, FileShare.Read)//если нужно читать в нескольких потоках


#File
некоторые методы находятся в FileInfo, если что можно поискать там
copy(string исход,string новый)//если не существует
copy(string исход,string новый,bool overwrite)//перезапишит

exist (string путь)
GetLastAccessTime (string путь)


#GetFiles #DirectoryInfo
new DirectoryInfo(@"C:\").GetFiles();//получить файлы





#io  #file #load #byte #console

Console.In-экземпляр TextReader  Console.Out -TextWriter Console.Error -TextWriter

методы
static void #SetIn(TextReader поток)
static void #SetOut(TextWriter поток)
static void #SetError(TextWriter поток)
//в TextReader можно обернуть вообще другой поток



#readKey
static consoleKeyInfo ReadKey()
static consoleKeyInfo ReadKey(bool intercept) - если true то не отобразится на консоли

#consoleKeyInfo
структура
char KeyChar  введенный символ
ConsoleKey Key значение из перечисления ConsoleKey
ConsoleModifiers Modifiers  значение из перечисления ConsoleModifiers , модификаторы которые бали нажаты ctrl и тд








//открыть файл и вернуть байты
 public static byte[] FileToByteArray(string fileName)
        {
            byte[] buff = null;
            FileStream fs = new FileStream(fileName,
                                           FileMode.Open,
                                           FileAccess.Read);
            BinaryReader br = new BinaryReader(fs);
            long numBytes = new FileInfo(fileName).Length;
            buff = br.ReadBytes((int)numBytes);
            return buff;
        }



#Console

Beep: подача звукового сигнала
Clear: очистка консоли
WriteLine: вывод строки текста, включая символ возврата каретки (то есть с переводом на новую строку)
Write: вывод строки текста, но без символа возврата каретки
ReadLine: считывание строки текста со входного потока
Read: считывание введенного символа в виде числового кода данного символа. С помощью преобразования к типу char мы можем получить введенный символ
ReadKey: считывание нажатой клавиши клавиатуры (ConsoleKeyInfo key= Console.ReadKey();)
Кроме того, класс Console обладает свойствами, которые позволяют управлять консолью. Некоторые из них:
BackgroundColor: цвет фона консоли
ForegroundColor: цвет шрифта консоли
BufferHeight: высота буфера консоли
BufferWidth: ширина буфера консоли
Title: заголовок консоли
WindowHeight и WindowWidth: высота и ширина консоли соответственно














#относительный #relative путь к файлу на сервере #HostingEnvironment
File.ReadAllText(HostingEnvironment.MapPath($"~/tsqlscripts/{i}.txt"))












#com 

#exel

var арр = new Application { Visible = false };
Workbook workbook = app.Workbooks.Add();
Worksheet worksheet = app.ActiveSheet;
int row = 1;
foreach (var product in Products)
{
worksheet.Cells[row, 1].Value = product.Name;
worksheet.Cells[row, 2].Value = product.Price;
row++;
}
workbook.SaveAs(Filename: "demo.xls",
FileFormat: XlFileFormat.xlWorkbookNormal);
app.Application.Quit();


#Ексель 
using  Microsoft.Office.Interop.Excel

var арр = new Application { Visible = true };//Открыть Excel с активным рабочим листом
арр.Workbooks.Add();
Worksheet worksheet = (Worksheet) app.ActiveSheet;
//Создать диапазон можно было бы и с помощью единственного вызова метода Range["А1:Т1]
Range start = (Range) worksheet.Cells[1, 1];//Определить начальную и конечную ячейки
Range end = (Range) worksheet.Cells[1, 20];//Определить начальную и конечную ячейки
worksheet.Range[start, end].Value = Enumerable.Range(1, 20).ToArray();//Заполнить диапазон значений [1, 20]
 








#doc #word


Application арр = new Application { Visible = true };
app.Documents.Add();
Document doc = app.ActiveDocument;
Paragraph para = doc.Paragraphs.Add();
para.Range.Text = "Thank goodness for C# 4";
doc.SaveAs(FileName: "test.doc",
FileFormat: WdSaveFormat.wdFormatDocument97);
doc.Close();
app.Application.Quit();











#python
ScriptEngine engine = Python.CreateEngine();
engine.Execute("print 'hello, world'");
engine.ExecuteFile("HelloWorld.py");











#* #unsafe #указатель

тип * название;
указатель может указывать на что угодно
int * p,q ;//создание 2х указателей
&val;//получить адрес
*ref;//получить значение по указателю

unsafe- пометить блок кода как не безопасный(можно применять указатели)
unsafe static void Main(){}

#fixed
fixed(int*=&val){
//val не будет удалена сборщиком мусора КАК МИНИМУМ пока не выполнится блок кода
}

fixed тип имя_буфера[размер]
создание массива фиксированного значения, можно указать только в структуре


арифметика с указателями
++ -- + - 
int* p;
p++;//увеличит на 4 тк int-4байта

если переменные связанны(допустим указатели на разные участки массива) то их можно сравнивать(и получить результат который что то будет значить)
== < >

int[] mass;
//одно и тоже
int*p=mass;
int*q=mass[0];

p[1], p[10] //работает тк указывает на массив


указатель на указатель
int** p;//**p получить значение

массивы
int*[]mass=new int*[3];
mass[0]=;//установить значение
*mass[0];//получить значение




#sizeof
sizeof(type)//узнать размер типа данных

#stackalloc
только при объявлении локальных переменных
память выделяется из кучи
выделенная память таким обрзом не очищается сборщиком мусора
тип *p=stackalloc тип[размер]








#inthernet #HttpWebRequest #parse #uri #url #интернет #парсинг #www  #internet #web
#HttpWebRequest req = (HttpWebRequest) #WebRequest.Create("http://www.McGraw-Hill.com");
#HttpWebResponse resp = (HttpWebResponse) req. #GetResponse();
Stream istrm = resp. #GetResponseStream();
//получаем html страницы
resp.Close();
//---короче
// Сначала создать объект запроса типа WebRequest по указанному URI.
#WebRequest req = WebRequest.Create("http://www.McGraw-Hill.com");
// Затем отправить сформированный запрос и получить на него ответ.
WebResponse resp = req.GetResponse();

#WebClient лучше использовать вместо Request Response если нужно просто получить инфу по ссылке и все
public byte[] DownloadData(string address) //получить результат по ссылке
public string DownloadString(string address) //результат по ссылке
public Stream OpenRead(Uri address) //поток четения
public Stream OpenWrite(Uri address) 
DownloadFile(uri, fname); //по ссылке записать все в файл, можно в ссылке указать как код на страницу так и код на файл


Uri sample = new Uri("http://HerbSchildt.com/somefile.txt?SomeQuery");
Uri-
public string Host { get; } Получает имя сервера
public string LocalPath { get; } Получает локальный путь к файлу
public string. PathAndQuery { get; }
public int Port { get; }
Получает абсолютный путь и строку запроса
Получает номер порта для указанного протокола. Так, для протокола HTTP номер порта
равен 80
public string Query { get; } Получает строку запроса
public string Scheme { get; } Получает протокол





#HttpClient обновленный тип для #WebClient #TODO не понятно откуда взялась: text
using (HttpClient client = new HttpClient())
{
await client.GetStringAsync("http://csharpindepth.com");
string str = text.Length.ToString();
}












#html #<> #скобки #><
 <p> будет выглядеть как &lt;p&gt;



#graph #graphic
http://htmlbook.ru/blog/grafiki-i-diagrammy

https://google-developers.appspot.com/chart/interactive/docs/gallery
 























#html5
#атрибуты #attr #atribute

accesskey: определяет клавишу для быстрого доступа к элементу
class: задает класс CSS, который будет применяться к элементу
contenteditable: определяет, можно ли редактировать содержимое элемента
contextmenu: определяет контекстное меню для элемента, которое отображается при нажатии на элемент правой кнопкой мыши
dir: устанавливает направление текста в элементе
draggable: определяет, можно ли перетаскивать элемент
dropzone: определяет, можно ли копировать переносимые данные при переносе на элемент
hidden: скрывает элемент
id: уникальный идентификатор элемента. На веб-странице элементы не должны иметь повторяющихся идентификаторов
lang: определяет язык элемента
spellcheck: указывает, будет ли для данного элемента использоваться проверка правописания
style: задает стиль элемента
tabindex: определяет порядок, в котором по элементам можно переключаться с помощью клавиши TAB
title: устанавливает дополнительное описание для элемента
translate: определяет, должно ли переводиться содержимое элемента

target для <a>  -- позволяет по разному открывать ссылку(фрейм окно и тд)


#tags

<b>: выделяет текст жирным
<del>: зачеркивает текст
<i>: выделяет текст курсивом
<em>: выделяет текст курсивом, в отличие от тега <i> носит логическое значение, придает выделяемому тексту оттенок важности
<s>: зачеркивает текст
<small>: делает текст чуть меньше размером, чем окружающий
<strong>: выделяет текст жирным. В отличие от тега <b> предназначен для логического выделения, чтобы показать важность текста. А <b> не носит характера логического выделения, выполняет функции только форматирования
<sub>: помещает текст под строкой
<sup>: помещает текст над строкой
<u>: подчеркивает текст
<ins>: определяет вставленный (или добавленный) текст
<mark>: выделяет текст цветом, придавая ему оттенок важности


#спойлер с названием и стрелкой #список
 <details>
            <summary>Флагманы 2015</summary>
</details>


внутренняя ссылка на странице #href #link #якорь 
<a href="#paragraph1">Параграф 1</a>
<h2 id="paragraph1">Параграф 1</h2>


#border #fieldset #legend #рамка
выделит красиво в 1 блок(линией по краям) и legend будет заголовком(НА линии и перекрывает ее)
 <fieldset>
                <legend>Введите данные:</legend>
</fieldset>


.article > p{}
только на те элементы которые в .article не включая блоки которые вложены еще в какой то блок 
<div class="article">
            <p>меняется</p>
            <div class="content">
                <p>не меняется</p>
            </div>


.article + p{}   для элемента p который следует за .ar
//возможна комбинация из нескольких +

 h2~div { color: red; }
<h2>Заголовок</h2>
        <p>Аннотация</p>
        <div>
            <p>red</p>
        </div>
        <div>
            <p>red</p>
        </div>




#градиенты #gradient
обязательно юзать -moz-  -webkit-
с левого верхнего угла в противоположный перелив из черного в белый
background-image: linear-gradient(top left,black,white);
20% 80%--- это положение точки, вроде как ширина
background-image: linear-gradient(left, #ccc, red 20%, red 80%, #ccc);
повторяющийся градиент
background-image: repeating-linear-gradient(left, #ccc 20px, red 30px, rgba(0, 0, 126, .5) 40px);

градиент для круга
белый-центр и черный края
background-image: radial-gradient(white, black);
для элипса
radial-gradient(ellipse, white, black);

задать центр   -- 25% от левой границы и 30 от верхней
background-image: radial-gradient(25% 30%, circle, white, black);

closest-side: градиент распространяется из центра только до ближайшей к центру стороне элемента. То есть градиент остается внутри элемента
closest-corner: ширина градиента вычисляется по расстоянию из его центра до ближайшего угла элемента, поэтому градиент может выйти за пределы элемента.
farthest-side: градиент распространяется из центра до самой дальней стороны элемента
farthest-corner: ширина градиента вычисляется по расстоянию из его центра до самого дальнего угла элемента
background-image: radial-gradient(25% 30%, circle farthest-corner, white, black);



#transform
ширина\высота
  transform: scale(2, 0.5);
transform: scale(0.5);
угол
  transform: rotate(30deg);
зеркальное отражение
transform: scaleX(-1);

перемещение
transform: translate(offset_X, offset_Y);
наклон(квердат станет паралелограммом)
  transform: skew(30deg, 10deg);


точка относительно которой трансформация
transform-origin: left top;
left top: левый верхний угол элемента
left bottom: левый нижний угол элемента
right top: правый верхний угол элемента
right bottom: правый нижний угол элемента



#transition
transition-delay: 500ms;
 transition-timing-function: ease-in-out;
linear: линейная функция плавности, изменение свойства происходит равномерно по времени
ease: функция плавности, при которой анимация ускоряется к середине и замедляется к концу, предоставляя более естественное изменение
ease-in: функция плавности, при которой происходит только ускорение в начале
ease-out: функция плавности, при которой происходит только ускорение в конце анимации
ease-in-out: функция плавности, при которой анимация ускоряется к середине и замедляется к концу, предоставляя более естественное изменение
cubic-bezier: для анимации применяется кубическая функция Безье




#keyframes   #frame #function
 animation-name: название_анимации;
animation-iteration-count: 3;  /*количество повторений, может быть   infinite*/
animation-fill-mode: forwards;   /*после выполнения оставить стиль на 100% */
animation-duration: 5s;
animation-direction: alternate;    /*анимация идет 0%->100%  100->0  0->100*/

@keyframes название_анимации {
    from {/*можно 0% вместо from*/
        /* начальные значения свойств CSS */
    }
    to {/*можно 100% вместо to*/
        /* конечные значения свойств CSS */
    }
}











#псевдоклассы #css
 a:not(.blueLink) { color: red; }
все а кроме . сделает красными

//выбирает элемент, который является единственным элементом определенного типа в контейнере.
span:only-of-type{
         
            color: green;   /* зеленый цвет */
        }


: #enabled {   если не установлен атрибут  disabled
: #checked  если установлен атрибут checked          // :checked + span {
 : #valid и : #invalid стилизуют элементы формы в зависимости от того, проходят они валидацию или нет
input:invalid 
            input:valid {
стилизуют элементы формы в зависимости от того, попадает ли их значение в определенный диапазон
: #in-range 
            : #out-of-range {
<input type="number" min="1" max="100" value="10" id="age" name="age"/>


: #optional                Не установлен required
            : #required {  установлен атрибут required





#nth-child позволяет стилизовать каждый второй, третий элемент, только четные или только нечетные элементы и т.д.
tr:nth-child(odd){} для нечетных элементов, 
tr:nth-child(even){} четных элементов в
tr:nth-child(3)  под номером 3
tr:nth-child(2n+1) { background-color: #bbb; } к каждой второй нечетной строке.

tr:nth-last-child(2) {    тоже самое,с конца




first-child: представляет элемент, который является первым дочерним элементом
:#last-child: представляет элемент, который является последним дочерним элементом
:#only-child: представляет элемент, который является единственным дочерним элементом в каком-нибудь контейнере
:#only-of-type: выбирает элемент, который является единственным элементом определенного типа (тега) в каком-нибудь контейнере
:#nth-child(n): представляет дочерний элемент, который имеет определенный номер n, например, второй дочерний элемент
:#nth-last-child(n): представляет дочерний элемент, который имеет определенный номер n, начиная с конца
:#nth-of-type(n): выбирает дочерний элемент определенного типа, который имеет определенный номер
:#nth-last-of-type(n): выбирает дочерний элемент определенного типа, который имеет определенный номер, начиная с конца



::#first-letter: позволяет выбрать первую букву из текста
::#first-line: стилизует первую строку текста
::#before: добавляет сообщение до определенного элемента
::#after: добавляет сообщение после определенного элемента
::#selection: выбирает выбранные пользователем элементы     работает например для выделенного текста


input[type="text"]{
.link[href="http://apple.com"]{
a[href^="https://"]{        начинается с подстроки
img[src$=".jpg"]{           заканчивается
a[href*="microsoft"]{           есть вхождения


В этом случае вне зависимости от наличия других селекторов с большим количеством баллов к ссылкам будет применяться красный цвет, определяемый первым стилем.
a {font-size: 18px; color: red !important;}




#hover #visible #visibility #display
если bl2 находится в bl1
div.bl1:hover div.bl2{
    top:0;
}

для соседних
.block1:hover + .block2 h1 { color: red;}


для как бы не соседних
<div class="one">Name</div>
<div class="two">Surname</div>
<div class="three">Opps</div>
.three {
    color: orange;
}

.one:hover + .two + .three {
    color: green;
}


для не соседних но при условии что они в 1 блоке
 .block1:hover ~ .block2 h1 { color: red;}
<div>
  <div class=block2><h1>нет</h1></div>
  <div class=block1>Проведите надо мной</div>
  <div class=block2><h1>да</h1></div>
</div>




#inline #inline-block #display #div_inline_block #divinlineblock
display: inline-block; 50% каждый див что бы уместились в строку —-»»> просто между блоками удалить все пробелы и переносы строк. т.е. закончился предыдущий div, и сразу же после закрывающего тега нужно вставлять следующий открывающий.
div.div_inline_block {
    display: inline-block;
    vertical-align: top;
}






#Спецсимволы #html #img #image
#стандарт #css #символ #картинка
https://html5book.ru/specsimvoly-html/
css content:'\2718';

#github
content: "\f09b";
content: "\f003"; // почтовый конвернт
content: "\f16c";// #stack #overflow
content: "\f019";//значек загрузки




#shadow
box-shadow: 0 0 10px rgba(0,0,0,0.5);


#кэш #кэширование
[OutputCache(Duration=30, Location= OutputCacheLocation.Downstream)]
        public string Index()
        {
CacheProfle: определяет конфигурацию кэширования
Duration: продолжительность кэширования контента в секундах. Важно оптимально подобрать временной отрезок, так как если задать большое значение, то пользователи будут работать практически со статичными данными, а при очень маленьком значении будет слишком часто обновление кэша, что нивелирует преимущества его использования
Location: место, где размещается кэшированный контент
NoStore: если данное значение равно true, в ответе в заголовке Cache-Control устанавливается флаг no-store, что указывает браузеру, что контент не надо сохранять
SqlDependency: определяет зависимость между кэшем и таблицой в бд
VaryByCustom: указывает произвольное значение, по которому будут определяться различные версии кэшированных данных
VaryByHeader="user-agent": указывает на набор заголовков, по которым будут определяться различные версии кэшированных данных
VaryByParam="title;id": указывает на параметры строки запроса или параметры переданных форм, по которым будут определяться различные версии кэшированных данных

Any: контент кэшируется как на клиенте, так и на прокси-сервере и в выходном кэше сервера
Client: контент кэшируется на клиенте
Downstream: контент кэшируется как на клиенте, так и на прокси-сервере. Выходной кэш сервера не используется
None: для заголовка Cache-Control устанавливается значение no-cache, что значит, что контент не будет нигде кэшироваться
Server: контент кэшируется только в выходном кэше сервера
ServerAndClient: контент кэшируется на клиенте и в выходном кэше сервера




mvc 
плагин для добавление автоматической пагинации(переключение страниц, нумерация страниц, Постраничный вывод)
#пагинация
https://metanit.com/sharp/mvc5/17.7.php



js-html
JqGrid пакет для добавления таблицы со стриницами поиском  редактированием тд
https://metanit.com/sharp/mvc5/17.3.php








Диалоговые окна и CRUD-интерфейс
реазилация partial action для окна(редактирование элемента например)
https://metanit.com/sharp/mvc5/17.2.php


jQuery UI и Autocomplete
для подгрузки блжайших совпадений при поиске
https://metanit.com/sharp/mvc5/17.1.php









обратная связь с клиентом  #SignalR #hubs

NuGet библиотеку Microsoft ASP.NET SignalR
если в проекте нет класса Startup(там где web.config, не в папках) 
то добавить его если есть то дописать(или дописать в конец файла Startup.Auth.cs 
в метод ConfigureAuth класса Startup тк он вызывается если указана строка  ConfigureAuth(app); 
в файле Startup)  app.MapSignalR();

using Microsoft.Owin;
using Owin;
[assembly: OwinStartup(typeof(SignalRMvc.Startup))]
namespace SignalRMvc
{
    public class Startup
    {
        public void Configuration(IAppBuilder app)
        {
            app.MapSignalR();
        }
    }
} 

класс для хранения пользователей
public class User
{
    public string ConnectionId { get; set; }
    public string UserId { get; set; }
}
Теперь добавим в проект новую папку. Назовем ее Hubs. В ней будут находиться хабы нашего приложения. В эту папку добавим новый item(SignalR Hub Class (v2)) ChatHub.cs
//[HubName("stockTickerMini")]  можно изменить имя хаба
 public class ChatHub : Hub
    {
        static List<UserForHub> Users = new List<UserForHub>();
//объявляем методы к которым будем обращаться 
public void Send(int id)
        {
 Clients.Group(groupName).MethodOnClient(id_dialog);//id_dialog- может быть объектом класса, в таком случае конвертится в json и отправляется, на стороне клиента в функцию зайдет сразу объектом а не json строкой
}
 public void JoinToHub()
        {
//добавляем группу если ее нет и добавляем в нее юзера
 Groups.Add(Context.ConnectionId, groupName);
//удаляем
Groups.Remove(Context.ConnectionId, roomName);
}

// Отключение пользователя
        public override System.Threading.Tasks.Task OnDisconnected(bool stopCalled)
        {
            var item = Users.FirstOrDefault(x => x.ConnectionId == Context.ConnectionId);
            if (item != null)
            {
                Users.Remove(item);
                var id = Context.ConnectionId;
                //Clients.All.onUserDisconnected(id);
            }

            return base.OnDisconnected(stopCalled);
        }
}

HTML(в конце боди лучше)
<script src="~/Scripts/jquery-1.10.2.min.js"></script>
    <!--Ссылка на библиотеку SignalR -->
    <script src="~/Scripts/jquery.signalR-2.2.0.min.js"></script>
    <!--Ссылка на автоматически сгенерированный скрипт хаба SignalR -->
    <script src="~/signalr/hubs"></script>
    <script src="~/Scripts/util.js"></script>


JS
//методы на стороне сервера нужно вызывать с маленькой буквы
создаем файл util.js

$(function () {
    // Ссылка на автоматически-сгенерированный прокси хаба
    var chat = $.connection.chatHub;

// Объявление функции
    chat.client.MethodOnClient = function (id_dialog) {
}

// Открываем соединение
    $.connection.hub.start().done(function () {
//так вызывается любой метод на сервере
        chat.server.joinToHub();
}
});





полезное:
//id пользователя в Hube
Context.ConnectionId
// Посылаем сообщение текущему пользователю
                Clients.Caller.onConnected(id, userName, Users);
// Посылаем сообщение всем пользователям, кроме текущего
                Clients.AllExcept(id).onNewUserConnected(id, userName);
//всем
Clients.All.addMessage(name, message);



Вызов метода на всех клиентах: Clients.All.addMessage(name, message);
Вызов метода только на текущем клиенте, который обратился к серверу: Clients.Caller.addMessage(name, message);
Вызов метода на всех клиентах, кроме того, который обратился к серверу: Clients.Others.addMessage(name, message);
Вызов метода только у клиента с определенным id: Clients.Client(Context.ConnectionId).addMessage(name, message);
Вызов метода на всех клиентах, кроме клиента с определенным id: Clients.AllExcept(connectionId).addMessage(name, message);
Вызов метода на всех клиентах указанной группы: Clients.Group(groupName).addMessage(name, message);
Вызов метода на всех клиентах указанной группы, за исключением клиента, у которого id - connectionId: Clients.Group(groupName, connectionId).addMessage(name, message);
Вызов метода на всех клиентах указанной группы, за исключением обратившегося к серверу клиента: Clients.OthersInGroup(groupName).addMessage(name, message);


включение логов хабов на стороне клиента
$.connection.hub.logging = true;





для того что бы можно было использовать обычный класс как hub class нужно в него передать(ресурсоемкий процесс)
IHubConnectionContext<dynamic> clients
получить - GlobalHost.ConnectionManager.GetHubContext<StockTickerHub>().Clients














https://metanit.com/sharp/mvc5/16.2.php


#бандлы #bundle/head подлючение скриптов
@Styles.Render("~/Content/css")
    @Scripts.Render("~/bundles/modernizr")
более удобное подключение группы скриптов, объединяет несколько скриптов в 1 файл и ускоряет работу и js.js.min делает
в файле BundleConfig.cs
bundles.Add(new ScriptBundle("~/bundles/jquery").Include(
                        "~/Scripts/jquery-{version}.js"));
параметр {version} является заменителем для любого символьного обозначения версии скрипта
"~/Scripts/jquery.validate*" с помощью знака звездочки заменяет остальную часть строки.
Однако само объявление бандлов в файле BundleConfig.cs еще не подключает автоматически их в проект. Для этого в файле Global.asax прописывается соответствующая директива:
protected void Application_Start()
    {
        //..............................................
        BundleConfig.RegisterBundles(BundleTable.Bundles);
    }


бандлы CDN
загрузка скриптов с сайтов
лучше всего проверять загрузился ли скрипт
public static void RegisterBundles(BundleCollection bundles)
        {
            bundles.UseCdn = true;   //включаем поддержку CDN
            // добавляем адрес нужной библиотеки в какой-нибудь сети CDN
            var jqueryCdnPath = "http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.7.1.min.js";
            bundles.Add(new ScriptBundle("~/bundles/jquery",
                        jqueryCdnPath).Include(
                        "~/Scripts/jquery-{version}.js"));




Минификация
при развертывании приложения ускоряет работу за счет бандлов, делает js.js.min и объединяет файлы
для включения надо отключить #режим #отладки
 В файле web.config меняем на false
<configuration>
  <!--------------------------------------->
  <system.web>
    <authentication mode="None" />
    <compilation debug="true" targetFramework="4.5" />
    <httpRuntime targetFramework="4.5" />






для формирования из строки с русскими буквами строку без них(кодирование) (например для запроса на сервер через ссылку)
#encodeURIComponent
(декодирование)
#decodeURIComponent

ActionName

хэш пароля
https://ru.stackoverflow.com/questions/545944/%D0%9A%D0%B0%D0%BA-%D0%B7%D0%B0%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BF%D0%B0%D1%80%D0%BE%D0%BB%D0%B8

фильтры атрибуты для методов #attr
RequireHttps-заставляет использовать https
[OutputCache (Duration=360)]-кэширует данные 360 секунд для увеличение работы с бд
ValidateAntiforgeryToken- применять к методам авторизации регистрации




#InternalsVisibleTo
#TODO
[assembly:InternalsVisibleTo("Friend_")]//Friend_ - название дружественной сборки
public class









отправка #статуса #кода #StatusCode 
#404 #200 #500
  return new #HttpStatusCodeResult(404);

Response.StatusCode = (int)HttpStatusCode.BadRequest; 
Response.StatusCode = 404;
return new EmptyResult();
return Content(ex.Message);

return HttpNotFound();
 return new HttpUnauthorizedResult();//#401 - нет доступа


[AllowAnonymous]/ [Authorize]
#controller
string controller_name = ViewContext.RequestContext.RouteData.Values["controller"].ToString(); ;
















#AJAX


#AJAX #js #jquery #img #image #post #httppost #uploadImage

html

обычная форма

<form id="commentForm" class="form" method="post"  enctype="multipart/form-data">
    <fieldset>
        <input type="text" id="text" placeholder="text"  name="text">
        <input id="id_user" type="text" placeholder="id_user:"  name="id_user">
        
        <input id="uploadImage" type="file"  name="uploadImage">
        
    </fieldset>
    <input id="button" class="submit" type="submit" value="Отправить" name="submit">
</form>



js



jQuery(document).ready(function () {
        $("#commentForm").submit(function () { return false; });

        $("#button").on("click", function () {

                $(".submit").replaceWith("<div class='form_dscr'><p class='sending'>Отправка...</p></div>");
            //получаем форму
                var form = document.forms.commentForm;

                var formData = new FormData(form);

                var xhr = new XMLHttpRequest();
                xhr.open("POST", "/SocialNetwork/AddMemePerson");

                xhr.onreadystatechange = function () {
                    if (xhr.readyState == 4) {
                        if (xhr.status == 200) {
                            //при возврате actionresult и тд, вернет -"<html>"
                            var data = xhr.responseText;
                            
                        }
                    }
                };

                xhr.send(formData);

        });
    });


тоже самое но вообще без html и jquery
(это не тестил)

function getXmlHttp() {
    var xmlhttp;
    try {
      xmlhttp = new ActiveXObject("Msxml2.XMLHTTP");
    } catch (e) {
    try {
      xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
    } catch (E) {
      xmlhttp = false;
    }
    }
    if (!xmlhttp && typeof XMLHttpRequest!='undefined') {
      xmlhttp = new XMLHttpRequest();
    }
    return xmlhttp;
  }
  function summa() {
    var a = document.getElementById("a").value; // Считываем значение a
    var b = document.getElementById("b").value; // Считываем значение b
    var xmlhttp = getXmlHttp(); // Создаём объект XMLHTTP
    xmlhttp.open('POST', 'test.php', true); // Открываем асинхронное соединение
    xmlhttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); // Отправляем кодировку
    xmlhttp.send("a=" + encodeURIComponent(a) + "&b=" + encodeURIComponent(b)); // Отправляем POST-запрос
    xmlhttp.onreadystatechange = function() { // Ждём ответа от сервера
      if (xmlhttp.readyState == 4) { // Ответ пришёл
        if(xmlhttp.status == 200) { // Сервер вернул код 200 (что хорошо)
          document.getElementById("summa").innerHTML = xmlhttp.responseText; // Выводим ответ сервера
        }
      }
    };
  }






#get #js
без jquery и ajax

var x = new XMLHttpRequest();
x.open("GET", "/echo/json/", true);
x.onload = function (){
    alert( x.responseText);
}
x.send(null);












можно проверить является ли запрос ajax
!Request.IsAjaxRequest()

#ajax #post #jquery #form #get
оба возвращают сам объект(не надо определять из json)
$.post( "/Info/Add_section", { name: "John", time: "2pm" })
  .done(function( data ) {
    alert( "Data Loaded: " + data );
  });

var dt={'Head':'sdf','parrent_sec_id':'sss'};
            $.ajax({
                url: "/Info/Add_section",
                data:dt,
                
                success: OnComplete_Add_section,//функция
                error: function () { alert("ошибка загрузки"); },
                // shows the loader element before sending.
                beforeSend: function () { alert("before"); },
                // hides the loader after completion of request, whether successfull or failor.             
                complete: function () { alert("after"); },
                type: 'POST', dataType: 'json'//'html'
            });

#TODO взять из диплома go_ajax функцию




//проверенный post



объявление объекта для отправки
var dt = {
        'id': id
    };
//можно так
 var dt = {
            'forms[0].ActionId': 10,
            'forms[1].ActionId':20,
'forms1.ActionId'
        };




    $.ajax({
        url: "/SocialNetwork/SendComment",
        data: dt,
        success: function (data) {
            ShowCommentsRecord(id, false)
        },
        error: function () {
            alert("ошибка загрузки");
            PreloaderAction(false);

        },
        beforeSend: function () { PreloaderAction(true); },
        complete: function () {
            PreloaderAction(false);

        },
        type: 'POST', dataType: 'json'//html
    });






из js отправить #get запрос
$('#results').load('@Url.Action("BookSearch", "Home")?name='+name)



$.ajax({
  url: url,
  data: data,
  success: onAjaxSuccess,
  dataType: dataType
});
function onAjaxSuccess(data)
{
  // Здесь мы получаем данные, отправленные сервером и выводим их на экран.
  alert(data);
}









@using (Ajax.BeginForm("BookSearch", new AjaxOptions
{
    UpdateTargetId = "results",
    OnBegin = "OnBegin",
    OnFailure = "OnFailure",
    OnSuccess = "OnSuccess",
    OnComplete = "OnComplete"
}))
{
    <input type="submit" value="Поиск" />
}



Confirm="Выполнить AJAX-запрос?" - настраивает сообщение о подтверждении отправки запроса на сервер. Если пользователь не подтвердит, то запрос не будет отправлен

HttpMethod - устанавливает метод (Get или Post), с помощью которого выполняется запрос

InsertionMode - устанавливает, как полученные результаты будут отображаться на странице. Может принимать одно из трех значений перечисления InsertionMode: InsertAfter, InsertBefore и Replace(по умолчанию).

LoadingElementId="loading"- устанавливает id элемента html-страницы, который будет отображаться во время запроса. Обычно это какая-нибудь анимация, которая дает знать, что некоторая работа выполняется в фоновом режиме

LoadingElementDuration=1000 - устанавливает количество миллисекунд, через которое появится элемент, указанный в параметре LoadingElementId

OnBegin - задает обратный вызов перед отправкой запроса. Соотносится с событием beforeSend библиотеки jQuery 
function OnBegin() {



OnComplete - задает обратный вызов, который вызывается после выполнения запроса (как удачного, так и неудачного). Соотносится с событием complete библиотеки jQuery
function OnComplete(request, status) {


OnFailure - задает обратный вызов, который вызывается после неудачного выполнения запроса. Соотносится с событием error библиотеки jQuery
 function OnFailure(request, error) {


OnSuccess - задает обратный вызов, который вызывается после удачного выполнения запроса. Соотносится с событием success библиотеки jQuery
function OnSuccess(data) {



UpdateTargetId - указывает на id элемента, в котором будут выводиться результаты запроса

Url - устанавливает адрес Url сервера, на который отправляется запрос. Установив данное свойство, можно не использовать название имя контроллера и его действие в качестве параметров Ajax.BeginForm














#TODO
фильтры и не только это не обрабатывал и многое не понял  https://metanit.com/sharp/mvc5/8.1.php          -https://metanit.com/sharp/mvc5/8.9.php



возможно получение параметров в методе https://metanit.com/sharp/mvc5/9.5.php


поставщик значений
	https://metanit.com/sharp/mvc5/9.4.php



!!!!!!!!!!!! https://metanit.com/sharp/mvc5/7.1.php    указывать тип для редактирования





#attr #atribute #атрибуты

название  с суффиксом Attribute

[AttributeUsage(AttributeTargets.All)]//то к чему может применяться
public class NameAttribute: Attribute{



public NameAttribute(){}
}
//если в классе есть нестатическое поле или свойство доступное для записи то его можно использовать как именованный параметр не указывая в конструкторе
[NameAttribute(позиционные параметры,именованные параметры)]
public class test{}

//получить атрибуты
((Type)obj).GetCustomAttributes
Attribute.GetCustomAttribute(MemberInfo a,Type b);//a-объект, b-тип атрибута



#Conditional
class n{
[Conditional("trial")]
void nnn(){}
}
nObj.nnn();//вызовется только если #define trial


#Obsolete
пометить элемент программы как устаревший
[Obsolete("сообщение",bool a)]//если a-true то сообщение об ошибке если нет то предупреждение
class n{}




















#атрибуты для #отображение #редактирование #attr #atribute

[...]
 public int Id { get; set; }

[HiddenInput (DisplayValue=false)] --- создаст hidden

 [Display(Name = "Название")]   корректно отображается через editorformodel() и LabelFor(=>)
[ScaffoldColumn(false)] --полностью скроет, не будет создано ничего
//editorfor
[DataType(DataType.Password)] --редактирем отображение

DataType.{
Currency --Отображает текст в виде валюты

DateTime--Отображает дату и время
Date--Отображает только дату, без времени
Time--Отображает только время
Text--Отображает однострочный текст
MultilineText--Отображает многострочный текст (элемент textarea)
Password--Отображает символы с использованием маски
Url--Отображает строку URL
EmailAddress-Отображает электронный адрес
}

#json атрибуты #JsonProperty
 [JsonProperty("startX")] -- меняет имя для формата json


 [UIHint("Url")]
 [UIHint("")]{
Boolean--Хелперы редактирования создают флажок (checkbox) для булевых значений. Для значений типа bool? (nullable) создается элемент select с параметрами True, False и Not Set
Хелперы отображения генерируют те же элементы html, что и хелперы редактирования, только с атрибутом disabled

Collection--Используется соответствующий шаблон для рендеринга каждого элемента коллекции. Причем элементы могут быть разных типов.

Decimal--Хелперы редактирования создают однострочное текстовое поле - элемент input

EmailAddress--Хелперы редактирования создают однострочное текстовое поле.
Хелперы отображения генерируют элемент ссылка, где атрибут href имеет значение mailto:url

HiddenInput--Создается скрытое поле - элемент hidden input

Html--Хелперы редактирования создают однострочное текстовое поле.
Хелперы отображения просто показывают текст

MultilineText--Хелперы редактирования создают многострочное текстовое поле (элемент textarea)

Object--Хелперы изучают свойства объекта и выбирают наиболее подходящие для него шаблоны.

Password--Хелперы редактирования создают текстовое поле для ввода символов с использованием маски
Хелперы отображения показывают пароль как есть, без использования маски

String--Хелперы редактирования создают однострочное текстовое поле

Url--Хелперы редактирования создают текстовое поле
Хелперы отображения создают элемент ссылки для данного Url

}

@Html.EditorForModel()
<input type="hidden" id="Id" name="Id" value="1" />



https://metanit.com/sharp/mvc5/7.1.php

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


#куки #сессия #сессии #session #Cookies
получить
string id =HttpContext.Request.Cookies["id"].Value;
установить
HttpContext.Response.Cookies["id"].Value = "ca-4353w";

удалить(устанавливаем вчерашнюю дату)
Response.Cookies[«MyCookieName»].Expires = DateTime.Now.AddDays(-1);

проверяем поддержки 
if (Request.Browser.Cookies)
{// поддерживает}
else
{// не поддерживает}
проверка отключения
Если пользователь отключил использование кукисов в броузере, то выше указанный метод Request.Browser.Cookies при проверки всё равно вернет true, но кукисы не будут сохранены на компютере клиета. Один из способов проверки в данном случаи является попытка сохранить кукис на первой странице, а затем используя Response.Redirect перенаправить на другую страницу и прочитать записанный кукис.


сессия
https://professorweb.ru/my/ASP_NET/base/level5/5_4.php
сессия держится 20 минут
Session["name"] = "Tom";
var val = Session["name"];
удалить
Session["name"]=null;
полностью закрываем сессию
Session.Abandon()


HttpSessionState методы
Count	Количество элементов в коллекции текущего сеанса
IsCookieless	Указывает, как отслеживается этот сеанс: с помощью cookie-набора или с использованием измененных URL-адресов
IsNewSession	Указывает, был ли данный сеанс только что создан для текущего запроса. Если в состоянии сеанса на текущий момент не содержится никакой информации, ASP.NET не будет беспокоиться ни об отслеживании сеанса, ни о создании cookie-набора сеанса. Вместо этого сеанс будет воссоздаваться заново при каждом запросе
Mode	Предоставляет перечислимое значение, которое объясняет, как ASP.NET хранит информацию о состоянии сеанса. Этот режим хранения определяется на основе указанных в файле web.config конфигурационных настроек
SessionID	Предоставляет строку с уникальным идентификатором сеанса для текущего клиента
StaticObjects	Предоставляет коллекцию элементов сеанса, предназначенных только для чтения, которые были объявлены в global.asax с помощью дескрипторов <object runat="server">. В основном эта технология не используется и является пережитком ASP-программирования; она поддерживается для обратной совместимости
Timeout	Текущее количество минут, которое должно пройти, прежде чем текущий сеанс будет завершен при условии отсутствия запросов от клиента. Это значение может изменяться программно, что дает возможность при необходимости продлевать срок жизни коллекции сеанса для более важных операций
Abandon()	Немедленно завершает текущий сеанс и освобождает все занятые им ресурсы памяти. Такая технология полезна на автономных страницах, поскольку позволяет освобождать ресурсы памяти сервера настолько быстро, насколько возможно
Clear()	Удаляет все элементы сеанса, но не изменяет идентификатор текущего сеанса





#area https://metanit.com/sharp/mvc5/6.5.php

classnameViewModel  для передачи в представление
переопределение шаблона отображения и редактирования EditorForModel @for @editor @display  https://metanit.com/sharp/mvc5/5.15.php
создание нового шаблона https://metanit.com/sharp/mvc5/5.14.php









#создание #html блоков c#

Свойство InnerHtml позволяет установить или получить содержимое тега в виде строки

Метод MergeAttribute (string, string, bool) позволяет добавить к элементу один атрибут. Для получения всех атрибутов можно использовать коллекцию Attributes

Метод SetInnerText(string) устанавливает текстовое содержимое внутри элемента

Метод AddCssClass(string) добавляет класс css к элементу

TagBuilder ul = new TagBuilder("ul");
TagBuilder li = new TagBuilder("li");
                li.SetInnerText(item);
                ul.InnerHtml += li.ToString();

return new MvcHtmlString(ul.ToString());





хелперы #helpers #healpers #razor
	стандартные 
@using (Html.BeginForm("Action", "Home",
    new { id = "MyIdValue" },
    FormMethod.Post,
    new { @class = "userCssClass", data_formType="user" })){
<input type="submit" value="Отправить" />
}

<form id="MyIdValue" class="userCssClass" method="post" action="/Home/Action" data-formType="user" method="post">
    
</form>




@Html.TextArea("text", "привет <br /> мир", 5, 50, null) <textarea cols="50" id="text" name="text" rows="5">привет <br /> мир</textarea>

@Html.TextBox(string name, string value, object htmlAttributes)

@Html.Hidden("BookId", "2") <input id="BookId" name="BookId" type="hidden" value="2" />

@Html.Password("UserPassword", "val") <input id="UserPassword" name="UserPassword" type="password" value="val" />

@Html.RadioButton 
Для создания группы переключателей, надо присвоить всем им одно и то же свойство name
@Html.RadioButton("color", "red") <input id="color" name="color" type="radio" value="red" />

@Html.CheckBox("Enable", false)
<input id="Enable" name="Enable" type="checkbox" value="true" />
<input name="Enable" type="hidden" value="false" />

@Html.Label("Name")<label for="Name">Name</label>

@Html.DropDownList("countires", new SelectList(new string[] {"Russia","USA", "Canada","France"}),"Countries")
SelectListItem имеет свойства Text (отображаемый текст), Value (само значение, которое может не совпадать с текстом) и Selected

<select id="countires" name="countires"><option value="">Countries</option>
<option>Russia</option></select>

@Html.ListBox("countires", new MultiSelectList(new string[] {"Россия","США", "Китай","Индия"}))
<select Length="9" id="countries" multiple="multiple" name="countires">
<option>Россия</option></select>

Display/DisplayFor Создает элемент разметки для отображения значения указанного свойства модели: Html.Display("Name")

Editor/EditorFor Создает элемент разметки для редактирования указанного свойства модели: Html.Editor("Name")

DisplayText/DisplayTextFor Создает выражение для указанного свойства модели в виде простой строки: Html.DisplayText("Name")

DisplayForModel/EditorForModel Создает поля для чтения для всех свойств модели: Html.DisplayForModel()


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!






entity
#entityFraemwork   #db   #bd #ef  #connectionstring
using System.Data.Entity;
........................
Web.config в секцию  <configSections> после  <section name="entityFramework" 
<connectionStrings>
    <add name="DefaultConnection" connectionString="Data Source=(LocalDb)\MSSQLLocalDB;AttachDbFilename=|DataDirectory|\aspnet-server_info_web_desk-20180518052414.mdf;Integrated Security=True" providerName="System.Data.SqlClient" />
  </connectionStrings>

в строке подключения не должно быть вхождения строки Initial Catalog=aspnet-dip-20181007084703;
(LocalDb)\MSSQLLocalDB можно узнать доступные значения (поиск-> sql , расположение sql server -> настройка )


#DbSet #context #DbContext

class SoccerContext : DbContext
{
    //public SoccerContext() : base("SoccerDB2")
public ApplicationDbContext(): base("DefaultConnection", throwIfV1Schema: false)
    { }
    public DbSet<Team> Teams { get; set; }
}


using(var db=new SoccerContext()){
db.Log=Console.Out;//вывод логов на консоль
}





правильное удаление редактирование   #Attach
при создании нескольких контекстов на 1 бд ссылающихся и для изменения данных надо прописать
using(){}
using(){
//db.Set<класс_объекта>().Attach(объект);  //ТАК(лучше)
p1.Price = 60000;
        //db.Entry(p1).State = EntityState.Modified;//редактирование //ИЛИ ТАК
}
для дозагрузки данных в другом контексте reference collection
#присоединение к #контексту   #Attach
db.Set<класс_объекта>().Attach(объект);


db.Entry(p1).State = EntityState.Deleted;//удаление
 db.Phones.Attach(p1);//
        db.SaveChanges();
https://metanit.com/sharp/entityframework/1.3.php


Способы загрузки и получения связанных данных #load #include #loading #ef #virtual #загрузка 
//для того что бы можно было закинуть лямбду а не строку надо -- using System.Data.Entity;
Eager Loading  жадная загрузка
 var players = db.Players.Include(p=>p.Team).ToList();



#Explicit Loading  Явная загрузка 
#Entry
if(!db.Entry(db.Players.FirstOrDefault()).Reference("Team").IsLoad)
db.Entry(db.Players.FirstOrDefault()).Reference("Team").Load();
для загрузки коллекций юзать Collection вместо Reference

можно добавлять условия, но нужно менять load на tolist (тк при load не загрузит(не точно)) #TODO
#Query
var mass=db.Entry(this).Collection(x1 => x1.ImagesLikes).Query().Where(...).Take(...).Select(...).....ToList();






#Lazy Loading
все делается само но в объявлении модели virtual
public int? TeamId { get; set; }
    public virtual Team Team { get; set; }



настройка связей с #Fluent #API
#one #to #many #многие #многим #один
TODO


связь 1 к 1
https://stackoverflow.com/questions/26389707/ef-code-first-one-to-one-relationship-multiplicity-is-not-valid-in-role-in-re

//то что ниже хз мб не для EF
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=relationsdb;Trusted_Connection=True;");
    }
     
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder
            .Entity<User>()
            .HasOne(u => u.Profile)
            .WithOne(p => p.User)
            .HasForeignKey<UserProfile>(p => p.UserKey);
    }

//должно работать

public class Student
{
    public int StudentId { get; set; }

    public StudentAddress Address { get; set; }
}
     
public class StudentAddress 
{
    [Key]
    [#ForeignKey("Student")]
    public int StudentAddressId { get; set; }

    public Student Student { get; set; }
}







#1 ко многим 

https://metanit.com/sharp/entityframework/3.3.php
если не указать внешний ключ как ?(nullable) то создается cascade(удалении записей связанных)


 Player pl1 = new Player {Name = "Роналду", Age = 31, Position = "Нападающий", Team=t2 };
public class Player
{
    public int Id { get; set; }
// название поле с объектом "Team"+ название поле ключа объекта "Team.Id"
    public int? TeamId { get; set; }
    public Team Team { get; set; }
}
public class Team
{
    public int Id { get; set; }
    public ICollection<Player> Players { get; set; }
    public Team()
    {
        Players = new List<Player>();
    }
}
даже если свойство объяслено так public int? TeamId { get; set; } при удалении Team произойдет ошибка, тк игроки все равно обязаны иметь сязь с командой, для исправления надо
строка для обNULLения ссылки на team при удалении team на который ссылается
db.Database.ExecuteSqlCommand("ALTER TABLE dbo.Players ADD CONSTRAINT Players_Teams FOREIGN KEY (TeamId) REFERENCES dbo.Teams (Id) ON DELETE SET NULL");







многие ко многим


public class Team
{
    public int Id { get; set; }
    public ICollection<Player> Players { get; set; }
    public Team()
    {
        Players = new List<Player>();
    }
}
public class Player
{
    public int Id { get; set; }
    public ICollection<Team> Teams { get; set; }
    public Player()
    {
        Teams = new List<Team>();
    }
}

...{
 public DbSet<Player> Players { get; set; }
        public DbSet<Team> Teams { get; set; }

//необязательно, но желательно, обязательно только если между сущностями несколько связей многие ко многим #WithMany #HasMany
 protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Player>().HasMany(c => c.Teams)//1 класс и свойство который связываем
                .WithMany(s => s.Players)//2 класс и свойство с которым связываем
                .Map(t => t.MapLeftKey("PlayerId")//id 1 которое в таблице будет
                .MapRightKey("TeamId")//id 2
                .ToTable("PlayerTeam"));//название таблицы
            base.OnModelCreating(modelBuilder);//инициализация что бы роли и все остальное добавилось нормально


//многие ко многим без лишнего
modelBuilder.Entity<Phone>()
    .HasMany(p => p.Companies)
    .WithMany(c => c.Phones);


//один-к нулю или к одному #WithOptional
//Phone -имеет,  Company- может не иметь
modelBuilder.Entity<Phone>()
        .HasRequired(c => c.Company)
        .WithOptional(c => c.BestSeller);

//один к одному #HasRequired #WithRequiredPrincipal
modelBuilder.Entity<Phone>()
    .HasRequired(c => c.Company)
    .WithRequiredPrincipal(c => c.BestSeller);//устанавливает Phone в качестве основной


//один ко многим
modelBuilder.Entity<Company>()
    .HasMany(p => p.Phones)
    .WithRequired(p=>p.Company);



modelBuilder.Entity<Company>()
    .HasMany(p => p.Phones)
    .WithRequired(p=>p.Company)
    .HasForeignKey(s=>s.Manufacturer)//явно указываем внешний ключ для связи с Company
.WillCascadeOnDelete(false);//отключаем каскадное удаление

//отключение каскадного удаления при отдельных видах отношений
modelBuilder.Conventions.Remove<OneToManyCascadeDeleteConvention>();
modelBuilder.Conventions.Remove<ManyToManyCascadeDeleteConvention>();

#HasRequired()//обязательно должно быть указано
#WithOptional()//не обязательная связь
#WithRequiredPrincipal()//обязательная связь,устанавливает одну из сущностей в качестве основной
#HasMany()//множественную связь
#WithMany()//обратная множественная связь
#HasForeignKey() //явно указываем внешний ключ для связи 
#WillCascadeOnDelete(false) //отключаем каскадное удаление
        }








закрытие protected override void #Dispose(bool disposing)
{
    db.Dispose();
    base.Dispose(disposing);
}






Когда следует использовать #AsNoTracking? Если нам надо просто вывести данные для отображения без необходимости их дальнейшего обновления, тогда как раз тот случай, когда мы можем использовать AsNoTracking.
не сохранит изменения и ускорит работу, не получится дозагрузить какие либо данные из бд (load,reference и тд)
Phone firstPhone = db.Phones.AsNoTracking().FirstOrDefault();
firstPhone.Name = "Samsung Galaxy Ace 2";
db.SaveChanges();
возможно стоит присоеденять запись и тогда можно будет ее обновить db.Set<ApplicationUser>().Attach(this);














#атрибуты #atribute #attribute #attr #[] #ef #entityframework
#Аннотации
System.ComponentModel.DataAnnotations
установить ключ в качестве идентификатора
[Key,DatabaseGenerated(DatabaseGeneratedOption.Identity)] //[Key]
public int Ident { get; set; }
 [Required]-NOT NULL в БД
[MaxLength(20)]/MinLength устанавливают максимальное и минимальное количество символов в строке-свойстве

System.ComponentModel.DataAnnotations.Schema
 [NotMapped]--не сопостовляется/добавляется колонка в дб

[Table("Mobiles")]//указываем название таблиц
public class Phone
{
    public int Id { get; set; }
    [Column("ModelName")]//указываем  название колонки
    public string Name { get; set; }
}

[ForeignKey("CompId")]--внешний ключ

 [Index]--установка индекса

[ConcurrencyCheck]--решает проблему параллелизма(если свойство было изменено пока менялось текущем пользователем то выбрасывает исключение DbUpdateConcurrencyException)

комплексные типы / если в моделе есть другая модель
[ComplexType]
public class PhoneInfo
{
    public string Company { get; set; }
    public int Price { get; set; }
}
public class Phone
{
    public int Id { get; set; }
    public string Name { get; set; }
 
    public PhoneInfo Info { get; set; }
 
    public Phone()
    {
        Info = new PhoneInfo { Price = 300 };
    }
}
db.Phones.Add(new Phone 
    { 
        Name = "Samsung Galaxy S5", 
        Info = new PhoneInfo { Company = "Samsung", Price = 17000 } 
    });
 foreach (Phone p in db.Phones)
        Console.WriteLine("{0} - {1}", p.Name, p.Info.Price);
https://metanit.com/sharp/entityframework/6.4.php


Две модели в одной таблице
#ToTable #Table
[Table("Mobiles")]
public class PhoneInfo
{
    [Key, ForeignKey("Phone")]
    public int PhoneId { get; set; }
    public Phone Phone { get; set; }
}
[Table("Mobiles")]
public class Phone
{
    [Key, ForeignKey("Info")]
    public int PhoneId { get; set; }
    public PhoneInfo Info { get; set; }
}
PhoneInfo pi1 = new PhoneInfo { PhoneId=1, Company = "Samsung", Price = 14000};
Phone p1 = new Phone { PhoneId = 1, Name = "Samsung Galaxy S5", Info = pi1 };
db.Infos.Add(pi1);

https://metanit.com/sharp/entityframework/6.5.php

Разделение сущности на несколько таблиц
public DbSet<Phone> Phones { get; set; }
 
    protected override void OnModelCreating(DbModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Phone>().Map(m =>
        {
            m.Properties(d => new { d.Name, d.Id });
            m.ToTable("Mobiles");
        }).Map(m =>
        {
            m.Properties(d => new { d.Company, d.Price });
            m.ToTable("MobilesInfo");
        });
        base.OnModelCreating(modelBuilder);
    }
https://metanit.com/sharp/entityframework/6.6.php


конвенции(установить атрибут сразу на определенные свойства всех классов в бд)
https://metanit.com/sharp/entityframework/6.9.php


Наследование в Entity Framework

public class Phone
{
    public int Id { get; set; }
}
 
public class Smartphone : Phone
{
    public string OS { get; set; }
}
 public DbSet<Phone> Phones { get; set; }
    public DbSet<Smartphone> Smarts { get; set; }
создается 1 таблица
при получении Phone из бд вернутся и Phone и Smartphone

если добавить так
[Table("Smartphones")]
public class Smartphone : Phone
{
то будут созданы 2 таблицы, в 1 все свойства базового во 2 все свойства производного

для базового и наследника создаются 2 разные таблицы и в каждом свои свойства
https://metanit.com/sharp/entityframework/7.3.php








sql
добавление своей функции sql
https://metanit.com/sharp/entityframework/5.2.php

Хранимые процедуры
https://metanit.com/sharp/entityframework/5.3.php

Fluent API и аннотации//переопределение того как enfr будет связывать таблицы ключи и тд(например изменить тип или название таблицы)
https://metanit.com/sharp/entityframework/6.1.php
https://metanit.com/sharp/entityframework/6.2.php


#выполнение #sql скрипта  #ExecuteSqlCommand #SqlQuery
db.Database.ExecuteSqlCommand("");
var comps = db.Database.SqlQuery<Company>("SELECT * FROM Companies");
возвращает количество затронутых строк
int numberOfRowInserted = db.Database.ExecuteSqlCommand("INSERT INTO Companies (Name) VALUES ('HTC')");
получить строку подключения
db.Database.Connection.ConnectionString




выполнение любого( создание каталога, индекса и тд ) #tsql скрипта из файла
#full #text #search   #fulltextsearch #SqlConnection #ExecuteNonQuery ExecuteQuery #Query
 var connection = new SqlConnection();
            connection.ConnectionString = "connection string";
            connection.Open();
                string script = File.ReadAllText(HostingEnvironment.MapPath($"~/tsqlscripts/file_name.txt"));
                
                using (var command = new SqlCommand(script, connection))
                {
                    command.ExecuteNonQuery();
                }

                connection.Close();




получить данные из бд без классов и тдтд

class DbManager
    {
        SqlConnection connection;
        SqlCommand command;

        public DbManager()
        {
            connection = new SqlConnection();
            connection.ConnectionString = @"Data Source=(LocalDb)\MSSQLLocalDB;AttachDbFilename=|DataDirectory|\SOFI.mdf;Integrated Security=True";
            command = new SqlCommand();
            command.Connection = connection;
            command.CommandType = CommandType.Text;
        } // constructor

        public bool GetUsersData(ref string lastname, ref string firstname, ref string age)
        {
            bool returnvalue = false;
            try
            {
                command.CommandText = "select * from ActionPros where firstname=@firstname and lastname=@lastname";
               // command.Parameters.Add("firstname", SqlDbType.VarChar).Value = firstname;
                //command.Parameters.Add("lastname", SqlDbType.VarChar).Value = lastname;
                connection.Open();
                SqlDataReader reader = command.ExecuteReader();
                if (reader.HasRows)
                {
                    while (reader.Read())
                    {

                        lastname= reader["actionId"].ToString();
                        firstname = reader["prosId"].ToString();
                        // age = reader.GetString(3);


                    }
                }
                returnvalue = true;
            }
            catch
            { }
            finally
            {
                connection.Close();
            }
            return returnvalue;

        }

    }
}



получаем данные
DbManager db = new DbManager();

                bool status = db.GetUsersData(ref lastname, ref firstname, ref age);





выполнение tsql скрипта ( создание каталога, индекса и тд ) из файла или из строки

 /// <summary>
        /// выполнение tsql запроса который ничего не возвращает
        /// </summary>
        /// <param name="query - будет использоваться только если command_==null"></param>
        /// <param name="command_ - если не null то не закрывается"></param>
        public static void ExecuteNonQuery(string query, SqlCommand command_ = null)
        {
            var command = command_;
            if (command_ == null)
            {
                var connection = new SqlConnection() { ConnectionString = Constants.sql_0 };
                connection.Open();
                command = new SqlCommand(query, connection);

            }
            command.ExecuteNonQuery();

            if (command_ == null)
            {
                command.Connection.Close();
                command.Dispose();
            }
            
        }

            



выполнение tsql скрипта ( выборка данных) из файла или из строки, метод возвращает данные

/// <summary>
        /// выполнение tsql запроса(например выборка данных) который возвращает данные. при command_-null - откроет новое подключение
        /// </summary>
        /// <param name="query - будет использоваться только если command_==null"></param>
        /// <param name="command_ - если не null то не закрывается"></param>
        /// <param name="props - список свойств"></param>
        /// <returns></returns>
        public static List<Dictionary<string, object>> ExecuteQuery(string query, SqlCommand command_, params string[] props)
        {
            List<Dictionary<string, object>> res = new List<Dictionary<string, object>>();

            var command = command_;
            if (command_ == null)
            {
                var connection = new SqlConnection() { ConnectionString = Constants.sql_0 };
                connection.Open();
                command = new SqlCommand(query, connection) { CommandType = CommandType.Text };

            }

            using (SqlDataReader reader = command.ExecuteReader())
                if (reader.HasRows)
                    while (reader.Read())
                    {
                        Dictionary<string, object> dict = new Dictionary<string, object>();
                        foreach (var i in props)
                            dict.Add(i, reader[i]);
                        res.Add(dict);
                    }
            if (command_ == null)
            {
                command.Connection.Close();
                command.Dispose();
            }

            return res;
        }
//получаем данные, вызов функции
var ldr=DataBase.DataBase.ExecuteQuery(q, "keyphrase");
            foreach (var i in ldr)//список всех выбранных строк
                res += i["keyphrase"].ToString()+" ";

            return res.Trim();













#Инициализация #базы #данных #seed  #ef #bd #entity #framework

#CreateDatabaseIfNotExists: инициализатор, используемый по умолчанию. Он не удаляет автоматчески базу данных и данные, а в случае изменения структуры моделей и контекста данных выбрасывает исключение.

#DropCreateDatabaseIfModelChanges: данный инициализатор проверяет на соответствие моделям определения таблиц в базе данных. И если модели не соответствуют определению таблиц, то база данные пересоздается

#DropCreateDatabaseAlways: этот инициализатор будет всегда пересоздавать базу данных


при старте
https://metanit.com/sharp/entityframework/3.9.php

class AppDbInitializer : DropCreateDatabaseAlways<ApplicationDbContext>
{
    protected override void Seed(ApplicationDbContext db)//название котекста
    {
//доп инфа по ролям и созданию пользователей по тегу #roles

db.Phones.Add();
        db.SaveChanges();

base.Seed(db);//context
    }
}

Объявление
так:
добавить в класс контекста (статический конструктор)
//class ApplicationDbContext : DbContext  или так может быть объявлен public class ApplicationDbContext : IdentityDbContext<ApplicationUser>
//{
static ApplicationDbContext()
    {
        Database.SetInitializer<ApplicationDbContext>(new AppDbInitializer());
    }
или так

в файл global.asax
 public class MvcApplication : System.Web.HttpApplication
    {
        protected void Application_Start()
        {
            Database.SetInitializer<ApplicationDbContext>(new AppDbInitializer());

AppDbInitializer  объявить в папке  Models->DataBase




#roles  #seed

к методу [Authorize(Roles="admin")] [Authorize]

в AppDbInitializer->seed

using Microsoft.AspNet.Identity;//!!!!!!!!!!!!!



var userManager = new ApplicationUserManager(new UserStore<ApplicationUser>(context));

            var roleManager = new RoleManager<IdentityRole>(new RoleStore<IdentityRole>(context));
 var role1 = new IdentityRole { Name = "admin" };
roleManager.Create(role1);
//создание юзера пользователя
var admin = new ApplicationUser { Email = "admin@mail.ru", UserName = "admin@mail.ru", Name="zsuz",Surname="zsuzSUR",Birthday=DateTime.Now };
            string password = "Admin1!";
            var result = userManager.Create(admin, password);
// если создание пользователя прошло успешно
            if (result.Succeeded)
            {
                // добавляем для пользователя роль
                userManager.AddToRole(admin.Id, role1.Name);
	}


для добавления роли при регистрации
accountController
public async Task<ActionResult> Register(RegisterViewModel model){
// после этой строки await SignInManager.SignInAsync(user, isPersistent:false, rememberBrowser:false);
await UserManager.AddToRoleAsync(user.Id, "user");




#roles
 ApplicationUserManager userManager = HttpContext.GetOwinContext()
                                            .GetUserManager<ApplicationUserManager>();
IList<string> roles=userManager.GetRoles(user.Id);
//еще вариант возвращает для зарегистрированного пользователя
System.Web.Security.Roles.GetRolesForUser();
//вернет id ролей(сложный объект)
using(var db=)
this.Roles;
db.Roles.where(=>);

//проверить принадлежит ли пользователь к роли
 System.Web.HttpContext.Current.User.IsInRole("role");
//если нужно закинуть контекст в метод то по такому типу данных "System.Web.HttpContextBase"






#check_id  #UserName #Current #FindById


string userName = Membership.GetUser(userId).UserName;

HttpContext.Current.GetOwinContext().GetUserManager<ApplicationUserManager>().FindById(ID).UserName;









сформировать классы по базе данных
создать класс "linq to sql classes"
в его конструктор просто перетаскивать из бд таблицы


#ef #entity framework
#mdf #bak #ssms
создать mdf из bak файла
по базе данных в microsoft SQL server management studio       задачи->восстановить-> там посоздавать бд   и потом правой кнопкой мыши по ней создать скрипт->использую create там будут пути куда создались файлы будет что то типа
C:\Program Files\Microsoft SQL Server\MSSQL12.SQLEXPRESS\MSSQL\DATA\SOFI.mdf


#SQL #server
расположение server и способ его включить если выключился
C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Microsoft SQL Server 2017 ->Средства настройки->Диспетчер конфигурации SQL Server 2017

//TODO где то уже есть инфа про строку подключения но другая, надо перетащить сюда
для формирования #connection #string  #connectionstring
@"Data Source=.\SQLEXPRESS01;AttachDbFilename=|DataDirectory|\PhysicalEffects.mdf;Integrated Security=True"
Data Source- ИМЯСЕРВЕРА\ИМЯИНСТАНСА
можно просто через local задать --  (LocalDb)\MSSQLLocalDB    -- имя можно узнать в cmd -comand---- sqllocaldb i
можно явно задать .\SQLEXPRESS01  ---  можно узнать какие доступны в  поиск->services ->найти sql server и то что в скобках можно пробовать использовать

#версии #версия #version sql server 
https://sqlserverbuilds.blogspot.com/2014/01/sql-server-internal-database-versions.html?m=1


























 #block #db #ef //#TODO
блокировка записи бд для редактирования и удаления  https://metanit.com/sharp/entityframework/3.10.php

#транзакции #tranzaction #transaction

using(UserContext db = new UserContext())
{
using (var transaction = db.Database.BeginTransaction())
    {
try
        {
            
            db.SaveChanges();
            transaction.Commit();
        }
        catch (Exception ex)
        {
            transaction.Rollback();
        }

}
}










миграция https://metanit.com/sharp/entityframework/3.12.php



репозитории 
https://metanit.com/sharp/entityframework/3.13.php











#regexp #regex #регулярки #регулярные #выражения

//спецсимволы которые надо экранировать символом \
Можно экранировать целую последовательность символов, заключив её между \Q и \E
[ ] \ / ^ $ . | ? * + ( ) { }

. - 1 любой символ но в некоторых реализациях исключая символ новой строки. Вместо символа . можно использовать [\s\S] (все пробельные и непробельные символы, включая символ новой строки)

////////Набор символов в квадратных скобках [ ] именуется символьным классом и позволяет указать интерпретатору регулярных выражений, что на данном месте в строке может стоять один из перечисленных символов.
[abd] - 1 из символов в скобках можно описать через (|)
[А-Яа-я] соответствует всем буквам русского алфавита, за исключением букв «Ё» и «ё»
^ в квадратных скобках  -символы, которые не входят в указанный набор.  [^0-9] означает любой символ, кроме цифр.

\d	[0-9]	Цифровой символ
\D	[^0-9]	Нецифровой символ
\s	[ \f\n\r\t\v]	Пробельный символ
\S	[^ \f\n\r\t\v]	Непробельный символ
\w	[[:word:]]	Буквенный или цифровой символ или знак подчёркивания
\W	[^[:word:]]	Любой символ, кроме буквенного или цифрового символа или знака подчёркивания


^	Начало текста (или строки при модификаторе ?m)	^a	Aaa aaa
$	Конец текста (или строки при модификаторе ?m)	a$	aaa aaA
\b	Граница слова	a\b	aaA aaA
			\ba	Aaa Aaa
\B	Не граница слова	\Ba\B	aAa aAa
\G	Предыдущий успешный поиск	\Ga	AAA aaa (поиск остановился на 4-й позиции — там, где не нашлось a)


() - Круглые скобки используются для определения области действия и приоритета операций. Шаблон внутри группы обрабатывается как единое целое и может быть квантифицирован

| - допустимые варианты - a|b -найдет a и b
gray|grey  === gr(a|e)y ===(можно и так)gr[ae]y




?	Ноль или одно	{0,1}	colou?r	color, colour
*	Ноль или более	{0,}	colou*r	color, colour, colouur и т. д.
+	Одно или более	{1,}	colou+r	colour, colouur и т. д. (но не color)
{n}	Ровно n раз	colou{3}r	colouuur
{m,n}	От m до n включительно	colou{2,4}r	colouur, colouuur, colouuuur
{m,}	Не менее m	colou{2,}r	colouur, colouuur, colouuuur и т. д.
{,n}	Не более n	colou{,3}r	color, colour, colouur, colouuur


!!!
Жадная и ленивая квантификация
(<.*>) - с жадной выделит весь html тела

Жадный	Ленивый
*	*?
+	+?
{n,}	{n,}?

#TODO
ab(xa)*+a	abxaabxaa; но не abxaabxaa, так как буква a уже занята
Жадный	Ревнивый
*	*+
?	?+
+	++
{n,}	{n,}+




А(?#тут комментарий)Б соответствует строке АБ


Флаги указываются после регулярного выражения (порядок флагов значения не имеет) /[0-9]$/m
g — глобальный поиск (обрабатываются все совпадения с шаблоном поиска).
i — регистр букв не имеет значения;
m — многострочный поиск.
s — текст трактуется как одна строка, в этом случае метасимволу . (точка) соответствует любой одиночный символ, включая символ новой строки;
u — unicode трактовка. Выражение может содержать специальные паттерны, характерные для уникода, `/\p{Lu}/ - заглавные буквы` например.






можно искать не создавая объект
Regex.Matches((string)sentence, (string)pattern)


//поиск вхождений всех
string pattern = @"\b\w+es\b";
      Regex rgx = new Regex(pattern);
      string sentence = "Who writes these notes?";
      
//можно указать с какой позиции начать поиск --rgx.Matches(sentence, match.Index + match.Length)  
      foreach (Match match in rgx.Matches(sentence))
         Console.WriteLine("Found '{0}' at position {1}", 
                           match.Value, match.Index);


//поиск вхождений по порядку
Match match = regex.Match(input);
while (match.Success) {
      // Handle match here...

      match = match.NextMatch();




js
''.replace(/\[/g,'<');//регулярка без кавычек



var str = '<h1>Привет, мир!</h1>';
var reg = /<(.*?)>/;
alert( str.match(reg) );

//найти все вхождения
while ((match = reg.exec(str)) !== null) {
  alert(match);










///////////////////////////////////////OLD--------------------------------------









подключение файлов
@Scripts.Render("~/scripts/jquery.validate.min.js")
<script src="@Url.Content("~/scripts/jquery.validate.min.js")" type="text/javascript"></script>


явная #привязка #bind #params
public ActionResult Edit()
{
    var book = new Book();
    try
    {
        #UpdateModel(book);// #TryUpdateModel тоже самое но без исключений и возвращает bool

Выборочная привязка
можно применять к свойству модели и к самой модели
	привязываются только указанные свойства
	public ActionResult Create([Bind (Include="Name, Author")] Book b)
	([Bind (Exclude="Year")] Book b)  исключает из привязки







#ActionResult
наследники
System.Web.Mvc.#ContentResult
System.Web.Mvc.#EmptyResult  #пустой #ответ
System.Web.Mvc.#FileResult
System.Web.Mvc.#HttpStatusCodeResult
System.Web.Mvc.#JavaScriptResult
System.Web.Mvc.#JsonResult
System.Web.Mvc.#RedirectResult
System.Web.Mvc.#RedirectToRouteResult
System.Web.Mvc.#ViewResultBase

return new EmptyResult();







#Response #Cookies #куки

HttpCookie MyCookie = new HttpCookie("LastVisit");
DateTime now = DateTime.Now;
MyCookie.Value = now.ToString();
MyCookie.Expires = now.AddHours(1);
Response.Cookies.Add(MyCookie);



получить параметры  #params #get #post
#request
	при post 
	b.Name = Request.Form["Name"];
HttpContext.Request.Params.Get("param.1");
this.Request.QueryString["param.1"];
Request.Form. В данном случае привязчик получает значения, отправленные с помощью форм
RouteData.Values. Здесь получает значения с помощью маршрутов приложения
Request.QueryString. В данном случае привязчик извлекает значения из строки запроса
Request.Files. В данном случае используются загруженные на сервер файлы
Request.Cookies		Cookie-наборы, отправленные браузером с этим запросом
Request.HttpMethod		Метод HTTP (команда наподобие GET или POST), используемый для этого запроса
Request.Headers		Полный набор заголовков HTTP, отправленных с этим запросом
Request.Url		Элемент RouteTable.Routes, выбранный для этого запроса
Request.UserHostAddress		IP-адрес пользователя, сделавшего этот запрос
RouteData.Route		Элемент Routetable.Routes, выбранный для этого запроса
RouteData.Values		Активные параметры маршрута (либо извлеченные из URL, либо стандартные значения)
HttpContext.Application		Хранилище состояния приложения
HttpContext.Cache		Хранилище кеша приложения
HttpContext.Items		Хранилище состояния для текущего запроса
HttpContext.Session		Хранилище состояния для сеанса посетителя
User		Аутентификационная информация о вошедшем пользователе
TempData		Временные элементы данных, сохраненные для текущего пользователя
(string)RouteData.Values["city"]





#валидация    #attr #validate
   https://metanit.com/sharp/mvc5/7.1.php
атрибуты для полей для валидации 
System.ComponentModel.DataAnnotations 
(ErrorMessage ="Идентификатор пользователя не установлен")--может быть у всех атрибутов
  [Required]-- (свойство обязательно должно быть задано)
[Required(ErrorMessage = "Поле должно быть установлено")]--с сообщением
[RegularExpression (@"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}", ErrorMessage = "Некорректный адрес")]-- проверка регулярками
[StringLength(50, MinimumLength = 3, ErrorMessage = "Длина строки должна быть от 3 до 50 символов")]-- ограничение длины строки
[Range(typeof(decimal), "0.00", "49.99")]   [Range(1700,2000,ErrorMessage="Недопустимый год")]
//
оба свойства должны иметь одинаковое значение
[DataType(DataType.Password)]
public string Password { get; set; }
 
[Compare("Password",ErrorMessage="Пароли не совпадают")]
[DataType(DataType.Password)]
public  string PasswordConfirm { get; set; }//#Password

//#валидация для проверки на #сервере
//перед свойством
[System.Web.Mvc.Remote("CheckExistingEmail", "Account", HttpMethod = "POST", ErrorMessage = "Email already exists")]
    
//
 // не нужно? [Remote("CheckName", "Home", ErrorMessage = "Name is not valid.")]
//return false если проверка не пройдена и true если норм
//[HttpGet]
public JsonResult CheckName(string name)
{
    var result = !(name=="Название");
    return Json(result, JsonRequestBehavior.AllowGet);
}
//

User user = new User { Name = name, Age = age };//создание объекта для которого настроена валидация атрибутами
//массив в котором будут ошибки
var results = new List<ValidationResult>();
//контекст валидации
            var context = new ValidationContext(user);
//bool -надо ли валидировать все свойства
            if (!Validator.TryValidateObject(user, context, results, true))
            {
                foreach (var error in results)
                {
                    Console.WriteLine(error.ErrorMessage);
                }
            }




 @Html.EditorFor(model => model.Name)
    @Html.ValidationMessageFor(model => model.Name)
валидация на сервере
public ActionResult Create([Bind(Include="Id,Name,Author,Year")] Book book){
if (ModelState.IsValid){//#IsValid
//#ModelState хранит все принятые свойства и флаг ошибки для каждого


ModelState.AddModelError("Name", "Некорректное название книги"); ---добавить "ошибку валидации" при "Name"=="" это ошибка уровня модели

//по ссылке все примеры и css
https://metanit.com/sharp/mvc5/7.2.php



создание своих атрибутов для валидации

//суффикс Attribute
//применять без суффикса [UserName]
public class UserNameAttribute : ValidationAttribute
{
    public override bool IsValid(object value)
    {
        if (value != null)
        {
//или к любому типу, если атрибут для всей модели а не для свойства то просто к объекту приводить
            string userName = value.ToString();
//если к моделе то можно так
this.ErrorMessage = "сообщение об ошибке";
        }
//false проверка не пройдена true-пройдена
        return false;
    }
}


Самовалидация модели

 public class User : IValidatableObject
    {
public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
        {
            List<ValidationResult> errors = new List<ValidationResult>();
 
            if (string.IsNullOrWhiteSpace(this.Name))
                errors.Add(new ValidationResult("Не указано имя"));
return errors;
        }}











#маршрутизация #routing
routes.IgnoreRoute("{resource}.axd/{*pathInfo}");
игнорирование routes.IgnoreRoute("Home/Index/12");
 
       routes.MapRoute(
                name: "Default",
                url: "{controller}/{action}/{id}",
                defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
            );
много параметров routes.MapRoute(name: "Default", url: "{controller}/{action}/{id}/{*catchall}",defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional});


#получить #параметры при том что выше , и тд
 string controller = RouteData.Values["controller"].ToString();
 string catchall = RouteData.Values["catchall"].ToString();//вернет все параметры

ограничения для маршрутов
routes.MapRoute(name: "",url: "",defaults: new { },
        constraints: new {controller="^H.*" , id = @"\d{2}" }//регулярки
);



routing через атрибуты https://metanit.com/sharp/mvc5/6.7.php





 



@RenderSection("Footer", false)   #рендер необязательной #секция #RenderSection #IsSectionDefined

рендер необязательной секции с кодом по умолчанию
 @if (IsSectionDefined("Footer")) {
        @RenderSection("Footer")
    }
    else 
    { 
        <span>Содержание элемента footer по умолчанию.</span>   
    }

определение секции в view 
@section Footer {
    Все права защищены. Syte Corp. 2012.
}





	создание #healper хелпера в файле представления
@helper BookList(IEnumerable<BookStore.Models.Book> books)
{}
@BookList(ViewBag.Books)


	#создание #healper #хелпера в отдельном файле #helper
создать в проекте папку под названием App_Code(именно такое)
создать представление в ней MyHelpers.cshtml
@helper HtmlList(string[] items)
{<div></div>}
@MyHelpers.HtmlList(new string[] { "Лондон", "Париж", "Берлин" })

	создание healper хелпера в отдельном файле на c#
создадать в проекте новую папку Helpers и добавим в нее новый класс ListHelper

namespace BookStore.Helpers
{
    public static class ListHelper
    {
        public static MvcHtmlString CreateList(this HtmlHelper html, string[] items, object htmlAttributes = null)
        {
            TagBuilder ul = new TagBuilder("ul");
            ul.MergeAttributes(HtmlHelper.AnonymousObjectToHtmlAttributes(htmlAttributes));
            return new MvcHtmlString(ul.ToString());
        }
    }
}
@using BookStore.Helpers
@Html.CreateList(cities, new { @class = "btn", id = "citiesList" })






Передача данных из контроллера в представление
#ViewData["

 ViewData["Head"] = "Привет мир!";
<h2>@ViewData["Head"]</h2>

#ViewBag

ViewBag.Head = "Привет мир!";
 <h2>@ViewBag.Head</h2>

#ViewData
при data известен тип 

@Html.TextBox("name", ViewData["Name"])
@Html.TextBox("name", (string)ViewBag.Name)

#TempData
хранится до момента прочтения, применение как у data






#redirect #TODO мбдублируется
так нельзя передавать сложные типы данных!!!! можно закинуть в TempData
return #RedirectToAction("ListFeText", "Physic", new { listId = list_id });
return #RedirectToRoute(new { controller = "Physic", action = "ListFeText", listId = list_id });

return Redirect("/Home/Index");//временная
 return RedirectPermanent("/Home/Index");//пермач














#c#

как определить что символы выглядят одинаково

char first = 'A';//angl
        char second = 'А';//rus
string firstNormalized = first.ToString().Normalize(NormalizationForm.FormKD);
        string secondNormalized = second.ToString().Normalize(NormalizationForm.FormKD);
Console.WriteLine(first.Equals(second));                     // False
        Console.WriteLine(firstNormalized.Equals(secondNormalized)); // True














































































//------------------------------------------------------------------------полезные куски кода-------------------------------

#check_id #id #GetUserId #UserId

public static string GetUserId()
        {
            return System.Web.HttpContext.Current.User.Identity.GetUserId();
        }

        public static ApplicationUser GetUser(string id)
        {
            //string check_id = ApplicationUser.GetUserId();
            ApplicationUser res = null;
            //if (string.IsNullOrWhiteSpace(id))
            //    return res;
            using (ApplicationDbContext db = new ApplicationDbContext())
            {
                res = ApplicationUser.GetUser(id,db);
            }
                
            return res;
        }
public static ApplicationUser GetUser(string id, ApplicationDbContext db)
        {
            //string check_id = ApplicationUser.GetUserId();
            ApplicationUser res = null;
            if (string.IsNullOrWhiteSpace(id))
                return res;
            res = db.Users.FirstOrDefault(x1 => x1.Id == id);

            return res;
        }






#main #header #main_header #mainheader  #preloader #up

<div id="Main_preloader_id" class="Main_preloader div_display_none"></div>
<div class="Main_header_big"> </div>
<div id="Main_header_check_small_or_big_header">
</div>
<div class="Main_header_small" id="Main_header_small_id">
</div>


layout
@Html.Action("Main_header", "Home")
        <div id="layout_active_panel_id" class="layout_active_panel"></div>
        <div onclick="up()" class="Main_header_back_to_top" id="Main_header_back_to_top_id"></div>





css
div.Main_header_big {
    position: relative;
    background-color: white;
    height: 500px;
    width: 96%;
    left: 2%;
    background-image: url(/Content/images/main_header_back_big.jpg);
    background-size: 100% 100%;
     box-shadow: 0 0 10px rgba(0,0,0,0.5);
}
div.Main_header_small {
    position: fixed;
    height: 50px;
    width: 100%;
    display: none;
    top: 0px;
    /*background-color: #cdfae0;*/
    background-image: url(/Content/images/main_header_back_big.jpg);
    min-width:960px;
    z-index: 5;
}


div.Main_preloader{
    position:fixed;
    width:100px;
    height:100px;
    left:48%;
    top:50px;
    background-image: url(/Content/images/preloader_cat.gif);
    background-size: 100% 100%;
    z-index:5;
}



/*JS*/

function up() {
    var top = Math.max(document.body.scrollTop, document.documentElement.scrollTop);
    if (top > 0) {
        window.scrollBy(0, -100);
        time_for_page_up = setTimeout('up()', 20);
    } else clearTimeout(time_for_page_up);
    return false;
}

function isVisible(tag) {
    var t = $(tag);
    var w = $(window);
    var top_window = w.scrollTop();
    var bot_window=top_window+document.documentElement.clientHeight;
    var top_tag = t.offset().top;
    var bot_tag = top_tag + t.height();
    //alert(bot_tag);
    //alert(top_window);
    return ((bot_tag >= top_window && bot_tag <= bot_window) || (top_tag >= top_window && top_tag <= bot_window) || (bot_tag >= bot_window && top_tag <= top_window));
}
$(function () {
    $(window).scroll(function () {
        Change_main_header();
        
    });
});


function Change_main_header() {
    var b = $("#Main_header_check_small_or_big_header");
    if (!b.prop("shown") && !isVisible(b)) {
        b.prop("shown", true);
        var o = document.getElementById("Main_header_small_id")
        var o1 = document.getElementById("Main_header_back_to_top_id")
        o1.style.display = 'block';

        o.style.display = 'block';

    }
    else {
        if (b.prop("shown") && isVisible(b)) {
            b.prop("shown", false);
            var o = document.getElementById("Main_header_small_id")
            var o1 = document.getElementById("Main_header_back_to_top_id")
            o1.style.display = 'none';
            o.style.display = 'none';
        }
    }

}












#плитка



<div class="padding_10_top create_something_one_block div_inline_block">
    <div class="create_something_one_block_inside">
        <a class="link_standart_for_div" href="@Url.Action("ListUserAct","ListPhysics", new { })">


            @*@Html.ActionLink("Личная страница", "PersonalRecord", "SocialNetwork", new { }, new { })*@
            Работа с списками и пользователями

            <div class="create_something_one_block_move">
                Страница для добавления\удаления отношения список-пользователь, физ эффект-пользователь

            </div>

        </a>
    </div>
</div>


.padding_10_top{
    padding-top:10px;
}
div.create_something_one_block{
    width:200px;
}
div.div_inline_block {
    display: inline-block;
    vertical-align: top;
}
div.create_something_one_block_inside{
    height:200px;
    -webkit-box-shadow: 0 0 10px rgba(0,0,0,0.5);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
    border-radius:20px;
    text-align:center;
cursor:pointer;
overflow:hidden;
position:relative;
}

.link_standart_for_div {
    display: block; /* Ссылка как блочный элемент */
    text-align: center; /* Выравнивание по центру */
    height: 100%; /* Высота на весь слой */
    color: black; /* Цвет ссылки */
    
}
div.create_something_one_block_inside:hover div.create_something_one_block_move{
    top:0;
}
div.create_something_one_block_move{
    /*border:solid 2px black;*/
position:absolute;
background-color:rgb(128, 128, 128);
opacity:1;
width:200px;
height:200px;
top:200px;
-webkit-transition:1s;
-o-transition:1s;
transition:1s;
color:white;

}










---------------------------------------------------------------этот блок где просто накидана найс инфа, без нормального поиска он почти бесполезен------------------------------------------------------------------------
#sql #error
при коннекте слева в дб  выдае ошибку
This database file is not compatible with the current instance of SQL Server.

To resolve this issue, you must upgrade the database file by creating a new data connection, or you must modify the existing connection to this database file.

For more information, see http://go.microsoft.com/fwlink/?LinkId=235986


решение 
go to VisualStadio 2012 In Server Explorer Windows open Data Connections Right click on ASPNETDB.MDF click on Modify Connection... a new windows open for you ... you just click OK if other windows open for you click Yes FINISH ( be Happy ) :D


#error
При установлении соединения с SQL Server произошла ошибка, связанная с сетью или с определенным экземпляром. Сервер не найден или недоступен. Убедитесь, что имя экземпляра указано правильно и что на SQL Server разрешены удаленные соединения. (provider: SQL Network Interfaces, error: 26 - Ошибка при обнаружении указанного сервера или экземпляра)
нужно включить именно тот к которому идет коннект
решение по тегам #SQL #server  ->запустить службу
+ включить сам сервер в папке сервера, инфа по темже тегам








при #seed добавление ролей add to role UserId not found
Это может включать в себя следующее:
Политика паролей не соблюдается (это наиболее распространенная причина)
Обязательные поля передаются как пустые строки / null
Дубликат имени пользователя или электронной почты
если нет то попробовать отладить метод create






































--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

















































