записать 
надо
https://metanit.com/sharp/tutorial/9.2.php
https://metanit.com/sharp/tutorial/11.2.php  +дальше все про потоки
 https://metanit.com/sharp/tutorial/12.2.php +дальше все про task
https://metanit.com/sharp/tutorial/13.4.php   обработка исключений
https://metanit.com/sharp/tutorial/13.6.php
https://metanit.com/sharp/tutorial/14.2.php  вся глава про рефлексию даже не читал
https://metanit.com/sharp/tutorial/15.1.php   тут все методы linq надо бы записать + дальше
https://metanit.com/sharp/tutorial/16.2.php   xml
так

https://metanit.com/sharp/tutorial/7.4.php
https://metanit.com/sharp/tutorial/18.1.php  процессы


https://metanit.com/sharp/tutorial/7.5.php




#TODO
@Html.AntiForgeryToken()


ToFrequency -?
FrornFrequency -?


#TODO

#PredicateBuilder.False<Foo>(); #where #linq #or #Predicate



AppDomain.CurrentDomain.BaseDirectory

ar a=(RolesProject)Enum.Parse(typeof(RolesProject), "", true);

#for #html
<label><input type="checkbox">Some text</label>





скорее всего треугольники с закругленными концами
div - before-font-size: 225px; content: "\E90E";



System.Numerics. #Complex.



#full text search
если не обновляется индекс
//пытаемся достроить недостающие записи
--ALTER FULLTEXT INDEX on FETexts START UPDATE POPULATION; 

--отключить автоматическое отслеживание 
--ALTER FULLTEXT INDEX ON FETexts SET CHANGE_TRACKING MANUAL;
//полностью перестраиваем
ALTER FULLTEXT INDEX ON FETexts START FULL POPULATION; 







#iis #https #ssl

C:\Users\zsuz\Documents\IISExpress\
включение iis manager  https://www.youtube.com/watch?v=kLhhvCE2IZg
панель управления-> удаление программ->слева "включение или отключение компонентов windows"-> найти "internet information services (Службы IIS)" и включить то что нужно
Убедитесь, что вы выбрали поддержку ASP.NET. Для этого раскройте узел Службы Интернета --> Компоненты разработки приложений --> ASP.NET (Internet Information Services --> World Wide Web Services --> Application Development Features --> ASP.NET):
Если вы хотите использовать поддержку IIS в Visual Studio, которая позволяет вам создавать виртуальные каталоги IIS непосредственно в диалоговом окне New Web Site, вам нужно выбрать пункт «Совместимость управления IIS 6» в разделе «Средства управления веб-сайтом» (Web Management Tools --> IIS 6 Management Compatibility).


Нажмите клавишу Windows и введите "Свойства Windows", выберите первую запись. Включите или выключите функции Windows.
IIS #manager #диспетчер #служб должен вернуться в Панель управления >\Все элементы панели управления\> Администрирование

https://docs.microsoft.com/en-us/iis/manage/configuring-security/how-to-set-up-ssl-on-iis

иконка в центре сертификаты сервера
создать самоподписанный,  
сайт слева выбрал дефолтный
для этого сайта справа bindings
добавить, имя не указывать , выбрать сертификат, указать https


в проекте visual
нажать на название проекта в solution explorer? снизу появятся настройки\свойства(properties) там включить ssl
проект(сверху)->свойства там базовую страницу поменять на ту которая отрисовалась в предыдущем пункте в строке https 





#professorweb #диспетчер #служб #iis #certificate #sertificate
http://professorweb.ru/my/ASP_NET/sites/level3/3_1.php




#js

#class

function Machine() {//функция конструктор класса, если нужны параметры то закидывать
  var enabled = false;//private свойство, 

function asd(){//private функция, не будет наслодоваться, если  надо наседовать то объявлять через this._asd  ,  _- указывает что функция прайват

}
  this.enable = function() {//public функция будет наследоваться
    enabled = true;
  };

  this.disable = function() {
    enabled = false;
  };
}



var sdf=new Machine();// или(но лучше со скобками) var sdf=new Machine;


2 способ с 2015 года


'use strict';//указывает о том что новые стандарты используются

class User {
//нельзя указывать поля(var a)
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }


static createGuest() {
    return new User("Гость", "Сайта");
  }

}

let user = new User("Вася");









наследование 
function CoffeeMachine(power) {
  Machine.call(this); // унаследовать то что через this. задано(public свойства)
//или так
//Machine.apply(this, arguments)

// переопределить this.enable
  this.enable = function() {
    /* enable для кофеварки */
  };


//если хотим дополнить метод то так
var parentEnable = this.enable; 
  this.enable = function() { 
      parentEnable.call(this);
      this.run(); 
}
}




наследование при class

'use strict';

class Animal {
  constructor(name) {
    this.name = name;
  }

  walk() {
    alert("I walk: " + this.name);
  }
}

class Rabbit extends Animal {
  walk() {
    super.walk();//метод родителя будет вызываться
    alert("...and jump!");
  }

constructor() {

//Вызвать конструктор родителя можно только изнутри конструктора потомка. В частности, super() нельзя вызвать из произвольного метода.
//В конструкторе потомка мы обязаны вызвать super() до обращения к this. До вызова super не существует this, так как по спецификации в этом случае именно super инициализирует this.
    // вызвать конструктор Animal с аргументом "Кроль"
    super("Кроль"); // то же, что и Animal.call(this, "Кроль")
  }
}



#int #приведение #parseInt

var num = parseInt("a4r t 4r43 43a b345b 123 cc gaeg4".replace(/\D+/g,"")); 
parseInt- парсит строку слева направо преобразуя по символу, если находит не цифру то заканчивает






#exist #существует #элемент

проверить существует ли элемент jquery $("div").is(".lBlock")
проверить существует ли элемент jquery $(".class").is("#id")



#select #выбрать #first #1 #первый
сделать первый элемент в select выбранным $("#actionI").val($("#actionI option:first").val());
$("#actionI option[value='idOption']").prop("selected", true); // установить выбранным idOption


#ready #document #start #старт
$(document).ready(function () 
{


#checkbox #radiobutton #each #for #foreach
$('#' + ch.value + type + ' input:checkbox:checked').each(function () {//[type=checkbox] 
$(this).removeAttr("checked") 
});




#scroll #scrollTop

$("html, body").animate({ scrollTop: $("#ScrollChangeActionId").offset().top }, "slow");

#запретить #скролл body.modal-open { 
overflow: hidden; 
}





#html

#отображать #div #текст как он есть  #html #pre>
#<pre></pre>


#html #div #size #% #width
div1-width 30%
и
div1-width 70%
не умещаются по ширине(перенос на новую строку) в внешний элемент
дивы не умещаются в див
.parent {
/*внешний див В который не умещаются*/
    font-size: 0;
}

.child {
/* это надо для восстановления шрифта к вложенным дивам (которые не умещаются)*/
    font-size: 16px;
}





























#c#


#struct

в структуре нельзя создать конструктор по умолчанию(он генерируется системой В ЛЮБОМ СЛУЧАЕ даже если мы определим другие, в отличии от класса)
если в конструкторе не инициализировать поля то комплятор НЕ сгенерирует им значения, а в классе сгенерирует
в структуре нельзя инициализировать переменные в месте их объявления
в структуре можно засунуть индексатор и статик конструктор
не ссылочный тип данных
не наследуется от класса и от структур и не может быть родителем для них, но может от интерфейса
нельзя определять деструкторы
члены структуры нельзя указывать как abstract virtual protected
объект может быть создан через new(но может и без него)
struct b{}
b perem;perem.val=10;//не вызывая конструктор


#class  
полностью хранится в куче(то что объявлено в классе тоже)
#constructor
если класс наследуется , при вызове конструктора вызывается сначала конструктор родителя(даже если не применили слово #base)
public class cl{
}
cl perem=new cl();
cl perem=new cl(){val=10};
cl perem=new cl{val=10};

x:y{
public x():base(){//передаем в конструктор y
в конструкторе нельзя вызывать метод экземпляра
this.method();//#TODO нельзя???
}
public x():this(){//передаем в другой конструктор x
}
}
В классе Subclass должны быть "повторно определены" любые конструкторы, которые необходимо открыть



???подкласс может иметь меньшую доступность, чем базовый класс, но не большую
public class TopLevel 
{ 
puЬlic class Nested { / / Вложенный класс 
public enum Color { Red, Blue, Tan } / / Вложенное  перечисление 
Вложенный тип
}
Он может получать доступ к закрытым членам включающего типа и ко всему остальному, к чему имеет доступ включающий тип.
• Он может быть объявлен с полным диапазоном модификаторов доступа, а не только public и internal.
• Стандартной доступностью вложенного типа является private, а не internal.
• Доступ к вложенному типу извне требует указания имени включающего типа (как при обращении к статическим членам).
Например, для доступа к члену Color.Red извне класса 
TopLevel необходимо записать так: 
TopLevel.Color color = TopLevel.Color.Red; 
Все типы могут быть вложенными, однако содержать вложенные типы могут только классы и структуры.



Любой совместимый метод экземпляра всегда будет иметь преимущество над расширяющим методом - даже когда параметры 
расширяющего метода дают более точное соответствие по типам.

правило более специфичных параметров TODO







#модификаторы #modificators

#virtual - для возможности переопределения в наследниках
#override - для переопределения чего либо

#sealed - если перед class то запретить наследование
если перед методом то только перед тем для которого должны были указать override - запретит переопределение через override,но метод будет унаследован
class Subclass1 : Base {
   public sealed override void Test() { ... }
}
class Subclass2 : Subclass1 {
   public override void Test() { ... } // Does not compile!
   // If `Subclass1.Test` was not sealed, it would've compiled correctly.
}




#readonly
только для чтения, можно задать в конструкторе или при объявлении
#const
только для чтения, константа, можно задать только при объявлении

#volatile
значение поля может быть изменено параллельно выполняющимися потоками, значение не кешируется в потоках=> всегда будет актуальным

#extern
1-метод предоставляется внешним кодом
2- псевдоним для внешней сборки








#checked  #unchecked
исключения при переполнении
что из этого используется по умолчанию нельзя сказать тк зависит от компилятора
существует 2 формы
checked((byte)(int_1*int_2))
checked{(byte)(int_1*int_2)}







#case #switch

#goto case х (переход на другую конструкцию case); 
 goto defaul t
switch 
{ 
case 13: 
//если тут нет кода то можно пропустить break; и 2 case объединятся
case 12: 
break;

case 12 when(y<10): 
break;

case int val: 
break;

default:
break;

case null:
break;

}



#if #else







#get #set
нельзя просто объявить свойство в методе
можно в классе, интерфейсе
public int Response { get; }//при таком объявлении обязательно раскрывать
public int Response { get;private set; }//но то что в скобках может быть только более ограничивающим
public int Maximum { get; } = 999;
Свойство только для чтения public decimal Worth => currentPrice * sharesOwned;
public int Response { get{
return val;
}
set{
val=value;
} }


#types



#object
главный тип, от него наследуется все остальные

#упаковка #распаковка
в объект типа object можем упаковать объект любого другого типа, и распаковать обратно в тот же тип или в тип родителя того класса который упаковывали
object tt=new object();
a tta=new a();
a ttb=new b();
tt=ttb;
tta=(a)tt;
при упаковке ссылка object == той ссылке которую упаковали(если упаковывали ссылочный тип)




#enum

[:int]- тип перечисления
enum apple[:int]{val1,val2,val3,val4=10}
enum apple:int{val1,val2,val3,val4=10}
(int)apple.val1;//0
(int)apple.val4;//10

for(apple i=apple.val1;i<apple.val4&&(i)<20;++i)
console.writeline(i);//val1...

foreach (RolesProject roleName in (RolesProject[])Enum.GetValues(typeof(RolesProject)))
                var role = new IdentityRole { Name = roleName.ToString() };

парсим из строки
RolesProject role = (RolesProject)Enum.Parse(typeof(RolesProject), roleNameString, true);

BorderSide b = (BorderSide) 12345; //даже если в BorderSide нет такого числа
Console.WriteLine (b)//12345




[Flags] 
public enum BorderSides 
{ 
None= O, 
Left=l, Right=2, Тор=4, Bottom=8, 
LeftRiqht = Left | Riqht, 
TopBottom = Тор | Bottom, 
All = LeftRiqht | TopBottom
}
BorderSides leftRight = BorderSides.Left | BorderSides.Right; 
if ((leftRight & BorderSides.Left) ! = О) 
Console.WriteLine ("Includes Left"); //Includes Left 
string formatted = leftRight.ToString() ;//"Left, Right" 
BorderSides s = BorderSides.Left; 
s |= BorderSides.Right; 
Console.WriteLine (s == leftRight); / / True

то что применяется к enum
+= -
! = < > <= >= + 
++ sizeof




#dynamic
#Динамическое #связывание противоположность #статического #связывания #статическое
проверка типа откладывается до выполнения


dynamic val;
val="";

void meth(object o);
void meth(dynamic o);//перегрузить не получится, тк  dynamic считается object

typeof (dynamic) == typeof (object) //true

dynamic х = 2;
var у= х * 3; // Статическим типом у является dynamic 



#IDynamicMetaObjectProvider #IDMOP #TODO
#Специальное связывание


Класс Duck в действительности не имеет метода Quack.
Вместо этого он использует специальное связывание для перехвата и интерпретации всех обращений к методам. 
puЬlic class Duck: DynamicObject
{
puЬlic override bool TryinvokeMember( InvokeMemЬerBinder binder, object[] args, out object result)
Console.WriteLine (binder.Name + "was called");
result = null;
return true; 
}
}
d.Quack(); // Выводит Quack was called
d.Waddle(); // Выводит Waddle was called



при вызове например метода которого нет(для обычного dynamic) выбросится исключение #RuntimeBinderException




статическое- #TODO
В простейшем случае компилятор осуществляет связывание за счет поиска в типе метода который необходимо вызвать с указанными параметрами.
Если не найдено то компилятор распространяет поиск на методы, принимающие необязательные параметры,
методы базовых классов  и расширяющие методы, которые принимают этот тип в своем первом параметре. Если ничего из этого
не найдено, возникает ошибка компиляции. Независимо от того,
к какому методу произведено связывание, суть в том, что связывание делается компилятором, и оно полностью зависит от статических сведений о типах операндов (в данном случае d). Именно
поэтому такой процесс называется статическим связыванием.











#Single представляет тип #float



#decimal
static Add
static Divide
static Myltiply
static Negate
static MaxValue
#TODO M





#array
Char[]off=new Char[]{a,s}
Char[]off={a,s}
Int[,]cf={{0,3},{}}
char [] vowels = {'а', 'е', 'i', 'о', 'u'};
int[][] matrix = 
{ 
new int [] {О, 1, 2}, 
new int [] { 3, 4, 5} }
new []{1,2 }

длина массива #Length 
размерность массива #Rank
#Createinstance динамическое создание массива
#GetValue #SetValue извлечение и установка элементов независимо от типа массива????
#GetLength
matrix.GetLength(0); //Метод GetLength массива возвращает длину для заданного измерения (начиная с 0):

System.Array.#CopyTo-- глубокое копирование
#clone-- поверхностное копирование



см также -collection
IsFixedSize - если фиксированного размера
IsSynchronized - если можно использовать в многопоточной среде
Rank - размерность массива
SyncRoot - объект для синхронизации доступа к массиву

если отсортированный и одномерный то
BinarySearch поиск эелемента по применению как IndexOf
IndexOf
Clear -очищает, размер остается
Clone - не полная копия(если внутри ссылки то будут ссылаться на теже элементы)
Find...
ForEach
GetValue
Reverse
Exist


#collection #array #list #interface


#приведение #типов #Необобщенное в #обобщенное var classicList = new System.Collections.ArrayList(); 
classicList.AddRange ( new int[] { 3, 4, 5} ) ; 
IEnumeraЫe<int> sequencel = classicList. #Cast<int>()//когда встретит не int элемент(не сможет привести через is) то сгенерит исключение
IEnumeraЫe<int> sequencel = db.users.Cast<int>()
IEnumeraЫe<int> sequencel = classicList. #OfType<int>()//когда встретит не int элемент(не сможет привести через is) то пропустит элемент




инициализация
List<char> lst = new List<char>() { 'С', 'А', 'Е', 'В', 'D', 'F' };
lst1=new SortedList<int, string>() { {1, "один"}, {2, "два" }, {3, "три"} };
такая инициализация интерпретируется как lst.Add();//=> нельзя так закидывать значения в коллекции в которых нет public Add



В среде .NET Framework поддерживаются пять типов коллекций: необобщенные,
специальные, с поразрядной организацией, обобщенные и параллельные
необобщенные- хранят только object
Специальные коллекции - оперируют данными конкретного типа или же делают это каким-то особым образом//--- #CollectionsUtil  #HybridDictionary  #ListDictionary #NameValueCollection #OrderedDictionary #StringCollection #StringDictionary
с поразрядной организацией-BitArray
Обобщенные коллекции-храниться только такие элементы данных,которые совместимы по типу с данной коллекцией. Благодаря этому исключается случайное несовпадение типов
Параллельные коллекции-  поддерживают многопоточный доступ к коллекции

должны реализовавывать IEnumerator и IEnumerable,  IEnumerator<T> и IEnumerable<T>




перечислитель
итератор

#IEnumerable
для #foreach,
IEnumerator GetEnumerator()
 IDictionaryEnumerator GetEnumerator()//если словарь
public IEnumerator GetEnumerator() {
return this;
}
public void Reset() { idx = -1; }













#IEnumerator
для #foreach, 
любое изменение коллекции делает перечислитель недействительным

bool MoveNext() //true- если есть след элемент
Reset // устанавливает перечислитель в конец(не на последний элемент)(элемент перед первым, для получения первого после reset -MoveNext())
свойство
Current




#IQueryable : IEnumerable
удаленные бд принимает expression при запросе происходит оптимизация




#IList : ICollection , IEnumerable
this[int index] { get; set; }
Add
Clear
Contains
IndexOf
Insert
Remove
RemoveAt
свойства
IsFixedSize
IsReadOnly



#ICollection: IEnumerable


int Count { get; }
bool IsReadOnly { get; }








#IDictionary: ICollection , IEnumerable
пустые ключи не допускаются
V this[T key] { get; set; }
Add
Clear
Contains
GetEnumerator
Remove
bool TryGetValue(TKey key, out TValue value) пытается извлечь по key и засунуть в value. если все норм то true. Если key не найден, value =значение выбираемое по умолчанию
свойства
IsFixedSize
IsReadOnly
Keys
Values



#IComparer 
int Compare(T х, T у)
(x>y) вернет положительное число



 #IEqualityComparer
bool Equals(T х, T у)
int GetHashCode(T obj)


#ISet<T>

: IEnumerable, IEnumerable<T>,ICollection<T>



#struct
#DictionaryEntry
коллекции словарей(вроде только не обобщенных) хранят в такой структуре key value
public DictionaryEntry(T key, T value)

#KeyValuePair<TKey, TValue>
коллекции словарей(вроде только обобщенных) хранят в такой структуре key value

class

абстрактные классы
 CollectionBase, ReadOnlyCollectionBase и DictionaryBase


#ArrayList , обобщенная форма называется #List
Определяет динамический массив, т.е. такой массив, который может при необходимости увеличивать свой размер

: ICollection, IList, IEnumerable , ICloneable

AddRange
BinarySearch
static FixedSize Заключает коллекцию list в оболочку типа ArrayList с фиксированным размером и возвращает результат 
InsertRange
static Readonly Заключает коллекцию list в оболочку типа ArrayList, доступную только для чтения
SetRange Заменяет часть вызывающей коллекции  элементами коллекции переданной
Sort
 static Synchronized Возвращает синхронизированный вариант коллекции 
TrimToSize Устанавливает значение свойства Capacity равным значению свойства Count(обрезает массив до количества элементов в нем)

свойства
Capacity - максимальный размер массива на данный момент, можно устанавливать но нельзя установить меньше чем количество элементов в массива сейчас




#Hashtable Определяет хеш-таблицу для пар “ключ-значение”   обобщенная форма называется #Dictionary
ключ хешируется=> скорость работы не зависит от количества элементов внутри
:IDictionary, ICollection, IEnumerable, ISerializable, IDeserializationCallback ,ICloneable



public Hashtable()
public Hashtable(IDictionary d)
public Hashtable(int capacity)
public Hashtable(int capacity, float loadFactor=1)
loadFactor - коэффициент заполнения(от 0,1 до 1,0)
Он определяет степень заполнения хеш-таблицы до увеличения ее размера. В частности, таблица расширяется, Count> loadFactor*емкость_таблицы


ContainsKey
ContainsValue
Synchronized


#Dictionary см Hashtable
:IDictionary,IDictionary<TKey, TValue>, ICollection, ICollection<KeyValuePair<TKey,TValue>>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>,ISerializable , IDeserializationCallback

var dict = new Dictionary<int, string>()
{
{ 5 , " f i ve" } ,
{ 10, "ten" }
}; 
Или в случае версии С# 6: 
var dict = new Dictionary<int, string>()
{
[3] = "three",
}; 

теория--
Инициализация происходит либо при создании (если передана начальный размер коллекции), либо при добавлении первого элемента, причем в качестве размера будет выбрано ближайшее простое число (3). При этом создаются 2 внутренние коллекции — int[] buckets и Entry[] entries. Первая будет содержать индексы элементов во второй коллекции, а она, в свою очередь, — сами элементы


При добавлении элемента вычисляется хэшкод его ключа и затем — индекс корзины в которую он будет добавлен по модулю от величины коллекции:

проверяется нет ли уже такого ключа в коллекции, если есть — то операция Add выбросит исключение, а присваивание по индексу просто заменит элемент на новый. 
Если достигнут максимальный размер словаря, то происходит расширение (выбирается новый размер ближайшим простым числом).
Сложность оперции соответственно — O(n).
Если происходит коллизия (то есть в корзине с индексов bucketNum уже есть элемент), то новый элемент добавляется в коллекцию, его индекс сохраняется в корзине, а индекс старого элемента — в его поле next. 
Таким образом получаем однонаправленный связный список. 
Данный механизм разрешения коллизий называется chaining. Если при добавлении элемента число коллизий велико (больше 100 в текущей версии), 
то при расширении коллекции происходит операция перехэширования, перед выполнением которой случайным образом выбирается новый генератор хэшкодов.
Сложность добавления O(1) или O(n) в случае коллизии.


При удалении элементов мы затираем его содержимое значениями по умолчанию, меняем указатели next других элементов при неоходимости и сохраняем индекс этого элемента во внутреннее поле freeList, 
а старое значение — в поле next. Таким образом, при добавлении нового элемента мы можем повторно использовать такие свободные ячейки:
Сложность снова O(1) или O(n) в случае коллизии.


-----
Внутренне устройство простейшего hash map со списком коллизий чрезвычайно примитивно: имеется массив T[N], каждый элемент которого — это список. Входом в таблицу (индексом) является хеш-значение ключа. Все ключи с одним и тем же хешем (по модулю N) попадают в один и тот же список, называемый списком коллизий.
=>
есть массив массивов ms[i][i2]
i- хэш элементов, если у некоторых элементов одинаковый хэш, они записываются в массив ms[i]->[i2_0],[i2_1],[i2_2]









#SortedDictionary см Dictionary
IDictionary,IDictionary<TKey, TValue>, ICollection, ICollection<KeyValuePair<TKey,TValue>>, IEnumerable , IEnumerable<KeyValuePair<TKey, TValue>>



#SortedList см List



#HashSet
динамическая коллекция
множество уникальных значений, можно использовать пересечение, объединение и разноименность
: ICollection<T>, ISet<T>, IEnumerable,IEnumerable<T>, ISerializable, IDeserializationCallback

RemoveWhere
SymmetricExceptWith - разноименность с множеством
UnionWith - объекдинение множеств
ExceptWith - вычитание множеств

public IEqualityComparer<T> Comparer { get; }



#SortedSet






#Queue Определяет очередь, или список, действующий по принципу “первым пришел — первым обслужен”
ICollection, IEnumerable и ICloneable
при увеличении для создания места под 1 элемент, увеличивается  на коэффициент роста(по умолчанию 2)
public Queue (int capacity, float growFactor=2)//growFactor=от  1,0 до 10,0

Enqueue - поместить в очередь
Dequeue извлечь и удалить 1 объект в очереди
Рееk извлечь но не удалять след объект в очереди
TrimToSize



#SortedList Определяет отсортированный список пар “ключ-значение”
пары "ключзначение" хранятся в порядке, отсортированном по значению ключей. 
IDictionary, ICollection, IEnumerable ,ICloneable

GetBylndex
GetKeyList
GetValueList
IndexOfKey
SetBylndex
Synchronized
TrimToSize


#Stack Определяет #стек, или список, действующий по принципу "первым пришел — последним обслужен”
ICollection, IEnumerable и ICloneable
Peek() - вершина стека
Pop() -  вершина стека с удалением
Push()
Synchronized()





#LinkedList
двунаправленный список
:ICollection, ICollection<T>,IEnumerable, IEnumerable<T>, ISerializable , IDeserializationCallback

ссылки на предыдущий и следующий элемент хранятся в LinkedListNode
LinkedListNode-
public LinkedListNode<T> Next { get; }//null если дальше пусто
public LinkedListNode<T> Previous { get; }
public LinkedList<T> List { get; }
public T Value { get; set; }

-
public LinkedListNode<T> First { get; }
public LinkedListNode<T> Last { get; }

AddAfter
AddBefore
AddFirst
AddLast
Find
Remove




#BitArray
хранит биты а не объекты, для хранения bool как 1 бит а не 1 байт



#SynchronizedCollection<T>
#SynchronizedReadOnlyCollection<T>
#KeyedByTypeCollection<T>




параллельные коллекции #parallel #collection
#BlockingCollection<T> Предоставляет оболочку для блокирующей реализации интерфейса IProducerConsumerCollection<T>
#ConcurrentBag<T> Обеспечивает неупорядоченную реализацию интерфейса IProducerConsumerCollection<T>, которая оказывается наиболее пригодной в том случае, когда информация вырабатывается и потребляется в одном потоке
#ConcurrentDictionary<TKey, TValue> Сохраняет пары "ключ-значение”, а значит, реализует параллельный словарь
#ConcurrentQueue<T> Реализует параллельную очередь и соответствующий вариантинтерфейса IProducerConsumerCollection<T>
#ConcurrentStack<T> Реализует параллельный стек и соответствующий вариант интерфейса IproducerConsumerCollection<T>






#bool
хранится как 1 байт
для хранения битом #BitArray



#int




#double
#float

const -
Epsilon


double.Negativeinfinity
double.NaN
#NaN
Not а Number - не число
+оо, -оо и -0



Console.WriteLine ( 1.0 /О.О);// Бесконечность 
Console.WriteLine (-1.0 /О.О);// Минус бесконечность 
Console.WriteLine ( 1.0 / -0.0); // Минус бесконечность 
Console.WriteLine (- 1.0 / -0.0); // Бесконечность
Console.Write (О.О/ О.О); //NaN
Console.Write ( (1.0 / О.О) - (1.0 /О.О)); //NaN

NaN==NaN;//false
object.Equals (0.0/0.0, double.NaN);//true
для проверки на NaN
(fload|double).IsNaN();



#string
ссылочный тип но передается по значению
не изменяемый(при попытыке изменения создает новую строку)

#$ $"text{val}"
#интерполяция строки($"")

#@ @"\text"-> "\\text"
если применять вместе то в порядке
$@"ffg"
скобки дублировать
$@"she{{x1}}"




#Интернирование строк — это механизм, при котором одинаковые литералы представляют собой один объект в памяти.
в рамках процесса (именно процесса, а не домена приложения) существует одна внутренняя хеш-таблица, ключами которой являются строки, а значениями – ссылки на них. 
Во время JIT-компиляции литеральные строки последовательно заносятся в таблицу (каждая строка в таблице встречается только один раз). На этапе выполнения ссылки на литеральные строки присваиваются из этой таблицы. 



Concat
IndexOf
public int IndexOfAny(char[] anyOf)  индекс первого символа который равен символу из массива
StartsWith
contains
Split(,StringSplitOptions)
Trim([params char[] trimChars]) - удаляет в начале и в конце символы из массива, если ничего не передали то удалит пробелы
Join
public string PadLeft(int totalWidth) заполнит с начала пробелами что бы общая длина строки была==totalWidth
public string PadLeft(int totalWidth, char paddingChar)
public string PadRight(int totalWidth)
public string Insert(int startIndex, string value)
public string Remove(int startIndex, int count)
public string Replace(string oldValue, string newValue)
public string ToLower()
public string ToUpper()
public string Substring(int startIndex, int length)//вернет строку которая начинается с startIndex

public static string Format(string format, params object[] args)
 String.Format("{0:F2}", v);//0-позиция аргумента
string str = 189.99.ToString("С");//тоже форматирование







#TODO потереть дубликаты

#string 
#Конкатенация 
String.Concat(s3, "!!!");
"123"+"332"

Сравнение строк
Если первая строка по алфавиту стоит выше второй, то возвращается число меньше нуля. В противном случае возвращается число больше нуля. И третий случай - если строки равны, то возвращается число 0.
#Compare
int result = String.Compare(s1, s2);
поиск
s1.IndexOf(ch);
LastIndexOf   EndsWith  StartWith
разделение
#Split
Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
string[] words = text.Split(new string[] { "," }, StringSplitOptions.RemoveEmptyEntries);


Обрезка строки
text.Trim();--убирает пробелы вначале и в конце
text.Trim(new char[] { 'd', 'h' });
функция TrimStart обрезает начальные символы, а функция TrimEnd обрезает конечные символы

// обрезаем начиная с третьего символа
text = text.Substring(2);
// обрезаем сначала до последних двух символов
text = text.Substring(0, text.Length - 2);

Вставка
text = text.Insert(8, text2);
Удаление строк
// вырезаем  символ
text = text.Remove(8);
// вырезаем первые два символа
text = text.Remove(0, 2);

Replace
text = text.Replace("хороший", "плохой");

hello.ToLower()
hello.ToUpper()















#StringComparer: IComparer
CurrentCulture - с учетом регистра и культурной среды
CurrentCultureIgnoreCase - без учета регистра и культурной среды
InvariantCulture - с учетом регистра без культур
InvariantCultureIgnoreCase
OrdinalIgnoreCase - порядковое сравнение без учета регистра







#BitConverter
класс для преобразования базовых типов данных в байты










#? #?? #null #Nullable
структура  тип Nullable<T>
//эквивалент
Nullable<bool> val;
bool? val;
val=null;
val=false;

val.HasValue//проверить установлено ли значение
val.Value//получить значение, только для чтения, если null то исключение
#GetValueOrDefault()возвращает значение Value, если HasValue равно true, и результат new Т () или заданное стандартное значение в противном случае

var test=val??true;//если val==null то вернет 2 член(true) если не null то вернет val
var test=val??method();//если val!=null то method не вызовется

можно сравнивать но если хотя бы 1== null то
< > <= >= -всегда false
true||null -true
null||null -null
!null - null
общее правило- если необходимо сравнить null значит будет null, если можно получить результат без сравнения то он будет получен


Когда Т? упаковывается, упакованное значение в куче содержит Т, а не Т?, тк object-ссылочный тип




#Random








#GC #мусор #сборка




#params #param #method
void func(params int[] ints){}
func();
func(1);
func(1,2);
func(new int[]{1,2,3});

если метод в 1 строку можем сделать так, с 17 студии кажется
int Foo (int х) => х * 2;



#необязательные #параметры
void func(int gg,int asd=10){}
необязательные параметры(asd) должны быть указаны в виде константного выражения или конструктора без параметров для типа значения.  не могут быть помечены посредством ref или out.

#позиционные
#именованные параметры
Foo (х:1, у:2);



#Tuple #кортеж

Tuple<t1,t2,t3>
static Create
Tuple<string, string, string, string> t= Tuple.Create("", "", "", "");

кортеж

var tuple = (5, "tre");
или 	 (int, string) tuple = (5, "tre");
tuple.Item1 += 26;

var tuple = (count:5, sum:10);
tuple.count=5;

var (name, age) = ("Tom", 23);
 Console.WriteLine(name);

var tuple = GetValues();
private static (int, int) GetValues()
{
    var result = (1, 3);

private static (int sum, int count) GetNamedValues()
{
    var result = (sum:0, count: 0);


 var (name, age) = GetTuple(("Tom", 23), 12);
private static (string name, int age) GetTuple((string n, int a) tuple, int x)
{
    var result = (name: tuple.n, age: tuple.a + x);










#foreach
есть утиная тапизация
foreach(T val in IEnumerable<T>){}
нужны IEnumerable и IEnumerator
сразу(даже перед 1 итерацией) вызывает сначала MoveNext() а потом Current
если есть dispose у Enumerator то вызывает



можно также без интерфейсов, просто докинуть #итератор  #yield #iterator
public IEnumerator<T> GetEnumerator() {
foreach(T ch in chrs)
yield return ch;
}


#итератор  #yield #return
при создании итератора класс автоматически реализует IEnumerator(не нужно явно указывать)

yield break; // прерывание итератора #TODO


именованный итератор

public IEnumerable имя_итератора(список_параметров) {
// ...
yield return obj;
}
public IEnumerable MyItr(int end) {
for(int i=0; i < end; i++)
yield return (char) (ch + i);
if (i==5) 
yield break;//заканчивает вызов, далее вызываться не будет(преждевременное завершение )
}

Итератор должен возвращать один из следующих четырех интерфейсов (иначе компилятор сгенерирует сообщение об ошибке):
System.Collections.IEnumerable
System.Collections.IEnumerator
System.Collections.Generic.IEnumerable<T>-наиболее часто
System.Collections.Generic.IEnumerator<T>





#Finalize и #Dispose #IDisposable #Деструктор
освобождения неуправляемых ресурсов

если наследуем от класса с IDispose то тоже надо реализовать
private bool IsDisposed = false;
 
    protected override void Dispose(bool disposing)
    {
        if (IsDisposed) return;
        if (disposing)
        {
            // Освобождение управляемых ресурсов
        }
        IsDisposed = true;
        // Обращение к методу Dispose базового класса
        base.Dispose(disposing);
    }





public class SomeClass: IDisposable
{
    private bool disposed = false;
 
    // реализация интерфейса IDisposable.
    public void Dispose()
    {
        Dispose(true);
        // подавляем финализацию
        GC.SuppressFinalize(this);
    }
 
    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            if (disposing)
            {
                // Освобождаем управляемые ресурсы
            }
            // освобождаем неуправляемые объекты
            disposed = true;
        }
    }
 
    // Деструктор
    ~SomeClass()
    {
        Dispose (false);
    }
}






















c#

#Параллельное #программирование #TPL
#Task
System.Threading.Tasks


после того, как задача завершена, она не может быть перезапущена. => для повторного запуска нужно пересоздать


public delegate void Action()
public Task(Action действие)
public Task(Func<TResult> функция)
public Task(Func<Object, TResult> функция, Object состояние) //задача принимает аргумент состояние


public Task<TResult> StartNew(Func<TResult> функция)
public Task<TResult> StartNew(Func<Object,TResult> функция, Object состояние)
public Task StartNew(Action<Object> action, Object состояние, CancellationToken признак_отмены)


public int Id { get; }
public static Nullable<int> CurrentID { get; }


в методе который передается в task при условии передачи в метод токена отмены параметром
cancelTok.ThrowIfCancellationRequested();//установит IsCanceled и выбросит исключение AggregateException
IsCanceled


Dispose().//только для завершенной задачи, если задача не завершена то InvalidOperationException

исключения
ObjectDisposedException.  если задача освобождена посредством вызова метода Dispose()
AggregateException,  если задача сама генерирует исключение или же отменяется


//1 способ

Task task = new Task(() => Console.WriteLine("Hello Task!"));
task.Start();
//2 способ
//	
Task task = Task.Factory.StartNew((Action action);
//3 способ
Task task = Task.Run(() => Console.WriteLine("Hello Task!"));

//получить результат
Task<int> task1 = new Task<int>(()=>Factorial(5));
        task1.Start();
//эта строка будет ждать завершения выполнения задачи
var f=task1.Result

//остановит поток до выполнения задачи
 task.Wait();
//остановит поток до выполнения всех задач в массиве  tasks
Task.WaitAll(params Task[] tasks)
//остановит поток до выполнения хотя бы 1 задачи в массиве  tasks
Task.WaitAny(params Task[] tasks)

//task2 начнет выполнение после завершения task1

public Task ContinueWith(Action<Task> действие_продолжения)
 Task task2 = task1.ContinueWith(Display);
void Display(Task t)
        {}
||
Task task3 = task1.ContinueWith((Task t) =>
    {
        Console.WriteLine("Id задачи: {0}", Task.CurrentId);
    });




//массивы
Task[] tasks1 = new Task[3]
foreach
 t.Start();
||
for (int i = 0; i < tasks2.Length; i++)
    tasks2[i] = Task.Factory.StartNew(() => Console.WriteLine($"Task {j++}"));

Класс Task имеет ряд свойств, с помощью которых мы можем получить информацию об объекте. Некоторые из них:
AsyncState: возвращает объект состояния задачи
CurrentId: возвращает идентификатор текущей задачи
Exception: возвращает объект исключения, возникшего при выполнении задачи
Status: возвращает статус задачи

#TaskCreationOptions #AttachedToParent
//вложенные задачи и из за параметра внешняя будет "ждать внутреннюю"
var outer = Task.Factory.StartNew(() =>      // внешняя задача
    {
var inner = Task.Factory.StartNew(() =>  // вложенная задача
        {}, TaskCreationOptions.AttachedToParent);
    });
outer.Wait(); // ожидаем выполнения внешней задачи



#Параллельное #программирование #TPL
#Parallel
#thread
теория
Отличия в многозадачности на основе процессов и потоков могут быть сведены к
следующему: многозадачность на основе процессов организуется для параллельного
выполнения программ, а многозадачность на основе потоков — для параллельного выполнения отдельных частей одной программы.



public delegate void ThreadStart()
public delegate void ParameterizedThreadStart(object obj)

public Thread(ThreadStart запуск) //создание потока
newThrd.Start([object param]);//запуск потока, можно передать параметр, если параметр передан то конструктор(ниже)
public Thread(ParameterizedThreadStart запуск)

Name - имя потока, можно задать
public bool IsAlive { get; }
public void Join() //ждет завершения потока, можно указать время
public bool IsBackground { get; set; } //сделать поток фоновым


установить приоритетность потока(чем выше тем чаще получает доступ к цп)
public ThreadPriority Priority{ get; set; }//ThreadPriority-enum


применять в особых случаях
public void Abort() //прервать выполнение потока
Thrd.Abort();
Thrd.Join(); //ожидать прерывания или выполнения
Thrd.Abort (object a);
в методе который в потоке
try {
//первая строка метода

//последняя строка метода
} catch(ThreadAbortException exc) {
Console.WriteLine("Поток прерван, код завершения " +
(int)exc.ExceptionState);//object a

//отменяем прерывание
Thread.ResetAbort();
}



состояния потока 
public ThreadState ThreadState{ get; }


получить текущий поток
public static Thread CurrentThread{ get; }









#Process
public static Process Start(string имя_файла)
//"просит" закрыться
public void Close()
public bool CloseMainWindow() //Если процесс является приложением Windows с графическим пользовательским интерфейсом, true-сообщение получено,false-приложение не имеет главного окна
//закрывает
неконтролируемому прерыванию процесса. Любые несохраненные данные, связанные с прерываемым процессом, будут, скорее всего, потеряны.
public void Kill()
//ждать закрытия
public void WaitForExit()
public bool WaitForExit(int миллисекунд)// false, если он все еще выполняется.





новое


//попытается распараллелить методы, вызывающий поток останавливается и ждет результаты
public static void Invoke(params Action[] actions)

#for
public delegate void Action<in T>(T obj)
public static ParallelLoopResult For (int fromInclusive, int toExclusive, Action<int> body)
первый параметр задает начальный индекс элемента в цикле, а второй параметр - (конечный индекс не включая , i<toExclusive). 
Третий параметр - делегат Action - указывает на метод, который будет выполняться один раз за итерацию
Parallel.For(1, 10, Factorial);
void Factorial(int x)
{}

break так же как в обычном for
public static ParallelLoopResult For(int fromInclusive, int toExclusive, Action<int, ParallelLoopState> body)
public delegate void Action<in T1, in T2>(T argl, T2 arg2)//T1-int T2-ParallelLoopState

ParallelLoopState
public void Break()//все шаги до вызова выполнятся, несколько может выполниться и после вызова
Stop()//если не волнует выполнение шагов

ParallelLoopResult-
public bool IsCompleted { get; }//определяет, завершилось ли полное выполнение параллельного цикла
public Nullable<long> LowestBreakIteration { get; }//если выполнение прервется, то будет содержать переменную-итертор на которой все прервалось(возвращает индекс, на котором произошло прерывание работы цикла)


есть также формы -
 указывать метод, вызываемый по завершении потока каждого цикла.
др.



#ForEach
public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, Action<TSource> body)
public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, Actior<TSource, ParallelLoopState> body)
ParallelLoopResult result = Parallel.ForEach<int>(new List<int>() { 1, 3, 5, 8 },
                Factorial);

остальное см For










 
//остановить задачу #cancel #CancellationTokenSource #CancellationToken
//вне задачи объявить
 CancellationTokenSource cancelTokenSource = new CancellationTokenSource();
    CancellationToken token = cancelTokenSource.Token;
//остановить 
cancelTokenSource.Cancel();
//в task
if (token.IsCancellationRequested)
            {
                return;//отменить задачу
            }

//если операция внешняя передавать ссылку на токен
Task task1 = new Task(() => Factorial(5, token));
void Factorial(int x, CancellationToken token)
{



//прерывание операции в цикле
//также объявить токен и в любом потоке также отменить
//в другом потоке где нужны циклы
try
    {   
        Parallel.ForEach<int>(new List<int>() { 1,2,3,4,5,6,7,8}, 
                                new ParallelOptions { CancellationToken=token}, Factorial);
        // или так
        //Parallel.For(1, 8, new ParallelOptions { CancellationToken = token }, Factorial);
    }
    catch(OperationCanceledException ex)
    {
        Console.WriteLine("Операция прервана");
    }
    finally
    {
        cancelTokenSource.Dispose();
    }


Асинхронные делегаты
public delegate int DisplayHandler();
//выполняем в ассинхронном режиме
//Первый параметр представляет делегат System.AsyncCallback  AsyncCallback указывает на метод, который будет выполняться в результате завершения работы асинхронного делегата
//Второй параметр представляет произвольный объект, с помощью которого мы можем передать дополнительную информацию в метод завершения, указанный в предыдущем параметре. 
IAsyncResult resultObj = handler.BeginInvoke(null, null);
//ждет выполнения
int result = handler.EndInvoke(resultObj);


//с параметрами
// добавляем параметр в делегат и в сам метод
 public delegate int DisplayHandler(int k);
int Display(int k)
        {}
//метод который будет вызываться по завершению
static void AsyncCompleted(IAsyncResult resObj)
        {
            string mes = (string)resObj.AsyncState;//Асинхронные вызовы
}
DisplayHandler handler = new DisplayHandler(Display);
 //1- параметр в метод 2- метод после завершения 3-параметр для метода после завешения
            IAsyncResult resultObj = handler.BeginInvoke(10, new AsyncCallback(AsyncCompleted), "Асинхронные вызовы");

            int res = handler.EndInvoke(resultObj);



#async и #await
ассинхронные методы -суффикс Async
async void DisplayResultAsync()
    {
//возращает int тк есть await если его нет то возвращает task
int result = await FactorialAsync(num);
}
static Task<int> FactorialAsync(int x)
    {
return Task.Run(() =>
        {});

//вызвать метод
DisplayResultAsync();
||
Task t = DisplayResultAsync();
    t.Wait();
||
//.GetAwaiter(), который остановит выполнение в вызывающем потоке, пока задача не завершится, и .GetResult(), который возвращает результат
DisplayResultAsync().GetAwaiter().GetResult();

//ждать выполнение всех задач
 Task<int> t1 = FactorialAsync(num1);
await Task.WhenAll(new[] { t1, t2, t3 });
 var gg=t1.Result





#PLINQ #Parallel #LINQ
Основу PLINQ составляет класс ParallelEnumerable



при возникновении ошибка в 1 потоке прерываются все

#AsParallel выполение запроса разбивая задачу на потоки
//будет обрабатывать коллекцию не по порядку если так будет быстрее и если не быстрее то обработает как обычно
var factorials = numbers.AsParallel().Select(x => Factorial(x));

#ForAll
.ForAll(n => Console.WriteLine(n));
ForAll выполняет действие в каждом потоке для той части которая находится в нем
без ForAll происходит склейка данных в 1 потоке и потом действие для всех элементов

#AsOrdered()
public static ParallelQuery<TSource> AsOrdered<TSource>(this ParallelQuery<TSource> source)
.AsParallel().AsOrdered()
разделяем на потоки и потом выставляем в том порядке как было бы если бы не разделяли

#AsUnordered()
разупорядочивание , если мы упорядочили но дальше какие то операции которые не требуют порядка, ускорит все


обработка ошибок 
catch (AggregateException ex)
{
    foreach (var e in ex.InnerExceptions)
    {
        Console.WriteLine(e.Message);
    }
}

отмена параллельной операции #cancel #CancellationTokenSource
CancellationTokenSource cts = new CancellationTokenSource();
 cts.Cancel();// установить токен для отмены
try{
numbers.AsParallel().WithCancellation(cts.Token)
}
catch(OperationCanceledException ex)
    {
        Console.WriteLine("Операция была прервана");
    }

foreach(var v in mass.AsParallel())//цикл прервется если в другом потоке Cancel();


#TODO
#WithDegreeOfParallelism()//указать максимальное количество процессоров, выделяемых для обработки запроса
#AsSequential()//запросить последовательное выполнение части параллельного запроса
#WithExecutionMode() когда PLINQ должен по умолчанию поддерживать последовательное выполнение, передать методу в качестве параметра признак ParallelExecutionMode.ForceParallelism.










#синхронизация


#Interlocked
тоже самое что и lock но быстрее и проще, для блокировки простых типов
CompareExchange()	Безопасно проверяет два значения на эквивалентность. Если они эквивалентны, изменяет одно из значений на третье
public static int Decrement(ref int location)	Безопасно уменьшает значение на 1
Exchange()	Безопасно меняет два значения местами
public static int Increment(ref int location)	Безопасно увеличивает значение на 1
//+возвращает это же число
int newVal = Interlocked.Increment(ref intVal);
Interlocked.Exchange(ref mylnt, 83);










#Monitor
Monitor.Enter(obj);
у monitor есть метод TryEnter-- он заставляет ждать определенное время а не бесконечность

//эти методы могут вызываться только из заблокированного фрагмента кода(блок lock например)
//временно блокирует поток но  освобождает заблокированный объект пока не продолжит выполнение
поток продолжит выполнение когда другой поток войдет в аналогичное состояние блокировки,  вызывает метод Pulse() или PulseAll()
obj-объект разблокировку которого ожидаем
//останавливает поток и заставляет ждать пока для obj не вызовется Pulse из другого потока
public static bool Wait(object obj) 
public static bool Wait(object obj, int миллисекунд_простоя)
//разрешает заблокировать уже заблокированный obj тому кто следующий в очереди
public static void Pulse(object obj)  возобновляется выполнение первого потока ожидающего своей очереди на получение блокировки
public static void PulseAll(object obj) сигнализирует о снятии блокировки всем ожидающим потокам

#lock преобразуется в monitor
private object obj = new object();
#lock (obj)
{
   // синхронизированная область для obj
}
//преабразуется в
Monitor.Enter(obj);
try
{
   // синхронизированная область для obj
}
finally
{
   Monitor.Exit(obj);
}
if (Monitor.TryEnter(lockObject, 300)) {  
    try {  
        // Place code protected by the Monitor here.  
    }  
    finally {  
        Monitor.Exit(lockObject);  
    }  
}  
else {  
    // Code to execute if the attempt times out.  
}



#spinlock #SpinWait, #SemaphoreSlim и #CountdownEvent, #TODO




#Mutex #мьютекс

public Mutex()
public Mutex(bool initiallyOwned)//если true то им завладевает вызывающий поток

public bool WaitOne(); // блокирует выполнение вызывающего потока до тех пор, пока не станет доступным указанный мьютекс
public void ReleaseMutex() //освобождает

создание именованного(виден не только в текущем процессе)
public Mutex(bool initiallyOwned, string имя)// если true, то владение мьютексом запрашивается
public Mutex(bool initiallyOwned, string имя, out bool createdNew) // createdNew будет иметь логическое значение true, если владение мьютексомбыло запрошено и получено, и логическое значение false, если запрос на владениебыл отклонен


в потоке, получившем мьютекс, допускается вызывать несколько WaitOne() перед вызовом метода
ReleaseMutex(), все эти вызовы будут произведены успешно. => дополнительные вызовы метода WaitOne() не будут блокировать
поток, который уже владеет мьютексом. Но количество вызовов метода WaitOne()
должно быть равно количеству вызовов метода ReleaseMutex() перед освобождением мьютекса.











#семафор  #Semaphore

разрешает доступ к участку не 1 потоку а количеству которое указали в конструкторе
при блокировке -- при икременте ++, если 0 то ждет пока станет >0

public Semaphore(int initialCount, int maximumCount)
initialCount - количество первоначально доступных разрешений
maximumCount — максимальное значение данного счетчика, т.е. максимальное количество разрешений, которые может дать семафор.

см мьютекс
WaitOne()
//return  подсчитанное количество разрешений, существовавших до высвобождения
public int Release()
public int Release(int releaseCount)


именованный семафор
public Semaphore(int initialCount, int maximumCount, string имя)
public Semaphore(int initialCount, int maximumCount, string имя,
out bool createdNew)










#event
1 поток ждет пока вызовется событие в другом потоке
public #ManualResetEvent(bool initialState)//если true, то о событии первоначально уведомляется
WaitOne()//ждем если объект "не активен"
Set()//в другом потоке вызываем событие, "активирует" объект
 Reset()//после вызова события объект события делаем "не активным", для разблокировки надо снова вызывать Set()



public #AutoResetEvent(bool initialState)
все как у ManualResetEvent но метод WaitOne() после того как дождался очереди вызывает Reset()







#Barrier Вынуждает потоки ожидать появления всех остальных потоков в указанной точке, называемой барьерной
#CountdownEvent Выдает сигнал, когда обратный отсчет завершается
#ManualResetEventSlim Это упрощенный вариант класса ManualResetEvent
#SemaphoreSlim Это упрощенный вариант класса Semaphore






attr
блокировка всего метода экземпляра(this). Если же метод относится к типу static, то блокируется его тип
[MethodImplAttribute(MethodImplOptions.Synchronized)]
применять очень аккуратно перечитать как и тд





#Synchronization]
#[Synchronization]
тоже синхронизация но такое





#ReaderWriterLock
блокировка только на запись













#Lazy

Lazy<Library> library = new Lazy<Library>();
library.Value;//создаст объект только тут!











#рефлексия #reflection

#Nameof - строковое представление метода
WriteLine(nameof(person.Address.ZipCode)); // prints "ZipCode"

#typeof #GetType
получить тип
Type myType = typeof(className);
Type myType = object.GetType();
//1- полное название с namespace 2-генерить ли исключение если не найдено 3-учитывать ли регистр у 1 параметра
Type myType = Type.GetType("TestConsole.User", false, true);

Туре а1 = typeof (А<>)
Console.Write (a1.GetGenericArguments().Count())




myType.IsAbstract();
myType.IsClass();


Type: #MemberInfo
DeclaringType //тип класса или интерфейса в котором объявляется отражаемый член
MemberType //возвращает перечисление .тип члена. является ли член полем\методом\свойством\событием\конструктором
MetadataToken //
Name //имя файла
ReflectionType //тип отражаемого объекта

абстрактные методы
GetCustomAttributes // получить список спец атрибутов
IsDefined // проверить есть ли такой атрибут

ConstructorInfo[] GetConstructors() // получить список конструкторов
GetEvents()
GetFields()
GetMembers() //список членов
GetMethods()
GetProperties //список свойств

свойства только для чтения
Attribures //получить атрибуты
BaseType //получить непосредственный базовый тип 
FullName
IsAbstract
IsArray
IsClass
IsEnum
IsGenericType //если обобщенный
Namespace


var mth=GetMethods([BindingFlags fl1|BindingFlags f2|...]);//fl-перечисление которое сообщает какие именно методы нужны

BindingFlags.  //если указан 1 значение перечисление и метод не возвращается, указать еще через | но те которые не противоречат
DeclaredOnly: получает только методы непосредственно данного класса, унаследованные методы не извлекаются
Instance: получает только методы экземпляра
NonPublic: извлекает не публичные методы
Public: получает только публичные методы
Static: получает только статические методы


foreach(var i in mth){
//вызов метода
i.Invoke(reflect_obj,args)//reflect_obj - объект для которого будет вызываться метод
i.Invoke(null,args)//reflect_obj - static метод
i.Invoke(null,null)//reflect_obj - static метод, не передаем параметры
i.ReturnType.Name
i.Name
var prms=i.GetParameters();
foreach(var p in prms){
p.ParameterType.Name
p.Name
}
}

var cons=GetConstructors();
foreach(var i in cons){
(object)i.Invoke(args);
}


var instance = FormatterServices.GetUninitializedObject(Type a);//создать объект сам достанет конструктор и вызовет, даже если у него есть параметры









#Assembly
если есть exe\dll то все тоже самое можно делать с помощью этого

var a=Assembly.LoadFrom(string path)
a.GetTypes();
//дальше просто с помощью рефлексии можно делать что угодно





#LINQ
для параллельного выполнения см PLINQ
применяется для IEnumerable<T>  (реализованы как методы расширения в System.Linq.EnumeraЫe)

формирование запроса
var t=from n in nums where n>0 select n;
var t=nums.where(x1=>x1>0);
выполнение запроса
t.Count();
t.ToList();
//изменить nums
t.ToList();//другой результат


//результат-каждый элемент mass1 с каждым элементом mass2
from x1 in mass1
from x2 in mass2
select new{x1,x2};



если команда применяется к data типу, то она не вернет null (int[]).FirstOrDefault(x1=>)==null//не правильно тк null не вернется
что бы не 0 возвращалось 
int? nullableId = GetNonNullableInts().Cast<int?>().FirstOrDefault();


//#TODO хз можно ли так
var people = db.People.Where("it.Name LIKE @searchTerm", new ObjectParameter("searchTerm", searchTerm));
//не получилось вызвать like
from c in dc.Organization where #SqlMethods.Like(c.Hierarchy, "%/12/%") select *;



#Select: определяет проекцию выбранных значений
#Where: определяет фильтр выборки
#OrderBy: упорядочивает элементы по возрастанию
#OrderByDescending: упорядочивает элементы по убыванию
#ThenBy: задает дополнительные критерии для упорядочивания элементов возрастанию
#ThenByDescending: задает дополнительные критерии для упорядочивания элементов по убыванию
#Join: соединяет две коллекции по определенному признаку
#GroupBy: группирует элементы по ключу
#ToLookup: группирует элементы по ключу, при этом все элементы добавляются в словарь
#GroupJoin: выполняет одновременно соединение коллекций и группировку элементов по ключу
#Reverse: располагает элементы в обратном порядке
#All: определяет, все ли элементы коллекции удовлятворяют определенному условию
#Any: определяет, удовлетворяет хотя бы один элемент коллекции определенному условию
#Contains: определяет, содержит ли коллекция определенный элемент
#Distinct: удаляет дублирующиеся элементы из коллекции
#Except: возвращает разность двух коллекций, то есть те элементы, которые содератся только в одной коллекции
#Union: объединяет две однородные коллекции
#Intersect: возвращает пересечение двух коллекций, то есть те элементы, которые встречаются в обоих коллекциях
#Count: подсчитывает количество элементов коллекции, которые удовлетворяют определенному условию
#Sum: подсчитывает сумму числовых значений в коллекции
#Average: подсчитывает cреднее значение числовых значений в коллекции
#Min: находит минимальное значение
#Max: находит максимальное значение
#Take: выбирает определенное количество элементов
#Skip: пропускает определенное количество элементов
#TakeWhile: возвращает цепочку элементов последовательности, до тех пор, пока условие истинно
#SkipWhile: пропускает элементы в последовательности, пока они удовлетворяют заданному условию, и затем возвращает оставшиеся элементы
#Concat: объединяет две коллекции
#Zip: объединяет две коллекции в соответствии с определенным условием
Избыточные элементы в любой из входных последовательностей игнорируются. Операция Zip не поддерживается в запросах к базам данных.
int[] numbers = { 3, 5, 7 }; string[] words = { "three", "five", "seven", "ignored" }; 
nurnbers.Zip (words, (n, w) => n + "=" + w); 
приводит к получению последовательности со следующими элементами: 
З=three 
S=five 
7=seven


#First: выбирает первый элемент коллекции
#FirstOrDefault: выбирает первый элемент коллекции или возвращает значение по умолчанию
#Single: выбирает единственный элемент коллекции, если коллекция содердит больше или меньше одного элемента, то генерируется исключение-- генерируют исключение при наличии более одного совпадения
#SingleOrDefault: выбирает первый элемент коллекции или возвращает значение по умолчанию--генерируют исключение при наличии более одного совпадения
#ElementAt: выбирает элемент последовательности по определенному индексу
#ElementAtOrDefault: выбирает элемент коллекции по определенному индексу или возвращает значение по умолчанию, если индекс вне допустимого диапазона
#Last: выбирает последний элемент коллекции
#LastOrDefault: выбирает последний элемент коллекции или возвращает значение по умолчанию






#into

group val by val.column into val_ where val_.count()>2 select val_;  
select с. ToUpper () into upper //и дальше с upper что хотим делаем
from name in names 
group name.ToUpper() bу name.Length into grouping 
where grouping.Coun t () == 2 
select grouping




#let

from str in strs
let val=str.ToCharArray()





#linq #join
var phones = db.Phones.Join(db.Companies, // второй набор
        p => p.CompanyId, // свойство-селектор объекта из первого набора
        c => c.Id, // свойство-селектор объекта из второго набора
        (p, c) => new // результат
        {
            Name=p.Name, 
            Company = c.Name, 
            Price=p.Price
        });

from val_a in mass_a
join val_b in mass_b
on val_a = val_b;// = == equals












#деревья   #Expressions
используются для обращения к бд
см delegate
Expressions<Func<int,int,bool>> IsDel=(n,d)=>n==d;
Func<int,int,bool> t=IsDel.Compile();
t(10,20);








#TODO #linq #where #PredicateBuilder #Predicate #or

var query = collection.Where( c => c.A == 1 || c.B == 2 );
//ниже эквивалент
есть 2 версии обе с nuget
//using Mono.Linq.Expressions;  - не разобрался как работать
using Binbin.Linq;   - ставить не последние версии тк они не ставятся на .net framework 4.5-6, использование как ниже

var predicate = PredicateBuilder.False<Foo>();//False- в данном случае уже идет как первое условие=> если для такого предиката добавлять только через AND то он не вернет ничего=>если нужно OR то юзать false если AND то юзать true
 predicate = predicate.Or( f => f.A == 1 );
 if (allowB)
 {
    predicate = predicate.Or( f => f.B == 1 );
 }

 var query = collection.Where( predicate );






















#namespace
//можно объявить несколько с одинаковым именем(сложатся в 1), 
namespace name{}
//можно вложить namespace в namespace
namespace name{
namespace name1{}}
//2 способ объявить вложенность
namespace name.name1{}



#using #примитивы 
using name_namespace;
using псевдоним=имя;
using new_name=name_namespace.classname;
using static System.Console;//будут доступны все статическое класса


using(var tmp=){
//раскладывается как блок try с .Dispose() в finally части
}//вызовется метод disposing, если его нет- ошибка


#::
если есть одноименный класс(например) в нескольких пространствах имен и мы подключаем оба то можно устранить неопределенность
name_namespace1::class_name val=new name_namespace1::class_name ();
//из глобального пространства имен
#global
global::class_name val=new global::class_name ();








#препроцессор #предпроцессор

#define
#define name_ind//объявить
#undef name_ind//удалить

#region//просто для удобства
#endregion

#pragma

#error name error//прервать компиляцию и показать ошибку


#if name_ind
..
#else
..
#elif
..
#endif//относится только к if



#line
#warning name error//показать предупреждение при компиляции






#public
публичный
#private
частный
при наследовании, наследуется но к нему есть доступ только через методы которые тоже были унаследованы(this.val не получится) и у которых был доступ к этому полю, если мы их не переопредляем
#protected
тоже самое что private но при наследовании мы можем использовать(this.val)
#internal
доступно только в пределах сборки
protected internal: совмещает функционал двух модификаторов. Классы и члены класса с таким модификатором доступны из текущей сборки и из производных классов.
private protected: такой член класса доступен из любого места в текущем классе или в производных классах, которые определены в той же сборке.



#immutable 
Это значит, что данные, хранящиеся в переменной, не могут быть изменены. При этом заметьте, что значение переменной может быть изменено - путём отказа от использования старых данных, которые могут быть изменены.
 Оригинальные данные остаются в памяти, а новые значения создаются вновь, в новой области памяти. Пример тип String.




#partial
можно разбить что либо на несколько кусков
partial class a{
math1}
partial class a{
math2}


если применили к методу
то можно не реализовывать(при вызове такого метода(не реализованного) не произойдет вообще ничего, он будет проигнорирован)
ограничения- обязательно возвращают void, не могут быть virtual, в них нельзя использовать out, не может быть модификатора доступа
partial void meth();
partial void meth(){}








#is 
вернет bool если можно\нельзя привести тип
(bool)(val is classname)


#TODO не совсем понял/ доступно с 17 студии
if(x is int i)


#as
//приведет тип если можно и если нет то вернет null
(val is classname)


























#деконструкторы #Deconstruct
class Person
{
public void Deconstruct(out string name, out int age)
    {
        name = this.Name;
}}
(string name, int age) = person;


#Индексаторы #[]
могут быть перегружены
class Library
{
    Book[] books;
 public Book this[int i, int j]{}
 public Book this[int index]
    {
        get
        {
            return books[index];
        }
        set
        {
            books[index] = value;
        }
    }






#обработка #ошибки
#try #catch #finaly #throw


try{}
catch{

throw new Exception();//выбросить новое исключение
}
catch(Exception e){
throw e;//пробросить исключение дальше, но  свойство StackTrace исключения больше не будет отражать исходную ошибку
throw;//пробросить исключение дальше
}
catch(Exception e)if(e.Source==""){
}



#Exception


свойства Exception
Message - характер ошибки
StackTrace - строка в вызовами стека из за которых случилась ошибка
TargetSite - объект-метод сгенерировавший исключение
InnerException - внутренее исключение
методы
ToString

конструкторы
public Exception()
public Exception(string сообщение)
public Exception(string сообщение,Exception внутреннее исключение)
protected Exception(System.Runtime.Serialization.SerializationInfo информация,System.Runtime.Serialization.StremingContext контекст)


создание своих исключений
class name:Exception{
//нужно просто реализовать все конструкторы
public name():base(){}
//....
}


#cath #try #finally
должны ловить исключения от частного к общему(сначала идет последний ребенок, потом его родитель, потом Exception)








#Сериализация #serialize #serealize
[Serializable]
class Person
{
[NonSerialized]
    public string accNumber;
//точно также можно делать и с массивом и тд
 // создаем объект #BinaryFormatter
            BinaryFormatter formatter = new BinaryFormatter();
            // получаем поток, куда будем записывать сериализованный объект
            using (FileStream fs = new FileStream("people.dat", FileMode.OpenOrCreate))
            {
                formatter.Serialize(fs, person);
            }
 
            // десериализация из файла people.dat
            using (FileStream fs = new FileStream("people.dat", FileMode.OpenOrCreate))
            {
                Person newPerson = (Person)formatter.Deserialize(fs);
            }

#SOAP. #SoapFormatter
https://metanit.com/sharp/tutorial/6.3.php

#XML. #XmlSerializer
https://metanit.com/sharp/tutorial/6.4.php

#JSON. #DataContractJsonSerializer

using Newtonsoft.Json;
data = JsonConvert.DeserializeObject<AllData>(upload_text);
//mass ---- var g= JsonConvert.DeserializeObject<test_t[]>(json);
str=JsonConvert.SerializeObject(section);
// через потоки

DataContractJsonSerializer jsonFormatter = new DataContractJsonSerializer(typeof(Person[]));
 
            using (FileStream fs = new FileStream("people.json", FileMode.OpenOrCreate))
            {
                jsonFormatter.WriteObject(fs, people);
            }
 
            using (FileStream fs = new FileStream("people.json", FileMode.OpenOrCreate))
            {
                Person[] newpeople = (Person[])jsonFormatter.ReadObject(fs);

            }


если не известен класс но знаем поля
using Newtonsoft.Json;  //JSON.NET
using Newtonsoft.Json.Linq;
var o = JObject.Parse(json);
var accessToken = (string)o["access_token"]; // "13a85707de16fbb1c290250872f30e0b"
var errorCode = (int)o["error"]["code"];     // 0
var duration = TimeSpan.FromSeconds((double)o["duration"]);


разрешить ответ на get запрос #json
return Json(data, JsonRequestBehavior.AllowGet);




#расширение #расширения #extension #extends

Любой совместимый метод экземпляра всегда будет иметь преимущество над расширяющим методом - даже когда параметры расширяющего метода дают более точное соответствие по типам. 
если 2 метода с одинаковой сигнатурой то вызывать как обычный static метод
 если один расширяющий метод имеет более специфичные аргументы, то ему будет отдаваться предпочтение
//создать static class 
//подключить это namespase к месту где будет использовать этот метод

public static class StringExtension
{
//this перед тем параметром к которому это будет применяться
    public static int WordCount(this string str, char c)
    {}
((string)str).WordCount((char)c);




#delegate #делегаты
-объект инкапсулирующий методы

1. Событие нельзя запустить вне класса, в котором оно было объявлено=> больше защищенность 
2. События могут быть помещены в интерфейс.(делегаты только как свойства могут быть помещены, вроде)
3. И событие и делегат можно объявить полем класса, но в отличие от делегата, событие не может быть локальной переменной метода 

Делегаты являются неизменяемыми, так что при использовании операции+= или -= фактически создается новый экземпляр делегата, который присваивается существующей переменной.
Если делегат имеет возвращаемый тип  вернется значение из последнего вызванного метода. возвращаемые значения Предшествующих методов  отбрасываются.
Все типы делегатов : System.MulticastDelegate: System.Delegate. Операции+, -, += и -=, транслируются в статические методы Combine и Remove класса System.Delegate.


delegate возвращаемый_тип name_del(type param1,type param2)

можно закинуть любой метод(статика \функцию\метод экземпляра и что угодно)
могут быть обобщенными

name_del name_del_obj=new name_del([meth]);//объявление
name_del name_del_obj=meth;//объявление, сокращение для new a(meth)

name_del_obj=meth;//убрать все методы и добавить новый
name_del_obj+=meth;//добавить новый метод, добавлять также можно и делегат
name_del_obj-=meth;//удалить новый метод, удалять также можно и делегат

name_del_obj();//сокращение для name_del_obj.Invoke();

если параметр передавать через ref то он будет передаваться в каждый метод и измененный после него идти в след метод

его можно объявить в классе(не создать объект а именно объявить)
delegate void Dl(); 
delegate void D2(); 
Dl dl = Methodl; 
D2 d2 = dl; / / Ошибка на этапе компиляции 
Тем не менее, следующее разрешено: 
D2 d2 = new D2 (dl); 
Экземпляры делегатов считаются равными, если они имеют один и тот же целевой метод (методы). Для групповых делегатов важен порядок следования целевых методов.







 #standart #стандартные
//стандартные делегаты не надо объявлять они уже есть

#Action
public delegate void Action<T1,T2,....T16>(T obj1,T obj2... T obj16)
Action<int, int> op=(a,b)=>{return;};

#Predicate
Predicate<int> isPositive =  (int x)=>{ return x > 0; };

#Func
//последний параметр всегда выходной
Func<T> isPositive
Func<T1, T2,... T16,TResult>
Func<int> isPositive=()=>{return 1;}
 Func<int, int> retFunc =( x)=>{return x;}





#ковариантность #контрвариантность #контравариантность для делегатов
delegate X name_del(Y param)

Y:X

X meth1(X o);
Y meth2(Y o);

name_del delobj;

#ковариантность
возвращаемый тип может быть наследником
delobj=meth2;


#контрвариантность #контравариантность
тип параметра может быть базовым
delobj=meth1;
delobj(X);
delobj(Y);//Y:X
тк тк мы потом будем передавать в метод который будет в делегате происзодное от базового(X) и он приведется к базовому


#Инвариантность
 позволяет использовать только заданный тип


#вариантность для обобщенных делегатов
#ковариантность
out-- выходное значение
delegate T name_del<out T>()
можно присвоить метод где параметр будет T или ребенком T


#контрвариантность
in-- входные параметры
delegate bool name_del<in T>(T obj)
можно присвоить метод где параметр будет T или родителем T
и объект T не может возвращаться






#анонимные #anonim #anonymous

//только для чтения
var f=new{x1,x2,x3.Id};//x1 x2 Id
var f=new{val1=x1,val2=x2};


коллекция анонимных типов(можно через dynamic)
// create the first list by using a specific "template" type.
var list = new [] { new { Name="", Phones=new[] { "" } } }.ToList();
// clear the list.  The first element was just an example.
list.Clear();
// start adding "actual" values.
list.Add(new { Name = "Krishna", Phones = new[] { "555-555-5555", "666-666-6666" } });










#анонимные #функции  #anonim #anonymous #function  #=> #лямбда


name_del delobj=delegate{/*код функции*/};
delobj=delegate(type val){/*код функции*/};
особенность такой штуки в том что можно присвоить объекту делегата который принимает параметры такой анонимный метод без параметров


через лямбды
скобки нужны если несколько параметров, параметров нет, или если явно указываем тип параметра
если есть =>{} то невозможно создать expression и называется лямбда оператор если нет то лямбда выражение

delobj=(type val)=>{/*код функции*/};
delobj=(val)=>{/*код функции*/};
delobj=val=>{/*код функции*/};
delobj=()=>{/*код функции*/};
{
delobj=(type val)=>/*код функции в 1 строку без return*/;
delobj=val=>val+2;
}
del myDelegate = x => x * x;  

// #древо выражений #деревья #дерево
 #Expression<del> myET = x => x * x; 

в /*код функции*/
можно использовать return
{#замыкание
можно захватывать внешние переменные, которые не будут уничтожены пока не уничтожатся все методы которые захватывают+ не будет других ссылок на нее
пример
method(){
int t=10;
delobj=delegate{t++;}
}
delobj();//увеличит на 1 и станет 11
delobj();//увеличит на 1 и станет 12
}




#event  #TODO
см delegate

могут быть объявлены в интерфейсах, 
могут быть абстрактными(только если без аксессоров),
могут быть virtual и sealed
event делегат_события имя_события;
delegate void Hand();
event Hand EventName;


События могут быть виртуальными, переопределенными, абстрактными или запечатанными. Они также могут быть статическими.

С# обеспечивает безопасность в отношении потоков во время обновления делегата, если это переопределить то будет не потокобезопасно
event Hand EventName{
add{
priceChanqed += value; 
}
remove{
priceChanqed -= value; 
}
}



EventName evt+=method;
if(evt!=null)
evt();



рекомендованная структура событий(уже есть предопределенные делегаты) #EventHandler #EventsArgs
class MyEventsArgs:EventsArgs{}
EventsArgs.Empty

delegate void Delname(object source,MyEventsArgs arg)

public event EventHandler<MyEventArgs> someEvent;//без обобщения если EventsArgs не переопределяем






#перегрузка

#operator #перегрузка #операторов
при перегрузке не должны изменяться те объекты, которые передаются в оператор через параметры
class Counter
{
public static возвращаемый_тип operator оператор(параметры)
{  }
public static Counter operator +(Counter c1, Counter c2)

зависимые друг от друга(противоположные) надо перегружать оба сразу
public static bool operator (>||<)(Counter c1, Counter c2) 
public static Counter operator ++(Counter c1)
{
    return new Counter { Value = c1.Value + 10 };
}
для if()
public static bool operator true(Counter c1)
  public static bool operator false(Counter c1)  

логические
public static bool operator (|,!,&)(Counter c1, Counter c2) 

укороченные логические
нужно перегрузить true false
нужно перегрузить(возможно) !
нужно перегрузить |, & - возвращаемый тип -объект для которого if(объект) -true
public static Counter operator (|)(Counter c1, Counter c2) 





#приведение #типов #перегрузка
#explicit-явное (type)obj  #implicit-не явное
public static implicit|explicit operator Тип_в_который_надо_преобразовать(исходный_тип param){
return new Тип_в_который_надо_преобразовать(param);
}



#интерфесы #interface 
все внутри без уровня доступа
при реализации, методы от интефейса не должны быть override
interface IName{
//свойство не будет самореализуемым, get\set тоже без уровня доступа
int nm{
get;
set;
}

return_type this[type val]{
get;set;
}

void methodname(){}
}

явная реализация метода
class g: IName{
void IName.methodname1(){}//без уровня доступа
public void methodname(){}

}
g g_=new g();
IName g1=new g();
g_.methodname1();//нельзя, надо сначала упаковать
g1.methodname1();


class g: IName{
void virtual methodname1(){}//разрешаем переопределение для наследников
void virtual IName.methodname1(){}//так нельзя
}


public interface IUndoaЫe { void Undo();
public class TextBox : IUndoaЫe
{
void IUndoaЫe.Undo()=> Console. Wri teLine ( "TextBox. Undo") ; 
}
public class RichTextBox TextBox, IUndoaЫe
{
public new void Undo ()=> Console.WriteLine ("RichTextBox.Undo"); //при вызове из класса вызовется этот метод, при вызове из интерфейса тоже
}

#ковариантность #контрвариантность


#ковариантность
out-- выходное значение
interface IMyInt<out T>{
//можно T применять только для возвращаемого типа, нельзя использовать для ограничения(where X:T)
//может ПРИСВОИТЬ ссылку на любой класс производный от T или сам T
T GetObj();
}
//при реализации интерфейса ключевое слово не указывается(ни в class ни в методах)
class Myclass<T>:IMyInt<T>{}
но указывается при наследовании только в ребенке интерфейса
interface Myclass<out T>:IMyInt<T>{}

class a{}
class b:a{}
IMyInt<a> alp=new Myclass<a>();//доступно в любом случае
alp=new Myclass<b>();//доступно из за ковариантности
ВЫВОД- позволяет засунуть в объект родителя объект ребенка но только эта иерархия не на сам класс а на обобщенный тип, и этот обобщенный тип применяется только к return type методов


#контрвариантность
in-- входные параметры
interface IMyInt<in T>{

void GetObj(T obj);
}
//при реализации интерфейса ключевое слово не указывается(ни в class ни в методах)
class Myclass<T>:IMyInt<T>{}
но указывается при наследовании только в ребенке интерфейса
interface Myclass<in T>:IMyInt<T>{}

class a{}
class b:a{}
IMyInt<a> alp=new Myclass<a>();//доступно в любом случае
IMyInt<b> bet=new Myclass<b>();//доступно в любом случае
bet=new Myclass<a>();//доступно из за контрвариантности
bet=alp;//доступно из за контрвариантности
ВЫВОД- позволяет засунуть в объект ребенка объект родителя но только эта иерархия не на сам класс а на обобщенный тип, и этот обобщенный тип применяется только к параметрам методов
в метод можем передать родителя T












#IEquatable IEquatable<T> - Equals
для сравнения(определения равенства)



#IComparable - CompareTo
IComparable<T>
для сравнения(для определения порядка следования)


#Sort()
//не обобщенная версия надо приводить к типам
public interface IComparable
{
    int CompareTo(object o);
}
//обобщенная, приводить к типу не надо
IComparable<Person>
 public int CompareTo(Person p)
    {}

Меньше нуля. Значит, текущий объект должен находиться перед объектом, который передается в качестве параметра
Равен нулю. Значит, оба объекта равны
Больше нуля. Значит, текущий объект должен находиться после объекта, передаваемого в качестве параметра

PeopleComparer--- класс которые реализует интерфейс #IComparer<Person>
Array.Sort(new[]Person, new PeopleComparer());




#сравнение #равенство #IComparer
IComparer<Person>
interface IComparer
{
    int Compare(object o1, object o2);
}

если первый объект больше второго, то возвращается число больше 0, если меньше - то число меньше нуля; если оба объекта равны, возвращается ноль.






#ICloneable #clone()
//сам интерфейс
public interface ICloneable
{
    object Clone();
}
//реализация через #MemberwiseClone--поверхностное копирование(если есть ссылки внутри то останутся ссылками на те же объекты)
public object Clone()
    {
        return this.MemberwiseClone();
    }



#IConvertible
преобразрвания типов



#IFormatProvider #IFormattable





#IObservable<T> #IObserver<T>
паттерн #наблюдатель
IObserver<T> - тот кто подписывается
Subscribe - подписать
OnNext отправить данные наблюдателю
OnError отправить сообщение об ошибке
OnCompleted - указывает на то что наблюдаемый объект прекратил отправку сообщений








#abstract


В интерфейсе все методы (свойства и т.д.) абстрактны и не имеют реализации. В абстрактном классе некоторые методы могут быть реализованы. 
В интерфейсе члены не могут иметь модификатора видимости (все они являются public по умолчанию), а в абстрактном классе члены могут иметь модификатор видимости.


Абстрактный класс — класс, который имеет хотя б 1 абстрактный метод; его обозначают abstract.
Интерфейс — такой же абстрактный класс,только в нем нет свойств и не определены тела у методов.

Таким образом, функционально любой интерфейс является абстрактным классом, но абстрактный класс не является интерфейсом.

в абстр классе пишем override для абс метода, дя интерфейса нет
Основные отличия интерфейса и абстрактного класса
•	абстрактный класс может содержать свойства
•???	интерфейс не содержит свойств(полей)
•	абстрактный класс может содержать тела методов
•	интерфейс не содержит тел методов, только их объявление
•	абстрактный класс наследуется (etxends)
•	интерфейс реализуется (implements)
•	наследник имеет только одного родителя (абстрактный класс)
•	наследник может реализовывать методы нескольких интерфейсов
•	наследник не обязан содержать реализацию методов абстрактного класса-родителя
•	наследник обязан содержать реализацию всех методов реализуемого интерфейса




















#ref 
таким модификатором нельзя пометить необязательные параметры

ref local

int x = 5;
ref int xRef = ref x;

будет ссылаться на элемент массива
ref int numberRef = ref Find(4, numbers);
static ref int Find(int[] numbers)
{
return ref numbers[0];//будет ссылаться на элемент
}


#out
обязательно должна быть установлена, в целом применяется как ref
в новой версии можно объявить так(при вызове метода)
meth(out var x,(int)10);




#обобщения  #обобщение #<>
могут быть обобщенные классы, интерфейсы, структуры,методы,делегаты
хранятся в обобщенной форме , а по мере необходимости создаются конкретные экземпляры классов cl<int> cl<string> - разные классы


ограничения:
свойства, операторы, индексаторы и события не могут быть обобщенными, но могут использовать в обобщенном классе с параметрами обобщенного типа этого класса
к обобщенному методу нельзя применять модификатор extern
типы указателей нельзя использовать в аргументах типа
если в обобщенном классе есть поле static то оно свое для каждого типа класса(cl<int> cl<string>-разные, cl<string> cl<string> -одно поле)



class Transaction<T> where T: Account
{
    public T FromAccount { get; set; }
}
class Transaction<T> 
{
    public T FromAccount { get; set; }
}
Transaction<Account> transaction1 = new Transaction<Account>
        {
}

//ограничение- должен быть тип значения
//ограничение должно быть 1 по порядку
class Account<T> where T : struct
{}
//ограничение- должен быть ссылочный тип
//ограничение должно быть 1 по порядку
class Transaction<T> where T : class
{}

//есть конструктор без параметров
//должно идти последним по порядку, использовать можно только конструктор без параметров, нельзя использовать с ограничением типа значения
class Transaction<T> where T : new()
{}

class Transaction<U, V>
        where U : Account<int>
        where V : struct
{}
class Transaction<U, V>
        where U : V{}
public static void Transact<T>(T acc1, T acc2, int sum) where T : Account<int>{}

public void nameMeth<T>(int g,T t) where T:class{}
//оба вызова норм, тип он сам подставит
nameMeth<string>(10,"");
nameMeth(10,"");

если одновременное ограничение типа на класс и на интерфейс то сначала указывается класс


delegate void name<T>();
name<int> nameObj=;



при обобщенном интерфейсе
ограничения интерфейса нужно продублировать ограничениями в класс который его реализует


при перегрузке не должно быть так, тк n<int,int>- все сломает
class n<T,V>{
void nnn(V a);
void nnn(T a);
}






#default

obj=default(тип);
при обобщении
obj=default(T);










#exeption #try #catch #finally
после try обязательно catch или finally или оба
более "узкие\специфичные" обработчики должны идти сначала
перехватить можно не все исключение вроде, #TODO какие если true
try{
throw new Exception("Длина строки больше 6 символов");
}
catch(... ex){
ex.Message
}
catch(Exeption ex) when (y==0){
ex.Message
}
catch{
throw;//пробрасываем исключение дальше
}
finally{
//выполняется всегда
}


-----------------------------



-----------------------------


#error
не работает точка останова  удалить все файлы в проекте .pdb




#image #uploadImage #img

отображение из байтов 
 <div class="div_image_standart" style="background:url( data:image/jpeg;base64,@Convert.ToBase64String(a.Data)) no-repeat;background-size: cover;">
        </div>

растянет очень криво но ничего не обрежет, и пустых мест не будет
<div id="main_tag_one_img_id_@a.Id" class="class_image_standart" style="background:url( data:image/jpeg;base64,@Convert.ToBase64String(a.Data)) no-repeat;background-size: 100% 100%;"> 
</div>

растянет не криво, но только по 1 краю(пропорции остаются), есть пустые места
<div id="main_tag_one_img_id_@a.Id" class="class_image_standart" style="background:url( data:image/jpeg;base64,@Convert.ToBase64String(a.Data)) no-repeat"> 
</div>
.class_image_standart{
    background-position: center;
    background-size: contain;
}


загрузка картинок на сервер сюда код формы метод для преобразования картинок в байты и тд
@using (Html.BeginForm("Add_new_image", "Home", FormMethod.Post, new { enctype = "multipart/form-data" }))
                    {
                        @Html.Hidden("from", "Personal_record")
                        @Html.Hidden("for_what", "main_img")

                        <input type="file" name="uploadImage[0]" />
                            <input type="submit" class="submit" value="Поделиться" />
                    }



#ajax

var files;
    $('input[type=file]').change(function () {
        files = this.files;
    });
var data = new FormData();
        $.each(files, function (key, value) {
            data.append('uploadImage', value);
        });

        data.append('obj.Text','this is test text');

        $.ajax({
            url: '/Physic/Create',
            type: 'POST',
            data: data,
            cache: false,
            dataType: 'json',
            processData: false, // Не обрабатываем файлы (Don't process the files)
            contentType: false, // Так jQuery скажет серверу что это строковой запрос
            success: function (respond, textStatus, jqXHR) {

                var ttt = 10;
            }
        });











 public ActionResult AddMemePerson(string id_user, HttpPostedFileBase[] uploadImage,string text)
{  
var list_img_byte = Get_photo_post(uploadImage);
}

public static List<byte[]> Get_photo_post(HttpPostedFileBase[] uploadImage)
        {

            /* сохранение картинок как файл ...
              HttpPostedFileBase image = Request.Files["fileInput"];
            
            if (image != null && image.ContentLength > 0 && !string.IsNullOrEmpty(image.FileName))
            {
                string fileName = image.FileName;
                image.SaveAs(Path.Combine(Server.MapPath("Images"), fileName));
            }
             
             * */
            List<byte[]> res = new List<byte[]>();
            if (uploadImage != null)
            {
                foreach (var i in uploadImage)
                {
                    try
                    {
                        byte[] imageData = null;
                        // считываем переданный файл в массив байтов
                        using (var binaryReader = new BinaryReader(i.InputStream))
                        {
                            imageData = binaryReader.ReadBytes(i.ContentLength);
                        }
                        // установка массива байтов
                        res.Add(imageData);
                    }
                    catch
                    {}
                }

            }

            return res;
        }








#uploadfile #upload #file
//получить текст файла
FunctionName(HttpPostedFileBase file) 
{ 
string result = new StreamReader(file.InputStream).ReadToEnd(); 
}


#image #byte #img

//image from byte
public static Image byteArrayToImage(byte[] byteArrayIn)
        {
            MemoryStream ms = new MemoryStream(byteArrayIn);
            Image returnImage = Image.FromStream(ms);
            return returnImage;
        }




#image to byte
//baseFormat = (Image)imageIn.RawFormat
public static byte[] ImageToByteArray(System.Drawing.Image imageIn, ImageFormat baseFormat)
        {
            using (var ms = new MemoryStream())
            {
                //var encoder = GetEncoderInfo("image/jpg");
                imageIn.Save(ms, baseFormat);//System.Drawing.Imaging.ImageFormat.Jpeg 
                return ms.ToArray();
            }
        }




#resize
//меняем размер картинки

 private static Image ResizeImage(int newSize, Image originalImage)
        {
            if (originalImage.Width <= newSize)
                newSize = originalImage.Width;

            var newHeight = originalImage.Height * newSize / originalImage.Width;

            if (newHeight > newSize)
            {
                // Resize with height instead
                newSize = originalImage.Width * newSize / originalImage.Height;
                newHeight = newSize;
            }

            return originalImage.GetThumbnailImage(newSize, newHeight, null, IntPtr.Zero);
        }








#io  #file #load #byte

#потоки 

#stream
методы
close
flush - заставляет вывести все, если не юзнуть то данные выводятся блоками
readByte
Read
seek  - установить положение в потоке
writebyte
write

свойства
canread
canseek
canwrite
length - длина потока
position текущее положение доступно и для чтения и для записи
readtimeout
writetimeout

#BufferedStream:stream - заключает в оболочку байтовый поток и добавляет буферизацию

#StreamReader #StreamWriter #TODO


#UnmanagedMemoryStream:stream - байтовый поток который использует неупраляемую память для хранения

!!!символьные потоки
#TextReader #TextWriter
методы TextReader
...
close
int peek - получает следующий символ из потока но не удаляет его, возвращает -1 если нет доступных символов

методы TextWriter
close
flush



вывод текст
в streamWriter: TextWriter заключается filestream(или другой наследник stream)
public streamWriter(Stream)
public streamWriter(string путь)
public streamWriter(string путь,bool append)//если true то в конец



#BinaryReader #BinaryWriter
для работы с байтами, лучше использовать как оболочку для дрягого байтового потока

void write
--
bool readboolean()
...



#MemoryStream:stream - байтовый поток который использует память для хранения
конструкторы 
MemoryStream(byte[] buf)
можно засунуть в оболочку и использовать как обычный поток

#StringReader:textReader StringWriter:textWriter - тоже что и MemoryStream но для хранения в строке
конструкторы
StringReader(string buf)
StringWriter()//не указываем строку в которой будет хранить но можно ее получить методом ToString()



!!!!
#FileStream:stream - байтовый поток для ввода вывода
конструкторы
FileStream(string путь, FileMode режим)
FileStream(string путь, FileMode режим, FileAccess доступ) - ограничивает доступ, только для чтения и тд
new FileStream(FilePathOld, FileMode.Open, FileAccess.Read, FileShare.Read)//если нужно читать в нескольких потоках


#File
некоторые методы находятся в FileInfo, если что можно поискать там
copy(string исход,string новый)//если не существует
copy(string исход,string новый,bool overwrite)//перезапишит

exist (string путь)
GetLastAccessTime (string путь)



#io  #file #load #byte #console

Console.In-экземпляр TextReader  Console.Out -TextWriter Console.Error -TextWriter

методы
static void #SetIn(TextReader поток)
static void #SetOut(TextWriter поток)
static void #SetError(TextWriter поток)
//в TextReader можно обернуть вообще другой поток



#readKey
static consoleKeyInfo ReadKey()
static consoleKeyInfo ReadKey(bool intercept) - если true то не отобразится на консоли

#consoleKeyInfo
структура
char KeyChar  введенный символ
ConsoleKey Key значение из перечисления ConsoleKey
ConsoleModifiers Modifiers  значение из перечисления ConsoleModifiers , модификаторы которые бали нажаты ctrl и тд








//открыть файл и вернуть байты
 public static byte[] FileToByteArray(string fileName)
        {
            byte[] buff = null;
            FileStream fs = new FileStream(fileName,
                                           FileMode.Open,
                                           FileAccess.Read);
            BinaryReader br = new BinaryReader(fs);
            long numBytes = new FileInfo(fileName).Length;
            buff = br.ReadBytes((int)numBytes);
            return buff;
        }



#Console

Beep: подача звукового сигнала
Clear: очистка консоли
WriteLine: вывод строки текста, включая символ возврата каретки (то есть с переводом на новую строку)
Write: вывод строки текста, но без символа возврата каретки
ReadLine: считывание строки текста со входного потока
Read: считывание введенного символа в виде числового кода данного символа. С помощью преобразования к типу char мы можем получить введенный символ
ReadKey: считывание нажатой клавиши клавиатуры (ConsoleKeyInfo key= Console.ReadKey();)
Кроме того, класс Console обладает свойствами, которые позволяют управлять консолью. Некоторые из них:
BackgroundColor: цвет фона консоли
ForegroundColor: цвет шрифта консоли
BufferHeight: высота буфера консоли
BufferWidth: ширина буфера консоли
Title: заголовок консоли
WindowHeight и WindowWidth: высота и ширина консоли соответственно














#относительный #relative путь к файлу на сервере #HostingEnvironment
File.ReadAllText(HostingEnvironment.MapPath($"~/tsqlscripts/{i}.txt"))










#* #unsafe #указатель

тип * название;
указатель может указывать на что угодно
int * p,q ;//создание 2х указателей
&val;//получить адрес
*ref;//получить значение по указателю

unsafe- пометить блок кода как не безопасный(можно применять указатели)
unsafe static void Main(){}

#fixed
fixed(int*=&val){
//val не будет удалена сборщиком мусора КАК МИНИМУМ пока не выполнится блок кода
}

fixed тип имя_буфера[размер]
создание массива фиксированного значения, можно указать только в структуре


арифметика с указателями
++ -- + - 
int* p;
p++;//увеличит на 4 тк int-4байта

если переменные связанны(допустим указатели на разные участки массива) то их можно сравнивать(и получить результат который что то будет значить)
== < >

int[] mass;
//одно и тоже
int*p=mass;
int*q=mass[0];

p[1], p[10] //работает тк указывает на массив


указатель на указатель
int** p;//**p получить значение

массивы
int*[]mass=new int*[3];
mass[0]=;//установить значение
*mass[0];//получить значение




#sizeof
sizeof(type)//узнать размер типа данных

#stackalloc
только при объявлении локальных переменных
память выделяется из кучи
выделенная память таким обрзом не очищается сборщиком мусора
тип *p=stackalloc тип[размер]








#inthernet #HttpWebRequest #parse #uri #url
#HttpWebRequest req = (HttpWebRequest) WebRequest.Create("http://www.McGraw-Hill.com");
#HttpWebResponse resp = (HttpWebResponse) req.GetResponse();
Stream istrm = resp.GetResponseStream();
//получаем html страницы
resp.Close();
//---короче
// Сначала создать объект запроса типа WebRequest по указанному URI.
WebRequest req = WebRequest.Create("http://www.McGraw-Hill.com");
// Затем отправить сформированный запрос и получить на него ответ.
WebResponse resp = req.GetResponse();

#WebClient лучше использовать вместо Request Response если нужно просто получить инфу по ссылке и все
public byte[] DownloadData(string address) //получить результат по ссылке
public string DownloadString(string address) //результат по ссылке
public Stream OpenRead(Uri address) //поток четения
public Stream OpenWrite(Uri address) 
DownloadFile(uri, fname); //по ссылке записать все в файл, можно в ссылке указать как код на страницу так и код на файл


Uri sample = new Uri("http://HerbSchildt.com/somefile.txt?SomeQuery");
Uri-
public string Host { get; } Получает имя сервера
public string LocalPath { get; } Получает локальный путь к файлу
public string. PathAndQuery { get; }
public int Port { get; }
Получает абсолютный путь и строку запроса
Получает номер порта для указанного протокола. Так, для протокола HTTP номер порта
равен 80
public string Query { get; } Получает строку запроса
public string Scheme { get; } Получает протокол





#html #<> #скобки #><
 <p> будет выглядеть как &lt;p&gt;



#graph #graphic
http://htmlbook.ru/blog/grafiki-i-diagrammy

https://google-developers.appspot.com/chart/interactive/docs/gallery
 























#html5
#атрибуты #attr #atribute

accesskey: определяет клавишу для быстрого доступа к элементу
class: задает класс CSS, который будет применяться к элементу
contenteditable: определяет, можно ли редактировать содержимое элемента
contextmenu: определяет контекстное меню для элемента, которое отображается при нажатии на элемент правой кнопкой мыши
dir: устанавливает направление текста в элементе
draggable: определяет, можно ли перетаскивать элемент
dropzone: определяет, можно ли копировать переносимые данные при переносе на элемент
hidden: скрывает элемент
id: уникальный идентификатор элемента. На веб-странице элементы не должны иметь повторяющихся идентификаторов
lang: определяет язык элемента
spellcheck: указывает, будет ли для данного элемента использоваться проверка правописания
style: задает стиль элемента
tabindex: определяет порядок, в котором по элементам можно переключаться с помощью клавиши TAB
title: устанавливает дополнительное описание для элемента
translate: определяет, должно ли переводиться содержимое элемента

target для <a>  -- позволяет по разному открывать ссылку(фрейм окно и тд)


#tags

<b>: выделяет текст жирным
<del>: зачеркивает текст
<i>: выделяет текст курсивом
<em>: выделяет текст курсивом, в отличие от тега <i> носит логическое значение, придает выделяемому тексту оттенок важности
<s>: зачеркивает текст
<small>: делает текст чуть меньше размером, чем окружающий
<strong>: выделяет текст жирным. В отличие от тега <b> предназначен для логического выделения, чтобы показать важность текста. А <b> не носит характера логического выделения, выполняет функции только форматирования
<sub>: помещает текст под строкой
<sup>: помещает текст над строкой
<u>: подчеркивает текст
<ins>: определяет вставленный (или добавленный) текст
<mark>: выделяет текст цветом, придавая ему оттенок важности


#спойлер с названием и стрелкой #список
 <details>
            <summary>Флагманы 2015</summary>
</details>


внутренняя ссылка на странице #href #link #якорь 
<a href="#paragraph1">Параграф 1</a>
<h2 id="paragraph1">Параграф 1</h2>


#border #fieldset #legend #рамка
выделит красиво в 1 блок(линией по краям) и legend будет заголовком(НА линии и перекрывает ее)
 <fieldset>
                <legend>Введите данные:</legend>
</fieldset>


.article > p{}
только на те элементы которые в .article не включая блоки которые вложены еще в какой то блок 
<div class="article">
            <p>меняется</p>
            <div class="content">
                <p>не меняется</p>
            </div>


.article + p{}   для элемента p который следует за .ar
//возможна комбинация из нескольких +

 h2~div { color: red; }
<h2>Заголовок</h2>
        <p>Аннотация</p>
        <div>
            <p>red</p>
        </div>
        <div>
            <p>red</p>
        </div>




#градиенты #gradient
обязательно юзать -moz-  -webkit-
с левого верхнего угла в противоположный перелив из черного в белый
background-image: linear-gradient(top left,black,white);
20% 80%--- это положение точки, вроде как ширина
background-image: linear-gradient(left, #ccc, red 20%, red 80%, #ccc);
повторяющийся градиент
background-image: repeating-linear-gradient(left, #ccc 20px, red 30px, rgba(0, 0, 126, .5) 40px);

градиент для круга
белый-центр и черный края
background-image: radial-gradient(white, black);
для элипса
radial-gradient(ellipse, white, black);

задать центр   -- 25% от левой границы и 30 от верхней
background-image: radial-gradient(25% 30%, circle, white, black);

closest-side: градиент распространяется из центра только до ближайшей к центру стороне элемента. То есть градиент остается внутри элемента
closest-corner: ширина градиента вычисляется по расстоянию из его центра до ближайшего угла элемента, поэтому градиент может выйти за пределы элемента.
farthest-side: градиент распространяется из центра до самой дальней стороны элемента
farthest-corner: ширина градиента вычисляется по расстоянию из его центра до самого дальнего угла элемента
background-image: radial-gradient(25% 30%, circle farthest-corner, white, black);



#transform
ширина\высота
  transform: scale(2, 0.5);
transform: scale(0.5);
угол
  transform: rotate(30deg);
зеркальное отражение
transform: scaleX(-1);

перемещение
transform: translate(offset_X, offset_Y);
наклон(квердат станет паралелограммом)
  transform: skew(30deg, 10deg);


точка относительно которой трансформация
transform-origin: left top;
left top: левый верхний угол элемента
left bottom: левый нижний угол элемента
right top: правый верхний угол элемента
right bottom: правый нижний угол элемента



#transition
transition-delay: 500ms;
 transition-timing-function: ease-in-out;
linear: линейная функция плавности, изменение свойства происходит равномерно по времени
ease: функция плавности, при которой анимация ускоряется к середине и замедляется к концу, предоставляя более естественное изменение
ease-in: функция плавности, при которой происходит только ускорение в начале
ease-out: функция плавности, при которой происходит только ускорение в конце анимации
ease-in-out: функция плавности, при которой анимация ускоряется к середине и замедляется к концу, предоставляя более естественное изменение
cubic-bezier: для анимации применяется кубическая функция Безье




#keyframes   #frame #function
 animation-name: название_анимации;
animation-iteration-count: 3;  /*количество повторений, может быть   infinite*/
animation-fill-mode: forwards;   /*после выполнения оставить стиль на 100% */
animation-duration: 5s;
animation-direction: alternate;    /*анимация идет 0%->100%  100->0  0->100*/

@keyframes название_анимации {
    from {/*можно 0% вместо from*/
        /* начальные значения свойств CSS */
    }
    to {/*можно 100% вместо to*/
        /* конечные значения свойств CSS */
    }
}











#псевдоклассы #css
 a:not(.blueLink) { color: red; }
все а кроме . сделает красными

//выбирает элемент, который является единственным элементом определенного типа в контейнере.
span:only-of-type{
         
            color: green;   /* зеленый цвет */
        }


: #enabled {   если не установлен атрибут  disabled
: #checked  если установлен атрибут checked          // :checked + span {
 : #valid и : #invalid стилизуют элементы формы в зависимости от того, проходят они валидацию или нет
input:invalid 
            input:valid {
стилизуют элементы формы в зависимости от того, попадает ли их значение в определенный диапазон
: #in-range 
            : #out-of-range {
<input type="number" min="1" max="100" value="10" id="age" name="age"/>


: #optional                Не установлен required
            : #required {  установлен атрибут required





#nth-child позволяет стилизовать каждый второй, третий элемент, только четные или только нечетные элементы и т.д.
tr:nth-child(odd){} для нечетных элементов, 
tr:nth-child(even){} четных элементов в
tr:nth-child(3)  под номером 3
tr:nth-child(2n+1) { background-color: #bbb; } к каждой второй нечетной строке.

tr:nth-last-child(2) {    тоже самое,с конца




first-child: представляет элемент, который является первым дочерним элементом
:#last-child: представляет элемент, который является последним дочерним элементом
:#only-child: представляет элемент, который является единственным дочерним элементом в каком-нибудь контейнере
:#only-of-type: выбирает элемент, который является единственным элементом определенного типа (тега) в каком-нибудь контейнере
:#nth-child(n): представляет дочерний элемент, который имеет определенный номер n, например, второй дочерний элемент
:#nth-last-child(n): представляет дочерний элемент, который имеет определенный номер n, начиная с конца
:#nth-of-type(n): выбирает дочерний элемент определенного типа, который имеет определенный номер
:#nth-last-of-type(n): выбирает дочерний элемент определенного типа, который имеет определенный номер, начиная с конца



::#first-letter: позволяет выбрать первую букву из текста
::#first-line: стилизует первую строку текста
::#before: добавляет сообщение до определенного элемента
::#after: добавляет сообщение после определенного элемента
::#selection: выбирает выбранные пользователем элементы     работает например для выделенного текста


input[type="text"]{
.link[href="http://apple.com"]{
a[href^="https://"]{        начинается с подстроки
img[src$=".jpg"]{           заканчивается
a[href*="microsoft"]{           есть вхождения


В этом случае вне зависимости от наличия других селекторов с большим количеством баллов к ссылкам будет применяться красный цвет, определяемый первым стилем.
a {font-size: 18px; color: red !important;}




#hover #visible #visibility #display
если bl2 находится в bl1
div.bl1:hover div.bl2{
    top:0;
}

для соседних
.block1:hover + .block2 h1 { color: red;}


для как бы не соседних
<div class="one">Name</div>
<div class="two">Surname</div>
<div class="three">Opps</div>
.three {
    color: orange;
}

.one:hover + .two + .three {
    color: green;
}


для не соседних но при условии что они в 1 блоке
 .block1:hover ~ .block2 h1 { color: red;}
<div>
  <div class=block2><h1>нет</h1></div>
  <div class=block1>Проведите надо мной</div>
  <div class=block2><h1>да</h1></div>
</div>




#inline #inline-block #display #div_inline_block #divinlineblock
display: inline-block; 50% каждый див что бы уместились в строку —-»»> просто между блоками удалить все пробелы и переносы строк. т.е. закончился предыдущий div, и сразу же после закрывающего тега нужно вставлять следующий открывающий.
div.div_inline_block {
    display: inline-block;
    vertical-align: top;
}






#Спецсимволы #html #img #image
#стандарт #css #символ #картинка
https://html5book.ru/specsimvoly-html/
css content:'\2718';

#github
content: "\f09b";
content: "\f003"; // почтовый конвернт
content: "\f16c";// #stack #overflow
content: "\f019";//значек загрузки




#shadow
box-shadow: 0 0 10px rgba(0,0,0,0.5);


#кэш #кэширование
[OutputCache(Duration=30, Location= OutputCacheLocation.Downstream)]
        public string Index()
        {
CacheProfle: определяет конфигурацию кэширования
Duration: продолжительность кэширования контента в секундах. Важно оптимально подобрать временной отрезок, так как если задать большое значение, то пользователи будут работать практически со статичными данными, а при очень маленьком значении будет слишком часто обновление кэша, что нивелирует преимущества его использования
Location: место, где размещается кэшированный контент
NoStore: если данное значение равно true, в ответе в заголовке Cache-Control устанавливается флаг no-store, что указывает браузеру, что контент не надо сохранять
SqlDependency: определяет зависимость между кэшем и таблицой в бд
VaryByCustom: указывает произвольное значение, по которому будут определяться различные версии кэшированных данных
VaryByHeader="user-agent": указывает на набор заголовков, по которым будут определяться различные версии кэшированных данных
VaryByParam="title;id": указывает на параметры строки запроса или параметры переданных форм, по которым будут определяться различные версии кэшированных данных

Any: контент кэшируется как на клиенте, так и на прокси-сервере и в выходном кэше сервера
Client: контент кэшируется на клиенте
Downstream: контент кэшируется как на клиенте, так и на прокси-сервере. Выходной кэш сервера не используется
None: для заголовка Cache-Control устанавливается значение no-cache, что значит, что контент не будет нигде кэшироваться
Server: контент кэшируется только в выходном кэше сервера
ServerAndClient: контент кэшируется на клиенте и в выходном кэше сервера




mvc 
плагин для добавление автоматической пагинации(переключение страниц, нумерация страниц, Постраничный вывод)
#пагинация
https://metanit.com/sharp/mvc5/17.7.php



js-html
JqGrid пакет для добавления таблицы со стриницами поиском  редактированием тд
https://metanit.com/sharp/mvc5/17.3.php








Диалоговые окна и CRUD-интерфейс
реазилация partial action для окна(редактирование элемента например)
https://metanit.com/sharp/mvc5/17.2.php


jQuery UI и Autocomplete
для подгрузки блжайших совпадений при поиске
https://metanit.com/sharp/mvc5/17.1.php









обратная связь с клиентом  #SignalR #hubs

NuGet библиотеку Microsoft ASP.NET SignalR
если в проекте нет класса Startup(там где web.config, не в папках) 
то добавить его если есть то дописать(или дописать в конец файла Startup.Auth.cs 
в метод ConfigureAuth класса Startup тк он вызывается если указана строка  ConfigureAuth(app); 
в файле Startup)  app.MapSignalR();

using Microsoft.Owin;
using Owin;
[assembly: OwinStartup(typeof(SignalRMvc.Startup))]
namespace SignalRMvc
{
    public class Startup
    {
        public void Configuration(IAppBuilder app)
        {
            app.MapSignalR();
        }
    }
} 

класс для хранения пользователей
public class User
{
    public string ConnectionId { get; set; }
    public string UserId { get; set; }
}
Теперь добавим в проект новую папку. Назовем ее Hubs. В ней будут находиться хабы нашего приложения. В эту папку добавим новый item(SignalR Hub Class (v2)) ChatHub.cs
//[HubName("stockTickerMini")]  можно изменить имя хаба
 public class ChatHub : Hub
    {
        static List<UserForHub> Users = new List<UserForHub>();
//объявляем методы к которым будем обращаться 
public void Send(int id)
        {
 Clients.Group(groupName).MethodOnClient(id_dialog);//id_dialog- может быть объектом класса, в таком случае конвертится в json и отправляется, на стороне клиента в функцию зайдет сразу объектом а не json строкой
}
 public void JoinToHub()
        {
//добавляем группу если ее нет и добавляем в нее юзера
 Groups.Add(Context.ConnectionId, groupName);
//удаляем
Groups.Remove(Context.ConnectionId, roomName);
}

// Отключение пользователя
        public override System.Threading.Tasks.Task OnDisconnected(bool stopCalled)
        {
            var item = Users.FirstOrDefault(x => x.ConnectionId == Context.ConnectionId);
            if (item != null)
            {
                Users.Remove(item);
                var id = Context.ConnectionId;
                //Clients.All.onUserDisconnected(id);
            }

            return base.OnDisconnected(stopCalled);
        }
}

HTML(в конце боди лучше)
<script src="~/Scripts/jquery-1.10.2.min.js"></script>
    <!--Ссылка на библиотеку SignalR -->
    <script src="~/Scripts/jquery.signalR-2.2.0.min.js"></script>
    <!--Ссылка на автоматически сгенерированный скрипт хаба SignalR -->
    <script src="~/signalr/hubs"></script>
    <script src="~/Scripts/util.js"></script>


JS
//методы на стороне сервера нужно вызывать с маленькой буквы
создаем файл util.js

$(function () {
    // Ссылка на автоматически-сгенерированный прокси хаба
    var chat = $.connection.chatHub;

// Объявление функции
    chat.client.MethodOnClient = function (id_dialog) {
}

// Открываем соединение
    $.connection.hub.start().done(function () {
//так вызывается любой метод на сервере
        chat.server.joinToHub();
}
});





полезное:
//id пользователя в Hube
Context.ConnectionId
// Посылаем сообщение текущему пользователю
                Clients.Caller.onConnected(id, userName, Users);
// Посылаем сообщение всем пользователям, кроме текущего
                Clients.AllExcept(id).onNewUserConnected(id, userName);
//всем
Clients.All.addMessage(name, message);



Вызов метода на всех клиентах: Clients.All.addMessage(name, message);
Вызов метода только на текущем клиенте, который обратился к серверу: Clients.Caller.addMessage(name, message);
Вызов метода на всех клиентах, кроме того, который обратился к серверу: Clients.Others.addMessage(name, message);
Вызов метода только у клиента с определенным id: Clients.Client(Context.ConnectionId).addMessage(name, message);
Вызов метода на всех клиентах, кроме клиента с определенным id: Clients.AllExcept(connectionId).addMessage(name, message);
Вызов метода на всех клиентах указанной группы: Clients.Group(groupName).addMessage(name, message);
Вызов метода на всех клиентах указанной группы, за исключением клиента, у которого id - connectionId: Clients.Group(groupName, connectionId).addMessage(name, message);
Вызов метода на всех клиентах указанной группы, за исключением обратившегося к серверу клиента: Clients.OthersInGroup(groupName).addMessage(name, message);


включение логов хабов на стороне клиента
$.connection.hub.logging = true;





для того что бы можно было использовать обычный класс как hub class нужно в него передать(ресурсоемкий процесс)
IHubConnectionContext<dynamic> clients
получить - GlobalHost.ConnectionManager.GetHubContext<StockTickerHub>().Clients














https://metanit.com/sharp/mvc5/16.2.php


#бандлы #bundle/head подлючение скриптов
@Styles.Render("~/Content/css")
    @Scripts.Render("~/bundles/modernizr")
более удобное подключение группы скриптов, объединяет несколько скриптов в 1 файл и ускоряет работу и js.js.min делает
в файле BundleConfig.cs
bundles.Add(new ScriptBundle("~/bundles/jquery").Include(
                        "~/Scripts/jquery-{version}.js"));
параметр {version} является заменителем для любого символьного обозначения версии скрипта
"~/Scripts/jquery.validate*" с помощью знака звездочки заменяет остальную часть строки.
Однако само объявление бандлов в файле BundleConfig.cs еще не подключает автоматически их в проект. Для этого в файле Global.asax прописывается соответствующая директива:
protected void Application_Start()
    {
        //..............................................
        BundleConfig.RegisterBundles(BundleTable.Bundles);
    }


бандлы CDN
загрузка скриптов с сайтов
лучше всего проверять загрузился ли скрипт
public static void RegisterBundles(BundleCollection bundles)
        {
            bundles.UseCdn = true;   //включаем поддержку CDN
            // добавляем адрес нужной библиотеки в какой-нибудь сети CDN
            var jqueryCdnPath = "http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.7.1.min.js";
            bundles.Add(new ScriptBundle("~/bundles/jquery",
                        jqueryCdnPath).Include(
                        "~/Scripts/jquery-{version}.js"));




Минификация
при развертывании приложения ускоряет работу за счет бандлов, делает js.js.min и объединяет файлы
для включения надо отключить #режим #отладки
 В файле web.config меняем на false
<configuration>
  <!--------------------------------------->
  <system.web>
    <authentication mode="None" />
    <compilation debug="true" targetFramework="4.5" />
    <httpRuntime targetFramework="4.5" />






для формирования из строки с русскими буквами строку без них(кодирование) (например для запроса на сервер через ссылку)
#encodeURIComponent
(декодирование)
#decodeURIComponent

ActionName

хэш пароля
https://ru.stackoverflow.com/questions/545944/%D0%9A%D0%B0%D0%BA-%D0%B7%D0%B0%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BF%D0%B0%D1%80%D0%BE%D0%BB%D0%B8

фильтры атрибуты для методов #attr
RequireHttps-заставляет использовать https
[OutputCache (Duration=360)]-кэширует данные 360 секунд для увеличение работы с бд
ValidateAntiforgeryToken- применять к методам авторизации регистрации


отправка #статуса #кода #StatusCode 
#404 #200 #500
  return new #HttpStatusCodeResult(404);

Response.StatusCode = (int)HttpStatusCode.BadRequest; 
Response.StatusCode = 404;
return new EmptyResult();
return Content(ex.Message);

return HttpNotFound();
 return new HttpUnauthorizedResult();//#401 - нет доступа


[AllowAnonymous]/ [Authorize]
#controller
string controller_name = ViewContext.RequestContext.RouteData.Values["controller"].ToString(); ;





Когда следует использовать AsNoTracking? Если нам надо просто вывести данные для отображения без необходимости их дальнейшего обновления, тогда как раз тот случай, когда мы можем использовать AsNoTracking.
не сохранит изменения и ускорит работу, не получится дозагрузить какие либо данные из бд (load,reference и тд)
Phone firstPhone = db.Phones.AsNoTracking().FirstOrDefault();
firstPhone.Name = "Samsung Galaxy Ace 2";
db.SaveChanges();
возможно стоит присоеденять запись и тогда можно будет ее обновить db.Set<ApplicationUser>().Attach(this);













#AJAX


#AJAX #js #jquery #img #image #post #httppost #uploadImage

html

обычная форма

<form id="commentForm" class="form" method="post"  enctype="multipart/form-data">
    <fieldset>
        <input type="text" id="text" placeholder="text"  name="text">
        <input id="id_user" type="text" placeholder="id_user:"  name="id_user">
        
        <input id="uploadImage" type="file"  name="uploadImage">
        
    </fieldset>
    <input id="button" class="submit" type="submit" value="Отправить" name="submit">
</form>



js



jQuery(document).ready(function () {
        $("#commentForm").submit(function () { return false; });

        $("#button").on("click", function () {

                $(".submit").replaceWith("<div class='form_dscr'><p class='sending'>Отправка...</p></div>");
            //получаем форму
                var form = document.forms.commentForm;

                var formData = new FormData(form);

                var xhr = new XMLHttpRequest();
                xhr.open("POST", "/SocialNetwork/AddMemePerson");

                xhr.onreadystatechange = function () {
                    if (xhr.readyState == 4) {
                        if (xhr.status == 200) {
                            //при возврате actionresult и тд, вернет -"<html>"
                            var data = xhr.responseText;
                            
                        }
                    }
                };

                xhr.send(formData);

        });
    });


тоже самое но вообще без html и jquery
(это не тестил)

function getXmlHttp() {
    var xmlhttp;
    try {
      xmlhttp = new ActiveXObject("Msxml2.XMLHTTP");
    } catch (e) {
    try {
      xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
    } catch (E) {
      xmlhttp = false;
    }
    }
    if (!xmlhttp && typeof XMLHttpRequest!='undefined') {
      xmlhttp = new XMLHttpRequest();
    }
    return xmlhttp;
  }
  function summa() {
    var a = document.getElementById("a").value; // Считываем значение a
    var b = document.getElementById("b").value; // Считываем значение b
    var xmlhttp = getXmlHttp(); // Создаём объект XMLHTTP
    xmlhttp.open('POST', 'test.php', true); // Открываем асинхронное соединение
    xmlhttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); // Отправляем кодировку
    xmlhttp.send("a=" + encodeURIComponent(a) + "&b=" + encodeURIComponent(b)); // Отправляем POST-запрос
    xmlhttp.onreadystatechange = function() { // Ждём ответа от сервера
      if (xmlhttp.readyState == 4) { // Ответ пришёл
        if(xmlhttp.status == 200) { // Сервер вернул код 200 (что хорошо)
          document.getElementById("summa").innerHTML = xmlhttp.responseText; // Выводим ответ сервера
        }
      }
    };
  }






#get #js
без jquery и ajax

var x = new XMLHttpRequest();
x.open("GET", "/echo/json/", true);
x.onload = function (){
    alert( x.responseText);
}
x.send(null);












можно проверить является ли запрос ajax
!Request.IsAjaxRequest()

#ajax #post #jquery #form #get
оба возвращают сам объект(не надо определять из json)
$.post( "/Info/Add_section", { name: "John", time: "2pm" })
  .done(function( data ) {
    alert( "Data Loaded: " + data );
  });

var dt={'Head':'sdf','parrent_sec_id':'sss'};
            $.ajax({
                url: "/Info/Add_section",
                data:dt,
                
                success: OnComplete_Add_section,//функция
                error: function () { alert("ошибка загрузки"); },
                // shows the loader element before sending.
                beforeSend: function () { alert("before"); },
                // hides the loader after completion of request, whether successfull or failor.             
                complete: function () { alert("after"); },
                type: 'POST', dataType: 'json'//'html'
            });

#TODO взять из диплома go_ajax функцию




//проверенный post



объявление объекта для отправки
var dt = {
        'id': id
    };
//можно так
 var dt = {
            'forms[0].ActionId': 10,
            'forms[1].ActionId':20,
'forms1.ActionId'
        };




    $.ajax({
        url: "/SocialNetwork/SendComment",
        data: dt,
        success: function (data) {
            ShowCommentsRecord(id, false)
        },
        error: function () {
            alert("ошибка загрузки");
            PreloaderAction(false);

        },
        beforeSend: function () { PreloaderAction(true); },
        complete: function () {
            PreloaderAction(false);

        },
        type: 'POST', dataType: 'json'//html
    });






из js отправить #get запрос
$('#results').load('@Url.Action("BookSearch", "Home")?name='+name)



$.ajax({
  url: url,
  data: data,
  success: onAjaxSuccess,
  dataType: dataType
});
function onAjaxSuccess(data)
{
  // Здесь мы получаем данные, отправленные сервером и выводим их на экран.
  alert(data);
}









@using (Ajax.BeginForm("BookSearch", new AjaxOptions
{
    UpdateTargetId = "results",
    OnBegin = "OnBegin",
    OnFailure = "OnFailure",
    OnSuccess = "OnSuccess",
    OnComplete = "OnComplete"
}))
{
    <input type="submit" value="Поиск" />
}



Confirm="Выполнить AJAX-запрос?" - настраивает сообщение о подтверждении отправки запроса на сервер. Если пользователь не подтвердит, то запрос не будет отправлен

HttpMethod - устанавливает метод (Get или Post), с помощью которого выполняется запрос

InsertionMode - устанавливает, как полученные результаты будут отображаться на странице. Может принимать одно из трех значений перечисления InsertionMode: InsertAfter, InsertBefore и Replace(по умолчанию).

LoadingElementId="loading"- устанавливает id элемента html-страницы, который будет отображаться во время запроса. Обычно это какая-нибудь анимация, которая дает знать, что некоторая работа выполняется в фоновом режиме

LoadingElementDuration=1000 - устанавливает количество миллисекунд, через которое появится элемент, указанный в параметре LoadingElementId

OnBegin - задает обратный вызов перед отправкой запроса. Соотносится с событием beforeSend библиотеки jQuery 
function OnBegin() {



OnComplete - задает обратный вызов, который вызывается после выполнения запроса (как удачного, так и неудачного). Соотносится с событием complete библиотеки jQuery
function OnComplete(request, status) {


OnFailure - задает обратный вызов, который вызывается после неудачного выполнения запроса. Соотносится с событием error библиотеки jQuery
 function OnFailure(request, error) {


OnSuccess - задает обратный вызов, который вызывается после удачного выполнения запроса. Соотносится с событием success библиотеки jQuery
function OnSuccess(data) {



UpdateTargetId - указывает на id элемента, в котором будут выводиться результаты запроса

Url - устанавливает адрес Url сервера, на который отправляется запрос. Установив данное свойство, можно не использовать название имя контроллера и его действие в качестве параметров Ajax.BeginForm














#TODO
фильтры и не только это не обрабатывал и многое не понял  https://metanit.com/sharp/mvc5/8.1.php          -https://metanit.com/sharp/mvc5/8.9.php



возможно получение параметров в методе https://metanit.com/sharp/mvc5/9.5.php


поставщик значений
	https://metanit.com/sharp/mvc5/9.4.php



!!!!!!!!!!!! https://metanit.com/sharp/mvc5/7.1.php    указывать тип для редактирования





#attr #atribute #атрибуты

название  с суффиксом Attribute

[AttributeUsage(AttributeTargets.All)]//то к чему может применяться
public class NameAttribute: Attribute{



public NameAttribute(){}
}
//если в классе есть нестатическое поле или свойство доступное для записи то его можно использовать как именованный параметр не указывая в конструкторе
[NameAttribute(позиционные параметры,именованные параметры)]
public class test{}

//получить атрибуты
((Type)obj).GetCustomAttributes
Attribute.GetCustomAttribute(MemberInfo a,Type b);//a-объект, b-тип атрибута



#Conditional
class n{
[Conditional("trial")]
void nnn(){}
}
nObj.nnn();//вызовется только если #define trial


#Obsolete
пометить элемент программы как устаревший
[Obsolete("сообщение",bool a)]//если a-true то сообщение об ошибке если нет то предупреждение
class n{}




















#атрибуты для #отображение #редактирование #attr #atribute

[...]
 public int Id { get; set; }

[HiddenInput (DisplayValue=false)] --- создаст hidden

 [Display(Name = "Название")]   корректно отображается через editorformodel() и LabelFor(=>)
[ScaffoldColumn(false)] --полностью скроет, не будет создано ничего
//editorfor
[DataType(DataType.Password)] --редактирем отображение

DataType.{
Currency --Отображает текст в виде валюты

DateTime--Отображает дату и время
Date--Отображает только дату, без времени
Time--Отображает только время
Text--Отображает однострочный текст
MultilineText--Отображает многострочный текст (элемент textarea)
Password--Отображает символы с использованием маски
Url--Отображает строку URL
EmailAddress-Отображает электронный адрес
}

#json атрибуты #JsonProperty
 [JsonProperty("startX")] -- меняет имя для формата json


 [UIHint("Url")]
 [UIHint("")]{
Boolean--Хелперы редактирования создают флажок (checkbox) для булевых значений. Для значений типа bool? (nullable) создается элемент select с параметрами True, False и Not Set
Хелперы отображения генерируют те же элементы html, что и хелперы редактирования, только с атрибутом disabled

Collection--Используется соответствующий шаблон для рендеринга каждого элемента коллекции. Причем элементы могут быть разных типов.

Decimal--Хелперы редактирования создают однострочное текстовое поле - элемент input

EmailAddress--Хелперы редактирования создают однострочное текстовое поле.
Хелперы отображения генерируют элемент ссылка, где атрибут href имеет значение mailto:url

HiddenInput--Создается скрытое поле - элемент hidden input

Html--Хелперы редактирования создают однострочное текстовое поле.
Хелперы отображения просто показывают текст

MultilineText--Хелперы редактирования создают многострочное текстовое поле (элемент textarea)

Object--Хелперы изучают свойства объекта и выбирают наиболее подходящие для него шаблоны.

Password--Хелперы редактирования создают текстовое поле для ввода символов с использованием маски
Хелперы отображения показывают пароль как есть, без использования маски

String--Хелперы редактирования создают однострочное текстовое поле

Url--Хелперы редактирования создают текстовое поле
Хелперы отображения создают элемент ссылки для данного Url

}

@Html.EditorForModel()
<input type="hidden" id="Id" name="Id" value="1" />



https://metanit.com/sharp/mvc5/7.1.php

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


#куки #сессия #сессии #session #Cookies
получить
string id =HttpContext.Request.Cookies["id"].Value;
установить
HttpContext.Response.Cookies["id"].Value = "ca-4353w";

удалить(устанавливаем вчерашнюю дату)
Response.Cookies[«MyCookieName»].Expires = DateTime.Now.AddDays(-1);

проверяем поддержки 
if (Request.Browser.Cookies)
{// поддерживает}
else
{// не поддерживает}
проверка отключения
Если пользователь отключил использование кукисов в броузере, то выше указанный метод Request.Browser.Cookies при проверки всё равно вернет true, но кукисы не будут сохранены на компютере клиета. Один из способов проверки в данном случаи является попытка сохранить кукис на первой странице, а затем используя Response.Redirect перенаправить на другую страницу и прочитать записанный кукис.


сессия
https://professorweb.ru/my/ASP_NET/base/level5/5_4.php
сессия держится 20 минут
Session["name"] = "Tom";
var val = Session["name"];
удалить
Session["name"]=null;
полностью закрываем сессию
Session.Abandon()


HttpSessionState методы
Count	Количество элементов в коллекции текущего сеанса
IsCookieless	Указывает, как отслеживается этот сеанс: с помощью cookie-набора или с использованием измененных URL-адресов
IsNewSession	Указывает, был ли данный сеанс только что создан для текущего запроса. Если в состоянии сеанса на текущий момент не содержится никакой информации, ASP.NET не будет беспокоиться ни об отслеживании сеанса, ни о создании cookie-набора сеанса. Вместо этого сеанс будет воссоздаваться заново при каждом запросе
Mode	Предоставляет перечислимое значение, которое объясняет, как ASP.NET хранит информацию о состоянии сеанса. Этот режим хранения определяется на основе указанных в файле web.config конфигурационных настроек
SessionID	Предоставляет строку с уникальным идентификатором сеанса для текущего клиента
StaticObjects	Предоставляет коллекцию элементов сеанса, предназначенных только для чтения, которые были объявлены в global.asax с помощью дескрипторов <object runat="server">. В основном эта технология не используется и является пережитком ASP-программирования; она поддерживается для обратной совместимости
Timeout	Текущее количество минут, которое должно пройти, прежде чем текущий сеанс будет завершен при условии отсутствия запросов от клиента. Это значение может изменяться программно, что дает возможность при необходимости продлевать срок жизни коллекции сеанса для более важных операций
Abandon()	Немедленно завершает текущий сеанс и освобождает все занятые им ресурсы памяти. Такая технология полезна на автономных страницах, поскольку позволяет освобождать ресурсы памяти сервера настолько быстро, насколько возможно
Clear()	Удаляет все элементы сеанса, но не изменяет идентификатор текущего сеанса





#area https://metanit.com/sharp/mvc5/6.5.php

classnameViewModel  для передачи в представление
переопределение шаблона отображения и редактирования EditorForModel @for @editor @display  https://metanit.com/sharp/mvc5/5.15.php
создание нового шаблона https://metanit.com/sharp/mvc5/5.14.php









#создание #html блоков c#

Свойство InnerHtml позволяет установить или получить содержимое тега в виде строки

Метод MergeAttribute (string, string, bool) позволяет добавить к элементу один атрибут. Для получения всех атрибутов можно использовать коллекцию Attributes

Метод SetInnerText(string) устанавливает текстовое содержимое внутри элемента

Метод AddCssClass(string) добавляет класс css к элементу

TagBuilder ul = new TagBuilder("ul");
TagBuilder li = new TagBuilder("li");
                li.SetInnerText(item);
                ul.InnerHtml += li.ToString();

return new MvcHtmlString(ul.ToString());





хелперы #helpers #healpers #razor
	стандартные 
@using (Html.BeginForm("Action", "Home",
    new { id = "MyIdValue" },
    FormMethod.Post,
    new { @class = "userCssClass", data_formType="user" })){
<input type="submit" value="Отправить" />
}

<form id="MyIdValue" class="userCssClass" method="post" action="/Home/Action" data-formType="user" method="post">
    
</form>




@Html.TextArea("text", "привет <br /> мир", 5, 50, null) <textarea cols="50" id="text" name="text" rows="5">привет <br /> мир</textarea>

@Html.TextBox(string name, string value, object htmlAttributes)

@Html.Hidden("BookId", "2") <input id="BookId" name="BookId" type="hidden" value="2" />

@Html.Password("UserPassword", "val") <input id="UserPassword" name="UserPassword" type="password" value="val" />

@Html.RadioButton 
Для создания группы переключателей, надо присвоить всем им одно и то же свойство name
@Html.RadioButton("color", "red") <input id="color" name="color" type="radio" value="red" />

@Html.CheckBox("Enable", false)
<input id="Enable" name="Enable" type="checkbox" value="true" />
<input name="Enable" type="hidden" value="false" />

@Html.Label("Name")<label for="Name">Name</label>

@Html.DropDownList("countires", new SelectList(new string[] {"Russia","USA", "Canada","France"}),"Countries")
SelectListItem имеет свойства Text (отображаемый текст), Value (само значение, которое может не совпадать с текстом) и Selected

<select id="countires" name="countires"><option value="">Countries</option>
<option>Russia</option></select>

@Html.ListBox("countires", new MultiSelectList(new string[] {"Россия","США", "Китай","Индия"}))
<select Length="9" id="countries" multiple="multiple" name="countires">
<option>Россия</option></select>

Display/DisplayFor Создает элемент разметки для отображения значения указанного свойства модели: Html.Display("Name")

Editor/EditorFor Создает элемент разметки для редактирования указанного свойства модели: Html.Editor("Name")

DisplayText/DisplayTextFor Создает выражение для указанного свойства модели в виде простой строки: Html.DisplayText("Name")

DisplayForModel/EditorForModel Создает поля для чтения для всех свойств модели: Html.DisplayForModel()


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!






entity
#entityFraemwork   #db   #bd #ef  #connectionstring
using System.Data.Entity;
........................
Web.config в секцию  <configSections> после  <section name="entityFramework" 
<connectionStrings>
    <add name="DefaultConnection" connectionString="Data Source=(LocalDb)\MSSQLLocalDB;AttachDbFilename=|DataDirectory|\aspnet-server_info_web_desk-20180518052414.mdf;Integrated Security=True" providerName="System.Data.SqlClient" />
  </connectionStrings>

в строке подключения не должно быть вхождения строки Initial Catalog=aspnet-dip-20181007084703;
(LocalDb)\MSSQLLocalDB можно узнать доступные значения (поиск-> sql , расположение sql server -> настройка )


#DbSet #context #DbContext

class SoccerContext : DbContext
{
    //public SoccerContext() : base("SoccerDB2")
public ApplicationDbContext(): base("DefaultConnection", throwIfV1Schema: false)
    { }
    public DbSet<Team> Teams { get; set; }
}



правильное удаление редактирование   #Attach
при создании нескольких контекстов на 1 бд ссылающихся и для изменения данных надо прописать
using(){}
using(){
//db.Set<класс_объекта>().Attach(объект);  //ТАК(лучше)
p1.Price = 60000;
        //db.Entry(p1).State = EntityState.Modified;//редактирование //ИЛИ ТАК
}
для дозагрузки данных в другом контексте reference collection
#присоединение к #контексту   #Attach
db.Set<класс_объекта>().Attach(объект);


db.Entry(p1).State = EntityState.Deleted;//удаление
 db.Phones.Attach(p1);//
        db.SaveChanges();
https://metanit.com/sharp/entityframework/1.3.php


Способы загрузки и получения связанных данных #load #include #loading #ef #virtual #загрузка 
//для того что бы можно было закинуть лямбду а не строку надо -- using System.Data.Entity;
Eager Loading  жадная загрузка
 var players = db.Players.Include(p=>p.Team).ToList();

Explicit Loading  Явная загрузка 
#Entry
if(!db.Entry(db.Players.FirstOrDefault()).Reference("Team").IsLoad)
db.Entry(db.Players.FirstOrDefault()).Reference("Team").Load();
для загрузки коллекций юзать Collection вместо Reference

можно добавлять условия, но нужно менять load на tolist (тк при load не загрузит(не точно)) #TODO
#Query
var mass=db.Entry(this).Collection(x1 => x1.ImagesLikes).Query().Where(...).Take(...).Select(...).....ToList();






#Lazy Loading
все делается само но в объявлении модели virtual
public int? TeamId { get; set; }
    public virtual Team Team { get; set; }



настройка связей с #Fluent #API
#one #to #many #многие #многим #один
TODO


связь 1 к 1
https://stackoverflow.com/questions/26389707/ef-code-first-one-to-one-relationship-multiplicity-is-not-valid-in-role-in-re

//то что ниже хз мб не для EF
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=relationsdb;Trusted_Connection=True;");
    }
     
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder
            .Entity<User>()
            .HasOne(u => u.Profile)
            .WithOne(p => p.User)
            .HasForeignKey<UserProfile>(p => p.UserKey);
    }

//должно работать

public class Student
{
    public int StudentId { get; set; }

    public StudentAddress Address { get; set; }
}
     
public class StudentAddress 
{
    [Key]
    [ForeignKey("Student")]
    public int StudentAddressId { get; set; }

    public Student Student { get; set; }
}







#1 ко многим 

https://metanit.com/sharp/entityframework/3.3.php
если не указать внешний ключ как ?(nullable) то создается cascade(удалении записей связанных)


 Player pl1 = new Player {Name = "Роналду", Age = 31, Position = "Нападающий", Team=t2 };
public class Player
{
    public int Id { get; set; }
// название поле с объектом "Team"+ название поле ключа объекта "Team.Id"
    public int? TeamId { get; set; }
    public Team Team { get; set; }
}
public class Team
{
    public int Id { get; set; }
    public ICollection<Player> Players { get; set; }
    public Team()
    {
        Players = new List<Player>();
    }
}

строка для обNULLения ссылки на team при удалении team на который ссылается
db.Database.ExecuteSqlCommand("ALTER TABLE dbo.Players ADD CONSTRAINT Players_Teams FOREIGN KEY (TeamId) REFERENCES dbo.Teams (Id) ON DELETE SET NULL");







многие ко многим


public class Team
{
    public int Id { get; set; }
    public ICollection<Player> Players { get; set; }
    public Team()
    {
        Players = new List<Player>();
    }
}
public class Player
{
    public int Id { get; set; }
    public ICollection<Team> Teams { get; set; }
    public Player()
    {
        Teams = new List<Team>();
    }
}

...{
 public DbSet<Player> Players { get; set; }
        public DbSet<Team> Teams { get; set; }

//необязательно, но желательно, обязательно только если между сущностями несколько связей многие ко многим
 protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Player>().HasMany(c => c.Teams)//1 класс и свойство который связываем
                .WithMany(s => s.Players)//2 класс и свойство с которым связываем
                .Map(t => t.MapLeftKey("PlayerId")//id 1 которое в таблице будет
                .MapRightKey("TeamId")//id 2
                .ToTable("PlayerTeam"));//название таблицы
            base.OnModelCreating(modelBuilder);//инициализация что бы роли и все остальное добавилось нормально


//многие ко многим без лишнего
modelBuilder.Entity<Phone>()
    .HasMany(p => p.Companies)
    .WithMany(c => c.Phones);


//один-к нулю или к одному
//Phone -имеет,  Company- может не иметь
modelBuilder.Entity<Phone>()
        .HasRequired(c => c.Company)
        .WithOptional(c => c.BestSeller);

//один к одному
modelBuilder.Entity<Phone>()
    .HasRequired(c => c.Company)
    .WithRequiredPrincipal(c => c.BestSeller);//устанавливает Phone в качестве основной


//один ко многим
modelBuilder.Entity<Company>()
    .HasMany(p => p.Phones)
    .WithRequired(p=>p.Company);



modelBuilder.Entity<Company>()
    .HasMany(p => p.Phones)
    .WithRequired(p=>p.Company)
    .HasForeignKey(s=>s.Manufacturer)//явно указываем внешний ключ для связи с Company
.WillCascadeOnDelete(false);//отключаем каскадное удаление

//отключение каскадного удаления при отдельных видах отношений
modelBuilder.Conventions.Remove<OneToManyCascadeDeleteConvention>();
modelBuilder.Conventions.Remove<ManyToManyCascadeDeleteConvention>();

#HasRequired()//обязательно должно быть указано
#WithOptional()//не обязательная связь
#WithRequiredPrincipal()//обязательная связь,устанавливает одну из сущностей в качестве основной
#HasMany()//множественную связь
#WithMany()//обратная множественная связь
#HasForeignKey() //явно указываем внешний ключ для связи 
#WillCascadeOnDelete(false) //отключаем каскадное удаление
        }








закрытие protected override void #Dispose(bool disposing)
{
    db.Dispose();
    base.Dispose(disposing);
}








#атрибуты #atribute #attribute #attr #[] #ef #entityframework
#Аннотации
System.ComponentModel.DataAnnotations
установить ключ в качестве идентификатора
[Key,DatabaseGenerated(DatabaseGeneratedOption.Identity)] //[Key]
public int Ident { get; set; }
 [Required]-NOT NULL в БД
[MaxLength(20)]/MinLength устанавливают максимальное и минимальное количество символов в строке-свойстве

System.ComponentModel.DataAnnotations.Schema
 [NotMapped]--не сопостовляется/добавляется колонка в дб

[Table("Mobiles")]//указываем название таблиц
public class Phone
{
    public int Id { get; set; }
    [Column("ModelName")]//указываем  название колонки
    public string Name { get; set; }
}

[ForeignKey("CompId")]--внешний ключ

 [Index]--установка индекса

[ConcurrencyCheck]--решает проблему параллелизма(если свойство было изменено пока менялось текущем пользователем то выбрасывает исключение DbUpdateConcurrencyException)

комплексные типы / если в моделе есть другая модель
[ComplexType]
public class PhoneInfo
{
    public string Company { get; set; }
    public int Price { get; set; }
}
public class Phone
{
    public int Id { get; set; }
    public string Name { get; set; }
 
    public PhoneInfo Info { get; set; }
 
    public Phone()
    {
        Info = new PhoneInfo { Price = 300 };
    }
}
db.Phones.Add(new Phone 
    { 
        Name = "Samsung Galaxy S5", 
        Info = new PhoneInfo { Company = "Samsung", Price = 17000 } 
    });
 foreach (Phone p in db.Phones)
        Console.WriteLine("{0} - {1}", p.Name, p.Info.Price);
https://metanit.com/sharp/entityframework/6.4.php


Две модели в одной таблице
[Table("Mobiles")]
public class PhoneInfo
{
    [Key, ForeignKey("Phone")]
    public int PhoneId { get; set; }
    public Phone Phone { get; set; }
}
[Table("Mobiles")]
public class Phone
{
    [Key, ForeignKey("Info")]
    public int PhoneId { get; set; }
    public PhoneInfo Info { get; set; }
}
PhoneInfo pi1 = new PhoneInfo { PhoneId=1, Company = "Samsung", Price = 14000};
Phone p1 = new Phone { PhoneId = 1, Name = "Samsung Galaxy S5", Info = pi1 };
db.Infos.Add(pi1);

https://metanit.com/sharp/entityframework/6.5.php

Разделение сущности на несколько таблиц
public DbSet<Phone> Phones { get; set; }
 
    protected override void OnModelCreating(DbModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Phone>().Map(m =>
        {
            m.Properties(d => new { d.Name, d.Id });
            m.ToTable("Mobiles");
        }).Map(m =>
        {
            m.Properties(d => new { d.Company, d.Price });
            m.ToTable("MobilesInfo");
        });
        base.OnModelCreating(modelBuilder);
    }
https://metanit.com/sharp/entityframework/6.6.php


конвенции(установить атрибут сразу на определенные свойства всех классов в бд)
https://metanit.com/sharp/entityframework/6.9.php


Наследование в Entity Framework

public class Phone
{
    public int Id { get; set; }
}
 
public class Smartphone : Phone
{
    public string OS { get; set; }
}
 public DbSet<Phone> Phones { get; set; }
    public DbSet<Smartphone> Smarts { get; set; }
создается 1 таблица
при получении Phone из бд вернутся и Phone и Smartphone

если добавить так
[Table("Smartphones")]
public class Smartphone : Phone
{
то будут созданы 2 таблицы, в 1 все свойства базового во 2 все свойства производного

для базового и наследника создаются 2 разные таблицы и в каждом свои свойства
https://metanit.com/sharp/entityframework/7.3.php








sql
добавление своей функции sql
https://metanit.com/sharp/entityframework/5.2.php

Хранимые процедуры
https://metanit.com/sharp/entityframework/5.3.php

Fluent API и аннотации//переопределение того как enfr будет связывать таблицы ключи и тд(например изменить тип или название таблицы)
https://metanit.com/sharp/entityframework/6.1.php
https://metanit.com/sharp/entityframework/6.2.php


#выполнение #sql скрипта  #ExecuteSqlCommand #SqlQuery
db.Database.ExecuteSqlCommand("");
var comps = db.Database.SqlQuery<Company>("SELECT * FROM Companies");
возвращает количество затронутых строк
int numberOfRowInserted = db.Database.ExecuteSqlCommand("INSERT INTO Companies (Name) VALUES ('HTC')");
получить строку подключения
db.Database.Connection.ConnectionString




выполнение любого( создание каталога, индекса и тд ) #tsql скрипта из файла
#full #text #search   #fulltextsearch #SqlConnection #ExecuteNonQuery ExecuteQuery #Query
 var connection = new SqlConnection();
            connection.ConnectionString = "connection string";
            connection.Open();
                string script = File.ReadAllText(HostingEnvironment.MapPath($"~/tsqlscripts/file_name.txt"));
                
                using (var command = new SqlCommand(script, connection))
                {
                    command.ExecuteNonQuery();
                }

                connection.Close();




получить данные из бд без классов и тдтд

class DbManager
    {
        SqlConnection connection;
        SqlCommand command;

        public DbManager()
        {
            connection = new SqlConnection();
            connection.ConnectionString = @"Data Source=(LocalDb)\MSSQLLocalDB;AttachDbFilename=|DataDirectory|\SOFI.mdf;Integrated Security=True";
            command = new SqlCommand();
            command.Connection = connection;
            command.CommandType = CommandType.Text;
        } // constructor

        public bool GetUsersData(ref string lastname, ref string firstname, ref string age)
        {
            bool returnvalue = false;
            try
            {
                command.CommandText = "select * from ActionPros where firstname=@firstname and lastname=@lastname";
               // command.Parameters.Add("firstname", SqlDbType.VarChar).Value = firstname;
                //command.Parameters.Add("lastname", SqlDbType.VarChar).Value = lastname;
                connection.Open();
                SqlDataReader reader = command.ExecuteReader();
                if (reader.HasRows)
                {
                    while (reader.Read())
                    {

                        lastname= reader["actionId"].ToString();
                        firstname = reader["prosId"].ToString();
                        // age = reader.GetString(3);


                    }
                }
                returnvalue = true;
            }
            catch
            { }
            finally
            {
                connection.Close();
            }
            return returnvalue;

        }

    }
}



получаем данные
DbManager db = new DbManager();

                bool status = db.GetUsersData(ref lastname, ref firstname, ref age);





выполнение tsql скрипта ( создание каталога, индекса и тд ) из файла или из строки

 /// <summary>
        /// выполнение tsql запроса который ничего не возвращает
        /// </summary>
        /// <param name="query - будет использоваться только если command_==null"></param>
        /// <param name="command_ - если не null то не закрывается"></param>
        public static void ExecuteNonQuery(string query, SqlCommand command_ = null)
        {
            var command = command_;
            if (command_ == null)
            {
                var connection = new SqlConnection() { ConnectionString = Constants.sql_0 };
                connection.Open();
                command = new SqlCommand(query, connection);

            }
            command.ExecuteNonQuery();

            if (command_ == null)
            {
                command.Connection.Close();
                command.Dispose();
            }
            
        }

            



выполнение tsql скрипта ( выборка данных) из файла или из строки, метод возвращает данные

/// <summary>
        /// выполнение tsql запроса(например выборка данных) который возвращает данные. при command_-null - откроет новое подключение
        /// </summary>
        /// <param name="query - будет использоваться только если command_==null"></param>
        /// <param name="command_ - если не null то не закрывается"></param>
        /// <param name="props - список свойств"></param>
        /// <returns></returns>
        public static List<Dictionary<string, object>> ExecuteQuery(string query, SqlCommand command_, params string[] props)
        {
            List<Dictionary<string, object>> res = new List<Dictionary<string, object>>();

            var command = command_;
            if (command_ == null)
            {
                var connection = new SqlConnection() { ConnectionString = Constants.sql_0 };
                connection.Open();
                command = new SqlCommand(query, connection) { CommandType = CommandType.Text };

            }

            using (SqlDataReader reader = command.ExecuteReader())
                if (reader.HasRows)
                    while (reader.Read())
                    {
                        Dictionary<string, object> dict = new Dictionary<string, object>();
                        foreach (var i in props)
                            dict.Add(i, reader[i]);
                        res.Add(dict);
                    }
            if (command_ == null)
            {
                command.Connection.Close();
                command.Dispose();
            }

            return res;
        }
//получаем данные, вызов функции
var ldr=DataBase.DataBase.ExecuteQuery(q, "keyphrase");
            foreach (var i in ldr)//список всех выбранных строк
                res += i["keyphrase"].ToString()+" ";

            return res.Trim();













#Инициализация #базы #данных #seed  #ef #bd #entity #framework

CreateDatabaseIfNotExists: инициализатор, используемый по умолчанию. Он не удаляет автоматчески базу данных и данные, а в случае изменения структуры моделей и контекста данных выбрасывает исключение.

DropCreateDatabaseIfModelChanges: данный инициализатор проверяет на соответствие моделям определения таблиц в базе данных. И если модели не соответствуют определению таблиц, то база данные пересоздается

DropCreateDatabaseAlways: этот инициализатор будет всегда пересоздавать базу данных


при старте
https://metanit.com/sharp/entityframework/3.9.php

class AppDbInitializer : DropCreateDatabaseAlways<ApplicationDbContext>
{
    protected override void Seed(ApplicationDbContext db)//название котекста
    {
//доп инфа по ролям и созданию пользователей по тегу #roles

db.Phones.Add();
        db.SaveChanges();

base.Seed(db);//context
    }
}

Объявление
так:
добавить в класс контекста (статический конструктор)
//class ApplicationDbContext : DbContext  или так может быть объявлен public class ApplicationDbContext : IdentityDbContext<ApplicationUser>
//{
static ApplicationDbContext()
    {
        Database.SetInitializer<ApplicationDbContext>(new AppDbInitializer());
    }
или так

в файл global.asax
 public class MvcApplication : System.Web.HttpApplication
    {
        protected void Application_Start()
        {
            Database.SetInitializer<ApplicationDbContext>(new AppDbInitializer());

AppDbInitializer  объявить в папке  Models->DataBase




#roles  #seed

к методу [Authorize(Roles="admin")] [Authorize]

в AppDbInitializer->seed

using Microsoft.AspNet.Identity;//!!!!!!!!!!!!!



var userManager = new ApplicationUserManager(new UserStore<ApplicationUser>(context));

            var roleManager = new RoleManager<IdentityRole>(new RoleStore<IdentityRole>(context));
 var role1 = new IdentityRole { Name = "admin" };
roleManager.Create(role1);
//создание юзера пользователя
var admin = new ApplicationUser { Email = "admin@mail.ru", UserName = "admin@mail.ru", Name="zsuz",Surname="zsuzSUR",Birthday=DateTime.Now };
            string password = "Admin1!";
            var result = userManager.Create(admin, password);
// если создание пользователя прошло успешно
            if (result.Succeeded)
            {
                // добавляем для пользователя роль
                userManager.AddToRole(admin.Id, role1.Name);
	}


для добавления роли при регистрации
accountController
public async Task<ActionResult> Register(RegisterViewModel model){
// после этой строки await SignInManager.SignInAsync(user, isPersistent:false, rememberBrowser:false);
await UserManager.AddToRoleAsync(user.Id, "user");




#roles
 ApplicationUserManager userManager = HttpContext.GetOwinContext()
                                            .GetUserManager<ApplicationUserManager>();
IList<string> roles=userManager.GetRoles(user.Id);
//еще вариант возвращает для зарегистрированного пользователя
System.Web.Security.Roles.GetRolesForUser();
//вернет id ролей(сложный объект)
using(var db=)
this.Roles;
db.Roles.where(=>);

//проверить принадлежит ли пользователь к роли
 System.Web.HttpContext.Current.User.IsInRole("role");
//если нужно закинуть контекст в метод то по такому типу данных "System.Web.HttpContextBase"






#check_id  #UserName #Current #FindById


string userName = Membership.GetUser(userId).UserName;

HttpContext.Current.GetOwinContext().GetUserManager<ApplicationUserManager>().FindById(ID).UserName;









сформировать классы по базе данных
создать класс "linq to sql classes"
в его конструктор просто перетаскивать из бд таблицы


#ef #entity framework
#mdf #bak #ssms
создать mdf из bak файла
по базе данных в microsoft SQL server management studio       задачи->восстановить-> там посоздавать бд   и потом правой кнопкой мыши по ней создать скрипт->использую create там будут пути куда создались файлы будет что то типа
C:\Program Files\Microsoft SQL Server\MSSQL12.SQLEXPRESS\MSSQL\DATA\SOFI.mdf


#SQL #server
расположение server и способ его включить если выключился
C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Microsoft SQL Server 2017 ->Средства настройки->Диспетчер конфигурации SQL Server 2017

//TODO где то уже есть инфа про строку подключения но другая, надо перетащить сюда
для формирования #connection #string  #connectionstring
@"Data Source=.\SQLEXPRESS01;AttachDbFilename=|DataDirectory|\PhysicalEffects.mdf;Integrated Security=True"
Data Source- ИМЯСЕРВЕРА\ИМЯИНСТАНСА
можно просто через local задать --  (LocalDb)\MSSQLLocalDB    -- имя можно узнать в cmd -comand---- sqllocaldb i
можно явно задать .\SQLEXPRESS01  ---  можно узнать какие доступны в  поиск->services ->найти sql server и то что в скобках можно пробовать использовать

#версии #версия #version sql server 
https://sqlserverbuilds.blogspot.com/2014/01/sql-server-internal-database-versions.html?m=1


























 #block #db #ef //#TODO
блокировка записи бд для редактирования и удаления  https://metanit.com/sharp/entityframework/3.10.php

#транзакции #tranzaction #transaction

using(UserContext db = new UserContext())
{
using (var transaction = db.Database.BeginTransaction())
    {
try
        {
            
            db.SaveChanges();
            transaction.Commit();
        }
        catch (Exception ex)
        {
            transaction.Rollback();
        }

}
}










миграция https://metanit.com/sharp/entityframework/3.12.php

мб уже писал db.Entry(p).State = EntityState.Modified;
#присоединение к #контексту context.Set<User>().Attach(user); //#TODO проверить доблируется ли


репозитории 
https://metanit.com/sharp/entityframework/3.13.php











#regexp #regex #регулярки #регулярные #выражения

//спецсимволы которые надо экранировать символом \
Можно экранировать целую последовательность символов, заключив её между \Q и \E
[ ] \ / ^ $ . | ? * + ( ) { }

. - 1 любой символ но в некоторых реализациях исключая символ новой строки. Вместо символа . можно использовать [\s\S] (все пробельные и непробельные символы, включая символ новой строки)

////////Набор символов в квадратных скобках [ ] именуется символьным классом и позволяет указать интерпретатору регулярных выражений, что на данном месте в строке может стоять один из перечисленных символов.
[abd] - 1 из символов в скобках можно описать через (|)
[А-Яа-я] соответствует всем буквам русского алфавита, за исключением букв «Ё» и «ё»
^ в квадратных скобках  -символы, которые не входят в указанный набор.  [^0-9] означает любой символ, кроме цифр.

\d	[0-9]	Цифровой символ
\D	[^0-9]	Нецифровой символ
\s	[ \f\n\r\t\v]	Пробельный символ
\S	[^ \f\n\r\t\v]	Непробельный символ
\w	[[:word:]]	Буквенный или цифровой символ или знак подчёркивания
\W	[^[:word:]]	Любой символ, кроме буквенного или цифрового символа или знака подчёркивания


^	Начало текста (или строки при модификаторе ?m)	^a	Aaa aaa
$	Конец текста (или строки при модификаторе ?m)	a$	aaa aaA
\b	Граница слова	a\b	aaA aaA
			\ba	Aaa Aaa
\B	Не граница слова	\Ba\B	aAa aAa
\G	Предыдущий успешный поиск	\Ga	AAA aaa (поиск остановился на 4-й позиции — там, где не нашлось a)


() - Круглые скобки используются для определения области действия и приоритета операций. Шаблон внутри группы обрабатывается как единое целое и может быть квантифицирован

| - допустимые варианты - a|b -найдет a и b
gray|grey  === gr(a|e)y ===(можно и так)gr[ae]y




?	Ноль или одно	{0,1}	colou?r	color, colour
*	Ноль или более	{0,}	colou*r	color, colour, colouur и т. д.
+	Одно или более	{1,}	colou+r	colour, colouur и т. д. (но не color)
{n}	Ровно n раз	colou{3}r	colouuur
{m,n}	От m до n включительно	colou{2,4}r	colouur, colouuur, colouuuur
{m,}	Не менее m	colou{2,}r	colouur, colouuur, colouuuur и т. д.
{,n}	Не более n	colou{,3}r	color, colour, colouur, colouuur


!!!
Жадная и ленивая квантификация
(<.*>) - с жадной выделит весь html тела

Жадный	Ленивый
*	*?
+	+?
{n,}	{n,}?

#TODO
ab(xa)*+a	abxaabxaa; но не abxaabxaa, так как буква a уже занята
Жадный	Ревнивый
*	*+
?	?+
+	++
{n,}	{n,}+




А(?#тут комментарий)Б соответствует строке АБ


Флаги указываются после регулярного выражения (порядок флагов значения не имеет) /[0-9]$/m
g — глобальный поиск (обрабатываются все совпадения с шаблоном поиска).
i — регистр букв не имеет значения;
m — многострочный поиск.
s — текст трактуется как одна строка, в этом случае метасимволу . (точка) соответствует любой одиночный символ, включая символ новой строки;
u — unicode трактовка. Выражение может содержать специальные паттерны, характерные для уникода, `/\p{Lu}/ - заглавные буквы` например.






можно искать не создавая объект
Regex.Matches((string)sentence, (string)pattern)


//поиск вхождений всех
string pattern = @"\b\w+es\b";
      Regex rgx = new Regex(pattern);
      string sentence = "Who writes these notes?";
      
//можно указать с какой позиции начать поиск --rgx.Matches(sentence, match.Index + match.Length)  
      foreach (Match match in rgx.Matches(sentence))
         Console.WriteLine("Found '{0}' at position {1}", 
                           match.Value, match.Index);


//поиск вхождений по порядку
Match match = regex.Match(input);
while (match.Success) {
      // Handle match here...

      match = match.NextMatch();




js
''.replace(/\[/g,'<');//регулярка без кавычек



var str = '<h1>Привет, мир!</h1>';
var reg = /<(.*?)>/;
alert( str.match(reg) );

//найти все вхождения
while ((match = reg.exec(str)) !== null) {
  alert(match);










///////////////////////////////////////OLD--------------------------------------









подключение файлов
@Scripts.Render("~/scripts/jquery.validate.min.js")
<script src="@Url.Content("~/scripts/jquery.validate.min.js")" type="text/javascript"></script>


явная #привязка #bind #params
public ActionResult Edit()
{
    var book = new Book();
    try
    {
        #UpdateModel(book);// #TryUpdateModel тоже самое но без исключений и возвращает bool

Выборочная привязка
можно применять к свойству модели и к самой модели
	привязываются только указанные свойства
	public ActionResult Create([Bind (Include="Name, Author")] Book b)
	([Bind (Exclude="Year")] Book b)  исключает из привязки







#ActionResult
наследники
System.Web.Mvc.#ContentResult
System.Web.Mvc.#EmptyResult  #пустой #ответ
System.Web.Mvc.#FileResult
System.Web.Mvc.#HttpStatusCodeResult
System.Web.Mvc.#JavaScriptResult
System.Web.Mvc.#JsonResult
System.Web.Mvc.#RedirectResult
System.Web.Mvc.#RedirectToRouteResult
System.Web.Mvc.#ViewResultBase

return new EmptyResult();







#Response

HttpCookie MyCookie = new HttpCookie("LastVisit");
DateTime now = DateTime.Now;
MyCookie.Value = now.ToString();
MyCookie.Expires = now.AddHours(1);
Response.Cookies.Add(MyCookie);



получить параметры  #params #get #post
#request
	при post 
	b.Name = Request.Form["Name"];
HttpContext.Request.Params.Get("param.1");
this.Request.QueryString["param.1"];
Request.Form. В данном случае привязчик получает значения, отправленные с помощью форм
RouteData.Values. Здесь получает значения с помощью маршрутов приложения
Request.QueryString. В данном случае привязчик извлекает значения из строки запроса
Request.Files. В данном случае используются загруженные на сервер файлы
Request.Cookies		Cookie-наборы, отправленные браузером с этим запросом
Request.HttpMethod		Метод HTTP (команда наподобие GET или POST), используемый для этого запроса
Request.Headers		Полный набор заголовков HTTP, отправленных с этим запросом
Request.Url		Элемент RouteTable.Routes, выбранный для этого запроса
Request.UserHostAddress		IP-адрес пользователя, сделавшего этот запрос
RouteData.Route		Элемент Routetable.Routes, выбранный для этого запроса
RouteData.Values		Активные параметры маршрута (либо извлеченные из URL, либо стандартные значения)
HttpContext.Application		Хранилище состояния приложения
HttpContext.Cache		Хранилище кеша приложения
HttpContext.Items		Хранилище состояния для текущего запроса
HttpContext.Session		Хранилище состояния для сеанса посетителя
User		Аутентификационная информация о вошедшем пользователе
TempData		Временные элементы данных, сохраненные для текущего пользователя
(string)RouteData.Values["city"]





#валидация    #attr #validate
   https://metanit.com/sharp/mvc5/7.1.php
атрибуты для полей для валидации 
System.ComponentModel.DataAnnotations 
(ErrorMessage ="Идентификатор пользователя не установлен")--может быть у всех атрибутов
  [Required]-- (свойство обязательно должно быть задано)
[Required(ErrorMessage = "Поле должно быть установлено")]--с сообщением
[RegularExpression (@"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}", ErrorMessage = "Некорректный адрес")]-- проверка регулярками
[StringLength(50, MinimumLength = 3, ErrorMessage = "Длина строки должна быть от 3 до 50 символов")]-- ограничение длины строки
[Range(typeof(decimal), "0.00", "49.99")]   [Range(1700,2000,ErrorMessage="Недопустимый год")]
//
оба свойства должны иметь одинаковое значение
[DataType(DataType.Password)]
public string Password { get; set; }
 
[Compare("Password",ErrorMessage="Пароли не совпадают")]
[DataType(DataType.Password)]
public  string PasswordConfirm { get; set; }

//#валидация для проверки на #сервере
//перед свойством
[System.Web.Mvc.Remote("CheckExistingEmail", "Account", HttpMethod = "POST", ErrorMessage = "Email already exists")]
    
//
 // не нужно? [Remote("CheckName", "Home", ErrorMessage = "Name is not valid.")]
//return false если проверка не пройдена и true если норм
//[HttpGet]
public JsonResult CheckName(string name)
{
    var result = !(name=="Название");
    return Json(result, JsonRequestBehavior.AllowGet);
}
//

User user = new User { Name = name, Age = age };//создание объекта для которого настроена валидация атрибутами
//массив в котором будут ошибки
var results = new List<ValidationResult>();
//контекст валидации
            var context = new ValidationContext(user);
//bool -надо ли валидировать все свойства
            if (!Validator.TryValidateObject(user, context, results, true))
            {
                foreach (var error in results)
                {
                    Console.WriteLine(error.ErrorMessage);
                }
            }




 @Html.EditorFor(model => model.Name)
    @Html.ValidationMessageFor(model => model.Name)
валидация на сервере
public ActionResult Create([Bind(Include="Id,Name,Author,Year")] Book book){
if (ModelState.IsValid){//#IsValid
//#ModelState хранит все принятые свойства и флаг ошибки для каждого


ModelState.AddModelError("Name", "Некорректное название книги"); ---добавить "ошибку валидации" при "Name"=="" это ошибка уровня модели

//по ссылке все примеры и css
https://metanit.com/sharp/mvc5/7.2.php



создание своих атрибутов для валидации

//суффикс Attribute
//применять без суффикса [UserName]
public class UserNameAttribute : ValidationAttribute
{
    public override bool IsValid(object value)
    {
        if (value != null)
        {
//или к любому типу, если атрибут для всей модели а не для свойства то просто к объекту приводить
            string userName = value.ToString();
//если к моделе то можно так
this.ErrorMessage = "сообщение об ошибке";
        }
//false проверка не пройдена true-пройдена
        return false;
    }
}


Самовалидация модели

 public class User : IValidatableObject
    {
public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
        {
            List<ValidationResult> errors = new List<ValidationResult>();
 
            if (string.IsNullOrWhiteSpace(this.Name))
                errors.Add(new ValidationResult("Не указано имя"));
return errors;
        }}











#маршрутизация #routing
routes.IgnoreRoute("{resource}.axd/{*pathInfo}");
игнорирование routes.IgnoreRoute("Home/Index/12");
 
       routes.MapRoute(
                name: "Default",
                url: "{controller}/{action}/{id}",
                defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
            );
много параметров routes.MapRoute(name: "Default", url: "{controller}/{action}/{id}/{*catchall}",defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional});


#получить #параметры при том что выше , и тд
 string controller = RouteData.Values["controller"].ToString();
 string catchall = RouteData.Values["catchall"].ToString();//вернет все параметры

ограничения для маршрутов
routes.MapRoute(name: "",url: "",defaults: new { },
        constraints: new {controller="^H.*" , id = @"\d{2}" }//регулярки
);



routing через атрибуты https://metanit.com/sharp/mvc5/6.7.php





 



@RenderSection("Footer", false)   #рендер необязательной #секция #RenderSection

рендер необязательной секции с кодом по умолчанию
 @if (IsSectionDefined("Footer")) {
        @RenderSection("Footer")
    }
    else 
    { 
        <span>Содержание элемента footer по умолчанию.</span>   
    }

определение секции в view 
@section Footer {
    Все права защищены. Syte Corp. 2012.
}





	создание #healper хелпера в файле представления
@helper BookList(IEnumerable<BookStore.Models.Book> books)
{}
@BookList(ViewBag.Books)


	#создание #healper #хелпера в отдельном файле #helper
создать в проекте папку под названием App_Code(именно такое)
создать представление в ней MyHelpers.cshtml
@helper HtmlList(string[] items)
{<div></div>}
@MyHelpers.HtmlList(new string[] { "Лондон", "Париж", "Берлин" })

	создание healper хелпера в отдельном файле на c#
создадать в проекте новую папку Helpers и добавим в нее новый класс ListHelper

namespace BookStore.Helpers
{
    public static class ListHelper
    {
        public static MvcHtmlString CreateList(this HtmlHelper html, string[] items, object htmlAttributes = null)
        {
            TagBuilder ul = new TagBuilder("ul");
            ul.MergeAttributes(HtmlHelper.AnonymousObjectToHtmlAttributes(htmlAttributes));
            return new MvcHtmlString(ul.ToString());
        }
    }
}
@using BookStore.Helpers
@Html.CreateList(cities, new { @class = "btn", id = "citiesList" })






Передача данных из контроллера в представление
#ViewData["

 ViewData["Head"] = "Привет мир!";
<h2>@ViewData["Head"]</h2>

#ViewBag

ViewBag.Head = "Привет мир!";
 <h2>@ViewBag.Head</h2>

#ViewData
при data известен тип 

@Html.TextBox("name", ViewData["Name"])
@Html.TextBox("name", (string)ViewBag.Name)

#TempData
хранится до момента прочтения, применение как у data






#redirect #TODO мбдублируется
так нельзя передавать сложные типы данных!!!! можно закинуть в TempData
return #RedirectToAction("ListFeText", "Physic", new { listId = list_id });
return #RedirectToRoute(new { controller = "Physic", action = "ListFeText", listId = list_id });

return Redirect("/Home/Index");//временная
 return RedirectPermanent("/Home/Index");//пермач




#JS

#отмена #клика #cancel #click #остановка #отстановить #отмена #клик

event.stopPropagation();

это не будет работать если этот блок в ссылке, но будет если внешней ссылки нет
onclick='event.stopPropagation()'

||
 elem = document.getElementById("tbl1");
  elem.addEventListener("click", stopEvent, false);

function stopEvent(ev) {
  // this ought to keep t-daddy from getting the click.
  ev.stopPropagation();
}




















#c#

как определить что символы выглядят одинаково

char first = 'A';//angl
        char second = 'А';//rus
string firstNormalized = first.ToString().Normalize(NormalizationForm.FormKD);
        string secondNormalized = second.ToString().Normalize(NormalizationForm.FormKD);
Console.WriteLine(first.Equals(second));                     // False
        Console.WriteLine(firstNormalized.Equals(secondNormalized)); // True






#SQL

https://www.opennet.ru/docs/RUS/rusql/#ch3
https://jsehelper.blogspot.com/2016/01/sql-2.html и предыдущая статья



Логический порядок обработки инструкции SELECT:

1 FROM
2 ON
3 JOIN
4 where
5 GROUP BY
6 WITH CUBE или WITH ROLLUP
7 HAVING
8 SELECT
9 DISTINCT
10 ORDER BY
11 TOP





#as


переименовываем поле в результате
SELECT *, count(*) AS x,
переименовываем  таблицу в запросе
from news_cat AS nc


получаем текущую дату
SELECT GetDate();

будем рассматривать капсом
WHERE  UPPER(EmpName) 

получаем год
SELECT YEAR(GETDATE()) as "Год";

при обращении к полю сущности можно опускать название таблицы пока используется только 1 (table_name.prop_name)
создание бд
CREATE DATABASE IF NOT EXISTS article;

просмотреть сазданные таблицы
SHOW TABLES; 

сплитить мб в tsql
SELECT value FROM STRING_SPLIT('Lorem ipsum dolor sit amet.', ' ');

если вместо * поля вписать, то вернутся только поля и именно в том порядке в котором указали
вывод всех строк таблицы
SELECT * FROM table1;

вернуть поля по условию
SELECT phone_id, user_id FROM table2 WHERE phone_number=200;
limit - 1 число  включается(будет пропущено 1 строка), и вернется 3 строки
SELECT phone_id, user_id FROM table2 WHERE phone_number=200 LIMIT 1, 3;

убирает дублирующиеся данные в результате выполнения(только если все поля совпали)
SELECT DISTINCT snum FROM Orders;

противоположность DISTINCT, используется по умолчанию
ALL 



WHERE

сложные предикаты

AND берет два булевых значения (в форме A AND B) как аргументы и оценивает, верны ли они оба.
OR берет два булевых значения (в форме A OR B) как аргументы и оценивает, верен ли один из них.
NOT берет одиночное булево значение (в форме NOT A) как аргумент и заменяет его значение с неверного на верное или с верного на неверное (инвертирует).



SELECT  *
FROM Customers
WHERE city = " San Jose'
AND rating > 200;

OR NOT rating > 200;

только к 1 
WHERE NOT city = " San Jose'
                      OR rating > 200;


ко всем
WHERE NOT(city = " San Jose'
                      OR rating > 200);



ОПЕРАТОР IN

выберет все где  city соответствует 1 из значений
SELECT *
          FROM Salespeople
          WHERE city IN ('Barcelona', 'London');

ОПЕРАТОР BETWEEN

все у чего comm находится между .10 и .12 или равно им 
 SELECT *
             FROM Salespeople
             WHERE comm BETWEEN .10 AND .12;

ОПЕРАТОР LIKE

символ подчёркивания ( _ ) замещает любой одиночный символ.
знак процента (%) замещает последовательность любого количества символов (включая символы нуля)

Выбираем из table3 все значения поля room_id, для которых room_number начинается с цифры 3 (% означает любое количество любых символов
SELECT room_id FROM table3 WHERE room_number LIKE '3%';

определяем оператор который указывает на то что используем именно этот символ а не то что он должен делать(то что выше написано)
 SELECT *
             FROM Salespeople
             WHERE sname LIKE '%/_%' ESCAPE '/';



IS NULL
находим все с null полем, просто через = сравнивать нельзя
SELECT *
               FROM Customers
               WHERE city IS NULL;



SELECT *
             FROM Customers
             WHERE city NOT NULL;






создание таблицы
CREATE TABLE `table1` (`user_id` INT(5) NOT NULL AUTO_INCREMENT, `username` VARCHAR(50), PRIMARY KEY(`user_id`), INDEX(`username`));


переименовать таблицу
RENAME TABLE table1 TO nya; 


Переименовать поле user_id в id (таблица table1)
ALTER TABLE table1 CHANGE user_id id INT; 


Меняем тип и атрибут поля phone_number:
ALTER TABLE table2 MODIFY phone_number VARCHAR(100) NOT NULL; 

Просмотр описания таблицы table1:
DESCRIBE table1;


Добавляем поле abra типа DATE:
ALTER TABLE table3 ADD abra  DATE; 

добавление данных
INSERT INTO table1 (username,...) VALUES ('foo',...); 

удаление данных по условию
DELETE FROM table1 WHERE user_id = 1;

обновить запись с условием
UPDATE table2 SET user_id='2', phone_number='200' WHERE phone_id='1';

сортировка по возрастанию
SELECT username FROM table1 ORDER BY username;
несколько столбцов
SELECT *
               FROM Orders
               ORDER BY cnum DESC, amt DESC;



по убыванию
SELECT username FROM table1 ORDER BY username DESC;







АГРЕГАТНЫЕ ФУНКЦИИ

COUNT
выдаёт количество строк или не-NULL значений полей, которые выбрал запрос.

общее количество строк в таблице
SELECT COUNT (*)
 FROM Customers

количество записей конкретного столбца за исключением NULL записей
COUNT(column_name)





SUM
выдаёт арифметическую сумму всех выбранных значений данного поля.
AVG
выдаёт усреднение всех выбранных значений данного поля.
MAX
выдаёт наибольшее из всех выбранных значений данного поля.
MIN
выдаёт наименьшее из всех выбранных значений данного поля.

SELECT AVG (amt)
       FROM Orders;




GROUP BY
TODO


HAVING
TODO



DISTINCT 
используется для указания на то, что следует работать только с уникальными значениями столбца
SELECT DISTINCT column_name FROM table_name









вывод

SELECT snum, sname, city, ' % ', comm * 100
               FROM Salespeople;
 1001   Peel      London       %   12.000000 




#exist
если вернет больше 1 строки то true
SELECT DISTINCT maker
FROM Product AS lap_product
WHERE type = 'laptop' AND 
 EXISTS (SELECT maker
 FROM Product
 WHERE type = 'printer' AND 
 maker = lap_product.maker
 );







JOIN


для 1 таблицы
SELECT e.name, m.name FROM Employee e, Employee m 
WHERE e.mgr_id = m.emp_id;


без join, вроде бы
SELECT Customers.cname, Salespeople.sname
                FROM Customers, Salespeople
                WHERE Salespeople.snum = Customers.snum;
// условия могут быть и такими
WHERE sname < cname
                      AND rating < 200;




несколько join

SELECT table3.room_number FROM table1 
INNER JOIN table2 ON table1.user_id = table2.user_id 
INNER JOIN table3 ON table2.phone_id = table3.phone_id 
WHERE table1.username = 'qux';



FROM
  Table1
  {INNER | {LEFT | RIGHT | FULL} OUTER | CROSS } JOIN
  Table2
    {ON <condition> | USING (field_name [,... n])}



INNER JOIN
соединение 2х таблиц по полю все лишнее отбрасывается
SELECT *
FROM
  Person
  INNER JOIN
  City
    ON Person.CityId = City.Id


LEFT OUTER JOIN
соединеяется все что может соединяться но
все в таблице слева остаются все
те что слева не соединениль null становятся
справа отбрасываются


SELECT *
FROM
  Person -- Левая таблица
  LEFT OUTER JOIN
  City   -- Правая таблица
    ON Person.CityId = City.Id


RIGHT OUTER JOIN
противоположность left


FULL OUTER JOIN
чсоединяет все но также все сохраняет с null


CROSS JOIN
соединяет каждое с каждым




#транзакция

Транзакция предполагает, что все, входящие в нее SQL-запросы будут обязательно выполнены, причем одновременно.

Начать транзакцию можно при помощи команды BEGIN TRANSACTION. Завершить можно либо сохранив изменения в базе данных при помощи команды COMMIT, либо удалив все сделанные транзакцией изменения командой ROLLBACK
При работе с транзакциями возможны 2 варианта:
результаты выполнения всех запросов, входящих в транзакцию, будут применены к базе данных
все внесенные изменения в базу данных будут отменены (откатаны).

BEGIN TRANSACTION
UPDATE user_account SET balance=balance-100 WHERE account_id=1 /* Снимаем деньги со счета,ID которого равен 1 */
UPDATE user_account SET balance=balance+100 WHERE account_id=2 /* И переводим эти деньги на счет, ID которого равен 2 */
COMMIT








#блокировка #lock

Существует 2 вида взаимодействий с базой данных, которые требуют блокировки 2-х разных типов:
Разделяемая блокировка 
Когда пользователь считывает данные, его совершенно не волнует кто эти данные считывает еще. 
При подобных операциях на данные накладывается разделяемая блокировка, которая говорит о том, что любая транзакция может выполнять эту же операцию с данными, т.к. она не изменяет их и не сможет привести ни к каким побочным эффектам.
Монопольная блокировка 
В случае, если выполняемая операция изменяет данные, на них накладывается монопольная блокировка, которая позволяет изменять данные только одному пользователю. 
СУБД не может устанавливать монопольную блокировку на данные, на которые уже установлена разделяемая блокировка. Такое ограничение имеет смысл как для пользователя, который записывает данные, так и для пользователя, который их считывает.




#HAVING
"В чем различие между выражениями HAVING и WHERE"

WHERE - это ограничивающее выражение. Оно выполняется до того, как будет получен результат операции.

HAVING - фильтрующее выражение. Оно применяется к результату операции и выполняется уже после того как этот результат будет получен, в отличии от where.
Выражения WHERE используются вместе с операциями SELECT, UPDATE, DELETE, в то время как HAVING только с SELECT и предложением GROUP BY

































































#PHP


<?php  ?>

переменные в массиве создаются при обращении к ним , не обязательно при присваивании
$b = array();
foo($b['b']);
array_key_exists('b', $b)//true




включаем строгую типизацию в файле
Строгая типизация применима только к скалярным типам и работает только в PHP 7.0.0 и выше. Равно как и сами объявления скалярных типов добавлены в этой версии.
declare(strict_types=1);


для доступа к объекту мы не ссылку используем как перменную, а в переменной хранится id и по нему получаем доступ
 $a = new A;
$b = $a; //копируется id
$d = &$a;// ссылаемся на id



оббъявление глобальной переменной
global $color;

отправить ответ в формате json
echo json_encode("This string will encode to JSON format");

var_dump Выводит информацию о переменной

method_exists($obg,string method_name);

$a = array(1, 2, array("a", "b", "c"));
var_dump($a);
 array(
    key  => value,
}

PHP_EOL перевод строки


// #перенаправление на скрипт index.php #redirect
//тут надо полностью прописывать адрес, а не так как тут, в мануале написано как именно
    header('Location: index.php');


bool isset($perem) — Определяет, была ли установлена переменная значением, отличным от NULL
unset($a); --уничтожаем переменную

 ?? как в шарпе
$foo ?? $bar ?? $baz ?? $qux; 


get_class — Возвращает имя класса(string), к которому принадлежит объект 

получить ключи объекта
key(obg)




NULL
if($a)
    echo "Переменная a определена и при приведении к bool стала true";
else
    echo "Переменная a не определена или при приведении к bool стала false";


кавычки как в js + \ для использования как символа
одинарные кавычки выводят текст как он есть(нельзя использовать $ для доступа к переменной)


#Константы #const
Если константа $name определена, то функция будет возвращать значение true
bool defined(string $name)

Функция constant() полезна, если вам необходимо получить значение константы, но неизвестно её имя. Например, если оно хранится в переменной или возвращается функцией.
$pricePerItem = constant(__CLASS__ . "::PRICE_" .strtoupper($product));

создание константы
define("NUMBER", 22);
echo NUMBER;
используются такие константы , как и те что ниже просто как переменные

_POST["a"] - запрос формы
_GET["a"] - get запрос
__FILE__: хранит полный путь и имя текущего файла

__LINE__: хранит текущий номер строки, которую обрабатывает интерпретатор

__DIR__: хранит каталог текущего файла

__FUNCTION__: название обрабатываемой функции

__CLASS__: название текущего класса

__METHOD__: название обрабатываемого метода

__NAMESPACE__: название текущего пространства имен



тип переменной
is_integer($a): возвращает значение TRUE, если переменная $a хранит целое число
is_string($a): возвращает значение TRUE, если переменная $a хранит строку
is_double($a): возвращает значение TRUE, если переменная $a хранит действительное число
is_numeric($a): возвращает значение TRUE, если переменная $a представляет целое или действительное число или является строковым представлением числа. Например:
is_bool($a): возвращает значение TRUE, если переменная $a хранит значение TRUE или FALSE
is_scalar($a): возвращает значение TRUE, если переменная $a представляет один из простых типов: строку, целое число, действительное число, логическое значение.
is_null($a): возвращает значение TRUE, если переменная $a хранит значение NULL
is_nan()
is_array($a): возвращает значение TRUE, если переменная $a является массивом
is_object($a): возвращает значение TRUE, если переменная $a содержит ссылку на объект
gettype($a): возвращает тип переменной $a, например, integer (целое число), double (действительное число), string (строка), boolean (логическое значение), NULL, array (массив), object (объект) или unknown type.


установить тип переменной
params 1-переменная 2-строка с типом(результат gettype())
settype()
$a = 10.7;
settype($a, "integer");
echo $a; // 10


if(NULL) --- false
 

#static статические переменные
если в функции то 1 на все функции(доступ к ней из функции просто как к переменной)
function getCounter()
{
    static $counter = 0;
}


global
определение глобальной переменой
можно обратиться из любой части программы
global $gvar;



array_walk()
Применяет заданную пользователем функцию к каждому элементу массива
Обычно функция callback принимает два параметра. В качестве первого параметра идет значение элемента массива array, а ключ - в качестве второго.
Если требуется, чтобы функция callback изменила значения в массиве, определите первый параметр callback как ссылку
Потенциально изменены могут быть только значения массива array; структура самого массива не может быть изменена, то есть нельзя добавить, удалить или поменять порядок элементов.

$fruits = array("d" => "lemon", "a" => "orange", "b" => "banana", "c" => "apple");

function test_alter(&$item1, $key, $prefix)
{
    $item1 = "$prefix: $item1";
}

array_walk($fruits, 'test_alter', 'fruit');
//можно вместо 2 параметра, use-это захват переменных в функцию
$callback =
            function ($quantity, $product) use ($tax, &$total)
            {
};




объединение массива в строку с разделителем
$comma_separated = implode(",", $array);




сравнение строк
Возвращает отрицательное число, если str1 меньше str2, положительное число, если str1 больше str2, и 0, если строки равны.
с учетом регистра
strcmp($var1, $var2) !== 0
первые n символы
int strncmp ( string $str1 , string $str2 , int $len )
strcasecmp — Бинарно-безопасное сравнение строк без учета регистра

#class

class A
{
    function foo()
    {
}


// если относится к классу то класс нельзя наследовать, если к методу то метод нельзя переопределять(но он наследуется) в классе наследнике
final function getInfo()//запрещаем наследование
    {
}
}


$a = new A();
//вызов не статичный
//поля также
//статику так нельзя
$a->foo();
//вызов статичный, также можно и не статичный метод вызвать при вызове через parent и тд
A::foo();
переменная A::$foo1;

//создание объекта без параметров
$instance = new SimpleClass();
$instance = new SimpleClass;

// Это же можно сделать с помощью переменной:
$className = 'SimpleClass';
$instance = new $className(); // new SimpleClass()



== свойства объектов просто сравниваются друг с другом, а именно: два объекта равны, если они имеют одинаковые атрибуты и значения (значения сравниваются через ==) и являются экземплярами одного и того же класса.
=== переменные, содержащие объекты, считаются идентичными только тогда, когда они ссылаются на один и тот же экземпляр одного и того же класса







#анонимный
при создании такого объекта анонимного класса, у него нет доступа к переменным класса в которым он осздан(кроме паблик), и их надо передавать в конструкторе
//для protected можно унаследовать анонимный от того в котором создается
//10 сразу вызываем конструктор
$obj=new class(10) extends SomeClass implements SomeInterface {
    private $num;

    public function __construct($num)
    {
        $this->num = $num;
    }

    use SomeTrait;
};


если есть функция(например) которая возвращает объект анонимного класса, то она будет возаращать объекты 1 и того же класса get_class()==


#const #static
public const BAR = 'bar';
echo Foo::BAR
public static $my_static = 'foo';
return parent::$my_static;
$foo = new Foo();
print $foo::$my_static



наследование
class SubClass extends BaseClass {

при наследовании если не переопредлить метод то остается метод класса родителя


// также можно метод с именем класса но это устарело и юзать не надо
конструктор
function __construct() {
       print "Конструктор класса BaseClass\n";
   }

при наследовании если не определяем свой конструктор то он наследуется от базового
если определяем то надо вызвать


function __construct() {
       parent::__construct();
       print "Конструктор класса SubClass\n";
   }



деструктор
наследование как у конструктора, выброс исключений недопустим
function __destruct() {
       print "Уничтожается " . $this->name . "\n";
   }







#перегрузка

добавляем классу магические методы которые позволяют вызывать и обращаться с свойствам или методам которые не объявлены

class PropertyTest 
{
    /**  Место хранения перегружаемых данных.  */
    private $data = array();

    /**  public свойство, будет доступ как обычно методы прегрузки вызываться не будут */
    public $declared = 1;

    /** private  Здесь перегрузка будет использована только при доступе вне класса.  */
    private $hidden = 2;

    public function __set($name, $value) 
    {
        //устанавливаем в массиве
        $this->data[$name] = $value;
    }

    public function __get($name) 
    {
        //получаем из массиве
        if (array_key_exists($name, $this->data)) {
            return $this->data[$name];
        }

      //обработка ошибка
    }

    public function __isset($name) 
    {
        // "Установлено ли '$name'?\n";
        return isset($this->data[$name]);
    }

    
    public function __unset($name) 
    {
        // "Уничтожение '$name'\n";
        unset($this->data[$name]);
    }


//для методов

public function __call($name, $arguments) {
}

//для статического метода
public static function __callStatic($name, $arguments) {

}

}


isset($obj->properyNotContain);//нормально отработает если был установлен до этого
$obj->mthodNotContain();
PropertyTest::StaticMthodNotContain();




















функции
можно указать тип параметра для строгой типизации, если указать класс то как в шарпе, наследники тоже зайдут
можно казать тип интерфейса
public function baz(Test $other)
    {
}


//определяем тип возвращаемого значения
function sum($a, $b): float {
    return $a + $b;
}



// Без "use"
$example = function () {
    var_dump($message);
};
$example();

// Наследуем $message
//$arg -обычный аргумент , message- замыкание,var -замыкание по ссылке
$example = function ($arg) use ($message,&$ var) {
    var_dump($message);
};
$example(11);



$func = static function() {
 $func();




передача по ссылке
function add_some_extra(&$string)
по умолчанию
function makecoffee($type = "капучино")


//скорее всего неверно
//Объекты, которые имеют общий тип (наследуются от одного класса), имеют доступ к элементам с модификатором  protected друг друга, даже если не являются одним и тем же экземпляром. 
//в функции объекта класса можно вызвать прайват функцию другого объекта этого класса или если у них общий родитель





::
позволяющая обращаться к статическим свойствам, константам и переопределенным свойствам или методам класса

class MyClass {
    const CONST_VALUE = 'Значение константы';
}
classname-строка с именем
echo $classname::CONST_VALUE;
MyClass::


??????????????????
с этими словами :: вызываем
parent - вызываем родительский метод (не обязательно статичный????), self - вызываем метод именно этого класса, static - вызываем метод текущего класса. Разница между self и static хорошо видна, например, когда вы делаете new self() или new static() - в первом случае будет создан объект класса, где упомянут self (т.е. создан родитель), во втором - объект того класса, где вызывается метод (т.е. потомок)


в классе объявлена статическая переменная и в методе класса получаем доступ
self::$my_static
в родителе объявлена переменная, получаем к ней доступ
parent::CONST_VALUE






Абстрактные классы



При наследовании от абстрактного класса, все методы, помеченные абстрактными в родительском классе, должны быть определены в дочернем классе;
 кроме того, область видимости этих методов должна совпадать (или быть менее строгой). Например, если абстрактный метод объявлен как protected,
 то реализация этого метода должна быть protected или public, но не private. Более того, объявления методов должны совпадать, то есть контроль типов (type hint) 
и количество обязательных аргументов должно быть одинаковым. К примеру, если в дочернем классе указан необязательный параметр, которого нет в объявлении абстрактного класса, 
то в данном случае конфликта объявлений методов не будет. Это правило также применяется к конструкторам начиная с версии PHP 5.4, ранее объявления конструкторов могли отличаться.


abstract class AbstractClass
{
   /* Данный метод должен быть определён в дочернем классе */
    abstract protected function prefixValue($prefix);

   /* Общий метод */
    public function printOut() {
}
}



необязательный аргументы
public function prefixName($name, $separator = ".") {


работа со строками
"{$prefix}{$separator} {$name}"; =="{val1}{val2} {val3}"



// Объявим интерфейс 'iTemplate'
interface iTemplate
{
    public function setVariable($name, $var);
    public function getHtml($template);
}


class Template implements iTemplate
{


}



interface a
interface b extends a



interface a
{
    const b = 'Константа интерфейса';
}
// константы переопределять нельзя.
class b implements a
{
    const b = 'Константа класса';//ошибка
}









#callback
//вызов функции по названию
call_user_func('my_callback_function');
// Type 2: Вызов статического метода класса
call_user_func(array('MyClass', 'myCallbackMethod'));
// Type 3: Вызов метода класса
$obj = new MyClass();
call_user_func(array($obj, 'myCallbackMethod'));
//B наследник класса A и вызовется метод A, статический
call_user_func(array('B', 'parent::who')); // A

class C {
    public function __invoke($name) {
        echo 'Hello ', $name, "\n";
    }
}
$c = new C();
call_user_func($c, 'PHP!');





$double = function($a) {
    return $a * 2;
};

// Диапазон чисел
$numbers = range(1, 5);
//будет вызвана для каждого числа и вернет массив новых чисел
$new_numbers = array_map($double, $numbers);







#array #массив
$ar=array();
$fruits = array("d" => "lemon", "a" => "orange", "b" => "banana", "c" => "apple");
$phones = array('iPhone', 'Samsung Galaxy S III', 'Nokia N9', 'Sony XPeria Z3');

$phones[0] = "Nokia N9";
$phones[1] = "Samsung Galaxy ACE II";
//ассоциативный массив, для перебора только foreach
$phones["nokia"] = "Nokia N9";

/* Пример 4: многомерные массивы */
$a = array();
$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

#foreach ($a as $v1) {
    foreach ($v1 as $v2) {
        echo "$v2\n";
    }
}
echo $phones["apple"][0];

if (array_key_exists($key, $array))

На каждой итерации значение текущего элемента присваивается переменной $value
foreach (array_expression as $value)
    statement


присвоит ключ текущего элемента переменной $key на каждой итерации+ то что 1
foreach (array_expression as $key => $value)
    statement




при сравнении == === сравнивается длина а потом поэлементно


для изменения в foreach
нужно &
foreach ($arr as &$value) {
    $value = $value * 2;
}
unset($value);//после цикла надо уничтожить, тк продолжит ссылаться



можно так
мы получим кдоступ ко всем ДОСТУПНЫМ свойствам
можно изменить реализовав в классе интерфейс Iterator или IteratorAggregate
$class = new MyClass();

foreach($class as $key => $value) {
    print "$key => $value\n";
}






альтернатива foreach
while (list($key, $value) = each($phones))
    echo "$key => $value <br />";


проверяет является ли переменная массивом
is_array($f)
количеств элементов в массиве
count/sizeof
перемешать элемнты случайным образом
shuffle($os);


compact 
создает из переменных массив с ключами которые соответствуют названиям переменных
$producer = "Apple";
$year = 1978;
$data = compact('model', 'producer', 'year');


сортировка массива
void func(mass);
сортировка по значениям
по алфавиту без регистра и только буквы, числа в порядке возрастания
asort($tablets);
//явно указываем
asort($tablets, SORT_STRING);
SORT_REGULAR: автоматический выбор сортировки
SORT_NUMERIC: числовая сортировка
SORT_STRING: сортировка по алфавиту

сортировка в обратном порядке
arsort($tablets);


сортировка по ключам

ksort($tablets, SORT_STRING);
обратный порядок
krsort($tablets);


сортировка смешанных данных(сортируем по строке в которой текст+ цифры)
естественная сортировка с учетом регистра
natsort($os);
без учета регистра
natcasesort($os);





#each 
проходит по всем элементам массива $phones и получает его в виде массива, в который входят ключ и значение элемента.
each($phones)





#__clone #clone

$a= clone $b;

function __clone()
    {
        //все поля копируются сами, если надо копировать ссылочный тип то делаем так,((((this указывает на новый объект, наврятли так но хз как это работает)))))
        $this->object1 = clone $this->object1;
    }



альтернатива
 (expr1) ? (expr2) : (expr3) 


<?php if ($a == 5): ?>
A равно 5
<?php endif; ?>

if ($a == 5):
    echo "a равно 5";
    echo "...";
elseif ($a == 6):
    echo "a равно 6";
    echo "!!!";
else:
    echo "a не равно ни 5 ни 6";
endif;


while ($i <= 10):
    echo $i;
    $i++;
endwhile;

endfor;




#безопасность  #защита
#htmlentities
js html код введенный будет просто текстом отображаться
 $login=htmlentities($_POST['login'],ENT_QUOTES, 'UTF-8');

для кирилицы
htmlentities("Кириллица", ENT_QUOTES, 'UTF-8')
полностью уберет html теги    <div>123</div>  -> 123
$password = strip_tags($_POST['password']);


#безопасность #sql
//безопасное получание данных(фиксит html, sql,js)
$name = htmlentities(mysqli_real_escape_string($link, $_POST['name']),ENT_QUOTES, 'UTF-8');



передача данныйх   получение данных
#$_GET #$_POST  #_GET #_POST

$_GET $_POST
$_REQUEST['username']; тоже что и _post

<input type="checkbox" name="remember" checked="checked" />
$remember = $_GET['remember'];
Если флажок находится в неотмеченном состоянии то при отправке формы значение данного флажка не передается на сервер.
Если флажок отмечен, то при отправке на сервер для поля remember будет передано значение on
Если нас не устраивает значение on, то с помощью атрибута value мы можем установить нужное нам значение:
Запомнить: <input type="checkbox" name="remember" value="1" />


для передачи группы checkbox name=[]

<input type="checkbox" name="technologies[]" value="ASP.NET" />
<input type="checkbox" name="technologies[]" value="PHP" />
принимается как массив того что отмечено
$technologies = $_POST['technologies'];
foreach($technologies as $item) echo "$item<br />";


На сервер передается значение атрибута value у выбранного переключателя
<input type="radio" name="course" value="ASP.NET" />ASP.NET <br>
<input type="radio" name="course" value="PHP" />PHP <br>



список
<select name="course" size="1">
    <option value="ASP.NET">ASP.NET</option>
    <option value="PHP">PHP</option>
</select>

при множественном выборе на сервере получаем массив
<select name="courses[]" size="4" multiple="multiple">
    <option value="ASP.NET">ASP.NET</option>







работа со #строками #string #строка #строки
включаем доп функции
 Но прежде чем начать работу со строками, откроем файл php.ini и найдем в нем следующую строку:
Раскомментируем ее, убрав точку с запятой.// И так как у нас файл php.ini изменился, перезапустим веб-сервер Apache.

;extension=mbstring



#strpos
возвращает позицию подстроки(первое #вхождение) или символа $search в строке $str или значение false, если строка $str не содержит подстроки 
$position = strpos($str, $search);
надо сравнивать результат через $position===false, тк может вернуть 0 а 0 == false

strpos может плохо работать с кирилицей, что бы все норм работало надо юзать #mb_strpos()


#strrpos()
возвращает позицию подстроки(последнее #вхождение)
#mb_strrpos() кирилица



#trim()
Функция trim($str) удаляет(возвращает новую строку) из строки начальные и конечные пробелы, а также управляющие символы '\n', '\r', '\t':


#регистр
#strtolower()
в нижний регистр, возвращает строку
#mb_strtolower кирилица

верхний регистр
#strtoupper()
#mb_ strtoupper()


#strlen()
#mb_strlen()
длина строки


#substr 
вроде работает без mb_
возвращает обрезанную версию
2- позиция первого символа
6- длина(необязательно)
$subinput2 = substr($input, 2, 6);











#cookie
#куки

bool setcookie(string $name, string $value, int $expire, 
    string $path, string $domain, bool $secure, bool $httponly);

name: имя cookie, которое будет использоваться для доступа к его значению
value: значение или содержимое cookie - любой алфавитно-цифровой текст не более 4 кБайт
expire (необязательный параметр): срок действия, после которого cookie уничтожаются. Если данный параметр не установлен или равен 0, то уничтожение cookie происходит после закрытия браузера.
path (необязательный параметр): путь к каталогу на сервере, для которого будут доступны cookie. Если задать '/', cookie будут доступны для всего сайта. Если задать, например, '/mydir/', cookie будут доступны только из каталога /mydir/' и всех его подкаталогов. По умолчанию значением является текущий каталог, в котором устанавливаются cookie.
domain (необязательный параметр): задает домен, для которого будут доступны cookie. Если это домен второго уровня, например, localhost.com, то cookie доступны для всего сайта localhost.com, в том числе и для его поддоменов типа blog.localhost.com.
Если задан поддомен blog.localhost.com, то cookie доступны только внутри этого поддомена.
secure (необязательный параметр): указывает на то, что значение cookie должно передаваться по протоколу HTTPS. Если задано true, cookie от клиента будет передано на сервер, только если установлено защищенное соединение. По умолчанию равно false.
httponly (необязательный параметр): если равно true, cookie будут доступны только через http протокол. То есть cookie в этом случае не будут доступны скриптовым языкам, например, JavaScript. По умолчанию параметр равен false


setcookie("language", $value2, time()+3600);  // срок действия 1 час

получаем
$_COOKIE["city"]


сохраняем массив, получаем как обычно
setcookie("lan[1]", "PHP");
setcookie("lan[2]", "C#");

удаление(время из прошлого)
setcookie ("city", "", time() - 3600);





#сессии  #session

session_start();
$_SESSION['city'] = "Сингапур";
isset($_SESSION['city'])//проверяем, используем как обычно

при запуске сессии в куки сохраняет id,name сессии

// идентификатор сессии
session_id(); 
//напрямую(тоже самое)
$_COOKIE['PHPSESSID'];
// имя - PHPSESSID
echo session_name();  




Уничтожение сессии
$_SESSION = array();
// уничтожение куки с идентификатором сессии
if (session_id() != "" || isset($_COOKIE[session_name()]))
    setcookie(session_name(), '', time()-2592000, '/');
session_destroy();





работа с #файлами #file #файлы
#fopen

resource      fopen(string $filename, string $mode)
$filename представляет путь к файлу, $mode - режим открытия
'r': файл открывается только для чтения. Если файла не существует, возвращает false
'r+': файл открывается только для чтения с возможностью записи. Если файла не существует, возвращает false
'w': файл открывается для записи. Если такой файл уже существует, то он перезаписывается, если нет - то он создается
'w+': файл открывается для записи с возможностью чтения. Если такой файл уже существует, то он перезаписывается, если нет - то он создается
'a': файл открывается для записи. Если такой файл уже существует, то данные записываются в конец файла, а старые данные остаются. Если файл не существует, то он создается
'a+': файл открывается для чтения и записи. Если файл уже существует, то данные дозаписываются в конец файла. Если файла нет, то он создается

$fd = fopen("form.php", 'r') or die("не удалось открыть файл");
fclose($fd);

считываем построчно

while(!feof($fd))//вернет true в конце файла
{
    $str = htmlentities(fgets($fd),ENT_QUOTES, 'UTF-8');//считывает 1 строку
//$str = htmlentities(fread($fd, 600),ENT_QUOTES, 'UTF-8');  // считываем 600 байт
    echo $str;
}


полностью прочитать файл(просто 1 строка, без открытия\закрытия и тд)

$str = htmlentities(file_get_contents("form.php"), ENT_QUOTES, 'UTF-8');



запись в файл
$fd = fopen("hello.txt", 'w') or die("не удалось создать файл");
$str = "Привет мир";
fwrite($fd, $str);
//fputs($fd, $str);//тоже самое что и fwrite
fclose($fd);



Работа с указателем файла

int fseek (resource $handle , int $offset [, int $whence = SEEK_SET ] )
Параметр $handle представляет дескриптор файла. Параметр $offset - смещение в байтах относительно начала файла, с которого начнется считывание/запись. Третий необязательный параметр задает способ установки смещения. Он может принимать три значения:
SEEK_SET: значение по умолчанию, устанавливает смещение в offset байт относительно начала файла
SEEK_CUR: устанавливает смещение в offset байт относительно начала текущей позиции в файле
SEEK_END: устанавливает смещение в offset байт от конца файла

В случае удачной установки указателя функция fseek() возвращает 0, а при неудачной установке возвращает -1.

$fd = fopen("hello.txt", 'w+') or die("не удалось открыть файл");
$str = "Привет мир!"; // строка для записи
fwrite($fd, $str); // запишем строку в начало
fseek($fd, 0); // поместим указатель файла в начало
fwrite($fd, "Хрю"); // запишем в начало строку




переместить файл

if (!rename("hello.txt", "subdir/hello.txt"))//перемещение в каталог
    echo "Ошибка перемещения файла";


копирование файла
if (copy("hello.txt", "hello_copy.txt"))
    echo "Копия файла создана";


Удаление файла
if (unlink("hello_copy.txt"))
    echo "Файл удален";

очистка файла
ftruncate($fd, 0);


Создание каталога

if(mkdir("newdir"))//в текущем каталоге, в корневом mkdir("/newdir")
    echo "Каталог создан";

Удаление каталога
if(rmdir("newdir"))
    echo "Каталог удален";


получения абсолютного пути к текущему каталогу
$path = getcwd();// C:\localhost



открывает определенный каталог для считывания из него информации о файлах и каталогах
При успешном открытии каталога функция возвращает дескриптор открытого каталога. После окончания работы с каталогом его надо закрыть функцией closedir().

Для считывания имени отдельного файла в открытом каталоге применяется функция readdir().

$dir = getcwd(); // получаем текущий каталог
 
if (is_dir($dir)) // является ли путь каталогом
{
    if ($dh = opendir($dir)) // открываем каталог
    {
        // считываем по одному файл или подкаталогу
        // пока не дойдем до конца
        while (($file = readdir($dh)) !== false) 
        {
            // пропускаем символы .. и .
            if($file=='.' || $file=='..') continue;
            // если каталог или файл
            if(is_dir($file)) echo "каталог: $file <br>";
            else echo "файл:    $file <br>";
        }
        closedir($dh); // закрываем каталог
    }
}



формирование очереди для работы с файлом

bool flock (resource $handle , int $operation [, int &$wouldblock ])
Первый параметр - дескриптор файла, возвращаемые функцией fopen().

Второй параметр указывает на тип блокировки. Он может принимать следующие значения:

LOCK_SH (или число 1): разделяемая блокировка (чтение файла)

LOCK_EX (или число 2): исключительная блокировка (запись файла)

LOCK_UN (или число 3): для снятия блокировки

LOCK_NB (или число 4): эта константа используется только вместе с одной из предыдущих в битовой маске (LOCK_EX | LOCK_NB), если не надо ждать пока flock() получит блокировку

//при блокировке, даже если надо делать запись, не рекомендуется использование 'w' и 'w+'
$fd = fopen("hello.txt", 'r+')
flock($fd, LOCK_EX)
...
flock($fd, LOCK_UN);
fclose($fd);





ОТПРАВКА файлов на сервер

изначальное ограничение 2 мегабайта, что бы изменить надо
//  в файле php.ini менять upload_max_filesize = 2M
//папка для временных файлов upload_tmp_dir = "C:/php/upload"



<form method="post" enctype='multipart/form-data'>
Выберите файл: <input type='file' name='filename' size='10' /><br /><br />

//несколько файлов в 1 форме
<input type='file' name='uploads[]' /><br />
<input type='file' name='uploads[]' /><br />



if ($_FILES && $_FILES['filename']['error']== UPLOAD_ERR_OK)//файл существует и ошибок нет
{
    $name = $_FILES['filename']['name'];
//из временного места перемещатся в каталог// путь к загруженному временному фуйлу и путь куда надо поместить файл
    move_uploaded_file($_FILES['filename']['tmp_name'], $name);
    echo "Файл загружен";
}

$_FILES['file']['name']: имя файла

$_FILES['file']['type']: тип содержимого файла, например, image/jpeg

$_FILES['file']['size']: размер файла в байтах

$_FILES['file']['tmp_name']: имя временного файла, сохраненного на сервере

$_FILES['file']['error']: код ошибки при загрузке


обработка нескольких файлов

foreach ($_FILES["uploads"]["error"] as $key => $error) {
        if ($error == UPLOAD_ERR_OK) {
            $tmp_name = $_FILES["uploads"]["tmp_name"][$key];
            $name = $_FILES["uploads"]["name"][$key];
            move_uploaded_file($tmp_name, "$name");
        }
    }













#include #require #подключение




//   ../  ищет файл в текущей директории
require//тоже самое что и include но при внутренней ошибке завершит выполнение а не просто предупреждение
include
если файл включался то не включится еще раз, если включить(через обычный include) 2 +раза то будет ошибка
require_once
include_once

подключение файла, область видимости подключаемого кода как у строки который подключает
include 'vars.php';

// Сработает.
include 'http://www.example.com/file.php?foo=1&bar=2';
//нужно без скобок,строка ниже правильная
if ((include 'vars.php') == TRUE)



этот кусок будет подключать файлы сам при обращении
просто в началей файла написать и путь подредактировать
spl_autoload_register(function ($class_name) {
//if (file_exists($className . '.php'))
    include $class_name . '.php';
});
вызовет функцию выше , она подключит класс(одноименный файл) и все будет работать
$obj  = new MyClass1();






return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // выведет 'PHP'

$bar = include 'noreturn.php';

echo $bar; // выведет 1 тк подключено успешно



goto

goto a;
echo 'Foo';
 
a:
echo 'Bar';







#обработка #ошибки
#try #catch #finaly
#Exception
throw new Exception("Невозможно загрузить $name.");

try {
    var_dump(sum(1, 2));
    var_dump(sum(1.5, 2.5));
} catch (TypeError $e) {
    echo 'Ошибка: '.$e->getMessage();
}



аналог params
для старых версий func_num_args(), func_get_arg() и func_get_args().
DateInterval- тип данных элеметов массива ...-- массив
function total_intervals($unit, DateInterval ...$intervals) {





a = 1;
$b =& $a;
$c = $b;
$c = 7; //$c не ссылка и не изменяет значений $a и $b
arr = array(1);
$a =& $arr[0]; //$a и $arr[0] ссылаются на одно значение
$arr2 = $arr; //присвоение не по ссылке!
$arr2[0]++;
/* $a == 2, $arr == array(2) */
/* Содержимое $arr изменилось, хотя было присвоено не по ссылке! */


var начинает ссылаться на другое значение а bar нет
function foo(&$var)
{
    $var =& $GLOBALS["baz"];
}
foo($bar); 


//b все еще указывает
$a = 1;
$b =& $a;
unset($a);













#Трейты  #trait #use


Наследуемый член из базового класса переопределяется членом, находящимся в трейте. 
Порядок приоритета следующий: члены из текущего класса переопределяют методы в трейте, 
которые в свою очередь переопределяют унаследованные методы.
можно use трейт в трейте

class Base {
    public function sayHello() {
        echo 'Hello ';
    }
}

trait SayWorld1 {
    public function sayHello() {
        parent::sayHello();
        echo 'World!';
echo 'Hello'.$this->getWorld();
    }
//абстрактный метод для установления требований
abstract public function getWorld();

//статический метод, вызывается как обычный статический метод
 public static function doSomething() {
        return 'Что-либо делаем';
    }

//обычное свойство, используется как и обычное
Если трейт определяет свойство, то класс не может определить свойство с 
таким же именем, кроме случаев полного совпадения (те же начальное значение и модификатор видимости)
public $x = 1;


}

class MyHelloWorld extends Base {
    use SayWorld1,...2,...3;

//реализуем абстрактный метод тк он был задан в трейте
public function getWorld() {
        return $this->world;
    }
}

$o = new MyHelloWorld();
$o->sayHello();



Для разрешения конфликтов именования между трейтами, используемыми в одном и том же классе, необходимо использовать оператор insteadof для того, чтобы точно выбрать один из конфликтующих методов.

use A, B {
        B::smallTalk insteadof A;//разрешение конфликтов
        A::bigTalk insteadof B;//разрешение конфликтов
        B::bigTalk as talk;//просто устанвливаем псевданим?
}
//меняем область видимости
use HelloWorld { sayHello as protected; }
//и то и то
use HelloWorld { sayHello as private myPrivateHello; }




















#SQL IN #PHP



//для локального сервера
$host = 'localhost'; // адрес сервера 
$database = 'compstore'; // имя базы данных
$user = 'root'; // имя пользователя
$password = '1234567'; // пароль


$link = mysqli_connect($host, $user, $password, $database) 
    or die("Ошибка " . mysqli_error($link));
// выполняем операции с базой данных

// закрываем подключение
mysqli_close($link);

//безопасное получание данных
htmlentities("Кириллица", ENT_QUOTES, 'UTF-8')
$name = htmlentities(mysqli_real_escape_string($link, $_POST['name']),ENT_QUOTES, 'UTF-8');


//получаем id последней вставленной записи
$obj->id=mysqli_insert_id();

     




$query ="SELECT * FROM phones";
$result = mysqli_query($link, $query) or die("Ошибка " . mysqli_error($link)); 
//Функция mysqli_query() возвращает объект $result, который содержит результат запроса. В случае неудачи данный объект содержит значение false.
if($result)
    echo "Выполнение запроса прошло успешно";
//для нормальной обраточки результата(в виде массива с столбцами ключами) ниже еще есть пример построчно
$data=mysqli_fetch_all($result,1);


обрабатываем результат
 $rows = mysqli_num_rows($result); // количество полученных строк при select

 for ($i = 0 ; $i < $rows ; ++$i)//идем по каждой строке результата
    {
//считываем одну строку, массив полей, доступ как к обычному массиву int, возвращается массив даже в случае выборки 1 поля
        $row = mysqli_fetch_row($result);
        echo "<tr>";

//получаем по порядку ячейки строки(поля)
            for ($j = 0 ; $j < 3 ; ++$j) echo "<td>$row[$j]</td>";
        echo "</tr>";
    }




#php #sql    #sql #php


русские буквы
mysql_query("SET NAMES utf8 COLLATE utf8_unicode_ci");

$connect=mysqli_connect("localhost","root","","bd_inter_v");
$result=mysqli_query($connect,$sql_code_string);
//преобразуем ответ в массив с доступом по [0] [1] 
$data=mysqli_fetch_all($result);
//преобразуем в массив с доступом по ["column_name"]
$data=mysqli_fetch_all($result,1);



$result = $pdo->query("SELECT id, name, salary FROM employees");
while (list($id, $name, $salary) = $result->fetch(PDO::FETCH_NUM)) {
    echo " <tr>\n" .
          "  <td><a href=\"info.php?id=$id\">$name</a></td>\n" .




function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();











#namespace

// перед namespace ничего(ни <html> ни что либо другое) не может быть кроме declare
PHP-код не может находиться вне скобок конструкции пространства имен, кроме начального выражения declare.
<?php
namespace MyProject;
namespace MyProject\Sub\Level;//определяем вложенность(подуровни)
для определения нескольких в 1 файле
namespace MyProject{код}

namespace {  //глобальное пространство имен



использования из namespace
$a = new foo();//текущее 
$a = new subnamespace\foo(); // ищет namespace с текущем и обращается через него
$a = new \currentnamespace\foo();   //обсолютный путь
???
namespace\Foo\Bar

вызвать функцию из namespace
namespace\func();

//use должно быть в namespace, не может быть в функции и тд
создание псевдонима, вызывается через mine
use blah\blah as mine;

use function My\Full\functionName,...,...,...;


групировака и подключение
use some\namespace\{ClassA, ClassB, ClassC as C};
use function some\namespace\{fn_a, fn_b, fn_c};
use const some\namespace\{ConstA, ConstB, ConstC};

#__NAMESPACE__
это строка, которая содержит имя текущего пространства имен. В глобальном пространстве, вне пространства имен, она содержит пустую строку.



для понимания

namespace A\B\C;

/* Эта функция является A\B\C\fopen */
function fopen() { 
     /* ... */
     $f = \fopen(...); // вызов глобальной функции fopen
     return $f;
} 





#catch

главный класс Exception
trow new Exception("");

обработка нескольких
try {
            throw new MyException();
        } catch (MyException | MyOtherException $e) {
            var_dump(get_class($e));
        }








#генераторы #yield





function gen_one_to_three() {
    for ($i = 1; $i <= 3; $i++) {
        // Обратите внимание, что $i сохраняет свое значение между вызовами.
//ключ значение
// yield $id => $fields;
        yield $i;
//yield; возвращаем null но как результат(тип массив с элементами null который можно перебирать)
//yield from [3, 4];  аналогично 2м , сначала 3 и следом 4
//yield from eight();   //в функции тоже yield ы 
    }
}

$generator = gen_one_to_three();
foreach ($generator as $value)
//value === 1,2,3

можно возвращать ссылку также как и с функцией, изменив переменную возвращенную из такой! функции она изменится в функции





#float
функции для работы
http://php.net/manual/ru/ref.bc.php

#round
округляет по правилам округления, оставляет указанное количество знаков после запятой
round($num,$after);








min\max
находит число в массиве(можно передать просто параметрами)


#denwer #denver
создать папку Z:\home в ней папку www в нее файлы
рестартнуть денвер

http://localhost/denwer/





//------------------------------------------------------------------------полезные куски кода-------------------------------

#check_id #id #GetUserId

public static string GetUserId()
        {
            return System.Web.HttpContext.Current.User.Identity.GetUserId();
        }

        public static ApplicationUser GetUser(string id)
        {
            //string check_id = ApplicationUser.GetUserId();
            ApplicationUser res = null;
            //if (string.IsNullOrWhiteSpace(id))
            //    return res;
            using (ApplicationDbContext db = new ApplicationDbContext())
            {
                res = ApplicationUser.GetUser(id,db);
            }
                
            return res;
        }
public static ApplicationUser GetUser(string id, ApplicationDbContext db)
        {
            //string check_id = ApplicationUser.GetUserId();
            ApplicationUser res = null;
            if (string.IsNullOrWhiteSpace(id))
                return res;
            res = db.Users.FirstOrDefault(x1 => x1.Id == id);

            return res;
        }






#main #header #main_header #mainheader  #preloader #up

<div id="Main_preloader_id" class="Main_preloader div_display_none"></div>
<div class="Main_header_big"> </div>
<div id="Main_header_check_small_or_big_header">
</div>
<div class="Main_header_small" id="Main_header_small_id">
</div>


layout
@Html.Action("Main_header", "Home")
        <div id="layout_active_panel_id" class="layout_active_panel"></div>
        <div onclick="up()" class="Main_header_back_to_top" id="Main_header_back_to_top_id"></div>





css
div.Main_header_big {
    position: relative;
    background-color: white;
    height: 500px;
    width: 96%;
    left: 2%;
    background-image: url(/Content/images/main_header_back_big.jpg);
    background-size: 100% 100%;
     box-shadow: 0 0 10px rgba(0,0,0,0.5);
}
div.Main_header_small {
    position: fixed;
    height: 50px;
    width: 100%;
    display: none;
    top: 0px;
    /*background-color: #cdfae0;*/
    background-image: url(/Content/images/main_header_back_big.jpg);
    min-width:960px;
    z-index: 5;
}


div.Main_preloader{
    position:fixed;
    width:100px;
    height:100px;
    left:48%;
    top:50px;
    background-image: url(/Content/images/preloader_cat.gif);
    background-size: 100% 100%;
    z-index:5;
}



/*JS*/

function up() {
    var top = Math.max(document.body.scrollTop, document.documentElement.scrollTop);
    if (top > 0) {
        window.scrollBy(0, -100);
        time_for_page_up = setTimeout('up()', 20);
    } else clearTimeout(time_for_page_up);
    return false;
}

function isVisible(tag) {
    var t = $(tag);
    var w = $(window);
    var top_window = w.scrollTop();
    var bot_window=top_window+document.documentElement.clientHeight;
    var top_tag = t.offset().top;
    var bot_tag = top_tag + t.height();
    //alert(bot_tag);
    //alert(top_window);
    return ((bot_tag >= top_window && bot_tag <= bot_window) || (top_tag >= top_window && top_tag <= bot_window) || (bot_tag >= bot_window && top_tag <= top_window));
}
$(function () {
    $(window).scroll(function () {
        Change_main_header();
        
    });
});


function Change_main_header() {
    var b = $("#Main_header_check_small_or_big_header");
    if (!b.prop("shown") && !isVisible(b)) {
        b.prop("shown", true);
        var o = document.getElementById("Main_header_small_id")
        var o1 = document.getElementById("Main_header_back_to_top_id")
        o1.style.display = 'block';

        o.style.display = 'block';

    }
    else {
        if (b.prop("shown") && isVisible(b)) {
            b.prop("shown", false);
            var o = document.getElementById("Main_header_small_id")
            var o1 = document.getElementById("Main_header_back_to_top_id")
            o1.style.display = 'none';
            o.style.display = 'none';
        }
    }

}












#плитка



<div class="padding_10_top create_something_one_block div_inline_block">
    <div class="create_something_one_block_inside">
        <a class="link_standart_for_div" href="@Url.Action("ListUserAct","ListPhysics", new { })">


            @*@Html.ActionLink("Личная страница", "PersonalRecord", "SocialNetwork", new { }, new { })*@
            Работа с списками и пользователями

            <div class="create_something_one_block_move">
                Страница для добавления\удаления отношения список-пользователь, физ эффект-пользователь

            </div>

        </a>
    </div>
</div>


.padding_10_top{
    padding-top:10px;
}
div.create_something_one_block{
    width:200px;
}
div.div_inline_block {
    display: inline-block;
    vertical-align: top;
}
div.create_something_one_block_inside{
    height:200px;
    -webkit-box-shadow: 0 0 10px rgba(0,0,0,0.5);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
    border-radius:20px;
    text-align:center;
cursor:pointer;
overflow:hidden;
position:relative;
}

.link_standart_for_div {
    display: block; /* Ссылка как блочный элемент */
    text-align: center; /* Выравнивание по центру */
    height: 100%; /* Высота на весь слой */
    color: black; /* Цвет ссылки */
    
}
div.create_something_one_block_inside:hover div.create_something_one_block_move{
    top:0;
}
div.create_something_one_block_move{
    /*border:solid 2px black;*/
position:absolute;
background-color:rgb(128, 128, 128);
opacity:1;
width:200px;
height:200px;
top:200px;
-webkit-transition:1s;
-o-transition:1s;
transition:1s;
color:white;

}










---------------------------------------------------------------этот блок где просто накидана найс инфа, без нормального поиска он почти бесполезен------------------------------------------------------------------------
#sql #error
при коннекте слева в дб  выдае ошибку
This database file is not compatible with the current instance of SQL Server.

To resolve this issue, you must upgrade the database file by creating a new data connection, or you must modify the existing connection to this database file.

For more information, see http://go.microsoft.com/fwlink/?LinkId=235986


решение 
go to VisualStadio 2012 In Server Explorer Windows open Data Connections Right click on ASPNETDB.MDF click on Modify Connection... a new windows open for you ... you just click OK if other windows open for you click Yes FINISH ( be Happy ) :D


#error
При установлении соединения с SQL Server произошла ошибка, связанная с сетью или с определенным экземпляром. Сервер не найден или недоступен. Убедитесь, что имя экземпляра указано правильно и что на SQL Server разрешены удаленные соединения. (provider: SQL Network Interfaces, error: 26 - Ошибка при обнаружении указанного сервера или экземпляра)
нужно включить именно тот к которому идет коннект
решение по тегам #SQL #server  ->запустить службу
+ включить сам сервер в папке сервера, инфа по темже тегам








при #seed добавление ролей add to role UserId not found
Это может включать в себя следующее:
Политика паролей не соблюдается (это наиболее распространенная причина)
Обязательные поля передаются как пустые строки / null
Дубликат имени пользователя или электронной почты
если нет то попробовать отладить метод create






































--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

















































