#CLR/#CTS - это всечто может clr-100% функционала
языки которые построены на clr используют только часть функционала, и каждый разную часть
#CLS - это функционал(часть clr)(тимы методы и тд) которые обязан реализовывать язык из clr

using System;

// Приказываем компилятору проверять код
// на совместимость с CLS
[assembly: CLSCompliant(true)]

namespace SomeLibrary { 

псевдонимы типов(например long) на самом деле в fcl называются system.Int64 и тд, не все типы поддерживаются fcl
стр 143 clr via c#







сборка с отложенным подписанием - стр 108 clr via c#

сборка с строгим именем TODO



Оператор #new выполняет следующие действия
1. Вычисление количества байтов, необходимых для хранения всех экземплярных полей типа и всех его базовых типов, включая System.Object (в котором
отсутствуют собственные экземплярные поля). Кроме того, в каждом объекте
кучи должны присутствовать дополнительные члены, называемые указателем
на объект-тип (type object pointer) и индексом блока синхронизации (sync block
index); они необходимы CLR для управления объектом. Байты этих дополнительных членов добавляются к байтам, необходимым для размещения самого
объекта.
2. Выделение памяти для объекта с резервированием необходимого для данного
типа количества байтов в управляемой куче. Выделенные байты инициализируются нулями (0).
3. Инициализация указателя на объект-тип и индекса блока синхронизации.
4. Вызов конструктора экземпляра типа с параметрами, указанными при вызове
new (в предыдущем примере это строка ConstructorParam1). Большинство
компиляторов автоматически включает в конструктор код вызова конструктора
базового класса. Каждый конструктор выполняет инициализацию определенных
в соответствующем типе полей. В частности, вызывается конструктор System.
Object, но он ничего не делает и просто возвращает управление.
Выполнив все эти операции, new возвращает ссылку (или указатель) на вновь
созданный объект. В предыдущем примере кода эта ссылка сохраняется в переменной e типа Employee.





#struct #ValueType
Все структуры являются прямыми потомками абстрактного типа System.
ValueType, который, в свою очередь, является производным от типа System.
Object. По умолчанию все значимые типы должны быть производными от System.
ValueType. Все перечисления являются производными от типа System.Enum, производного от System.ValueType.

При определении собственного значимого типа нельзя выбрать произвольный
базовый тип, однако значимый тип может реализовать один или несколько выбранных вами интерфейсов. Кроме того, в CLR значимый тип является изолированным,
то есть он не может служить базовым типом для какого-либо другого ссылочного
или значимого типа. 

System.ValueType переопределяет
метод Equals, который возвращает true, если значения полей в обоих объектах
совпадают. Кроме того, в System.ValueType переопределен метод GetHashCode,
который создает хеш-код по алгоритму, учитывающему значения полей экземпляра объекта. Из-за проблем с производительностью в реализации по умолчанию(рефлексия), определяя собственные значимые типы значений, надо переопределить
и написать свою реализацию методов Equals == и GetHashCode
см #equals



можно изменить порядок полей объекта(то как будут храниться)
System.Runtime.InteropServices.StructLayoutAttribute.
Чтобы порядок полей устанавливался CLR, нужно передать конструктору атрибута параметр LayoutKind.Auto, чтобы сохранить установленный программистом порядок — параметр LayoutKind.Sequential, а параметр LayoutKind.
Explicit позволяет разместить поля в памяти, явно задав смещения. Если в описании типа не применен атрибут StructLayoutAttribute, порядок полей выберет
компилятор

Для ссылочных типов (классов) компилятор C# выбирает вариант LayoutKind.
Auto, а для значимых типов (структур) — LayoutKind.Sequential
// Для повышения производительности разрешим CLR
// установить порядок полей для этого типа
[StructLayout(LayoutKind.Auto)]
internal struct SomeValType {
 private readonly Byte m_b; 






#упаковка
При упаковке экземпляра значимого типа происходит следующее.
1. В управляемой куче выделяется память. Ее объем определяется длиной значимого типа и двумя дополнительными членами — указателем на типовой объект
и индексом блока синхронизации. Эти члены необходимы для всех объектов
в управляемой куче.
2. Поля значимого типа копируются в память, только что выделенную в куче.
3. Возвращается адрес объекта. Этот адрес является ссылкой на объект, то есть
значимый тип превращается в ссылочный.


#распаковка
При распаковке упакованного значимого типа происходит следующее.
1. Если переменная, содержащая ссылку на упакованный значимый тип, равна
null, генерируется исключение NullReferenceException.
2. Если ссылка указывает на объект, не являющийся упакованным значением
требуемого значимого типа, генерируется исключение InvalidCastException
нельзя распаковать int32 в int16, но можно сначала распаковать а потом явно привести тип





//TODO это надо записать короче - страница 168
Хотя неупакованные значимые типы не имеют указателя на типовой объект, вы
все равно можете вызывать виртуальные методы (такие, как Equals, GetHashCode
или ToString), унаследованные или прееопределенные этим типом. Если ваш значимый тип переопределяет один из этих виртуальных методов, CLR может вызвать
метод невиртуально, потому что значимые типы неявно запечатываются и поэтому
не могут выступать базовыми классами других типов. Кроме того, экземпляр значимого типа, используемый для вызова виртуального метода, не упаковывается.
Но если ваше переопределение виртуального метода вызывает реализацию этого
метода из базового типа, экземпляр значимого типа упаковывается при вызове
реализации базового типа, чтобы в указателе this базового метода передавалась
ссылка на объект в куче.
Вместе с тем вызов невиртуального унаследованного метода (такого, как GetType
или MemberwiseClone) всегда требует упаковки значимого типа, так как эти методы
определены в System.Object, поэтому методы ожидают, что в аргументе this передается указатель на объект в куче.
Кроме того, приведение неупакованного экземпляра значимого типа к одному
из интерфейсов этого типа требует, чтобы экземпляр был упакован, так как интерфейсные переменные всегда должны содержать ссылку на объект в куче. 


internal struct Point : IComparable {
 private Int32 m_x, m_y;
 // Конструктор, просто инициализирующий поля
 public Point(Int32 x, Int32 y) {
 m_x = x;
 m_y = y;
 }
 // Переопределяем метод ToString, унаследованный от System.ValueType
 public override String ToString() {
 // Возвращаем Point как строку (вызов ToString предотвращает упаковку)
 return String.Format("({0}, {1})", m_x.ToString(), m_y.ToString());
 }
 // Безопасная в отношении типов реализация метода CompareTo
 public Int32 CompareTo(Point other) {
 // Используем теорему Пифагора для определения точки,
 // наиболее удаленной от начала координат (0, 0)
 return Math.Sign(Math.Sqrt(m_x * m_x + m_y * m_y)
 - Math.Sqrt(other.m_x * other.m_x + other.m_y * other.m_y));
 }
 // Реализация метода CompareTo интерфейса IComparable
 public Int32 CompareTo(Object o) {
 if (GetType() != o.GetType()) { 
throw new ArgumentException("o is not a Point");
 }
 // Вызов безопасного в отношении типов метода CompareTo
 return CompareTo((Point) o);
 }
}
public static class Program {
 public static void Main() {
 // Создаем в стеке два экземпляра Point
 Point p1 = new Point(10, 10);
 Point p2 = new Point(20, 20);
 // p1 НЕ пакуется для вызова ToString (виртуальный метод)
 Console.WriteLine(p1.ToString()); // "(10, 10)"
 // p1 ПАКУЕТСЯ для вызова GetType (невиртуальный метод)
 Console.WriteLine(p1.GetType()); // "Point"
 // p1 НЕ пакуется для вызова CompareTo
 // p2 НЕ пакуется, потому что вызван CompareTo(Point)
 Console.WriteLine(p1.CompareTo(p2)); // "-1"
 // p1 пакуется, а ссылка размещается в c
 IComparable c = p1;
 Console.WriteLine(c.GetType()); // "Point"
 // p1 НЕ пакуется для вызова CompareTo
 // Поскольку в CompareTo не передается переменная Point,
 // вызывается CompareTo(Object), которому нужна ссылка
 // на упакованный Point
 // c НЕ пакуется, потому что уже ссылается на упакованный Point
 Console.WriteLine(p1.CompareTo(c)); // "0"
 // c НЕ пакуется, потому что уже ссылается на упакованный Point
 // p2 ПАКУЕТСЯ, потому что вызывается CompareTo(Object)
 Console.WriteLine(c.CompareTo(p2));// "-1"
 // c пакуется, а поля копируются в p2
 p2 = (Point) c;
 // Убеждаемся, что поля скопированы в p2
 Console.WriteLine(p2.ToString());// "(10, 10)"


// p упаковывается, упакованный объект изменяется и освобождается
 ((IChangeBoxedPoint) p).Change(4, 4);
 Console.WriteLine(p);
 // Упакованный объект изменяется и выводится
 ((IChangeBoxedPoint) o).Change(5, 5);
 Console.WriteLine(o); 

 }
}


Вызов ToString
При вызове ToString упаковка p1 не требуется
 метод ToString переопределен в Point

Вызов GetType. При вызове невиртуального метода GetType упаковка p1 необходима, поскольку тип Point не реализует GetType, а наследует его от System.
Object

Первый вызов CompareTo. При первом вызове CompareTo упаковка p1 не нужна,
так как Point реализует метод CompareTo, и компилятор может просто вызвать его
напрямую. 

Приведение типа к IComparable. Когда выполняется приведение типа p1 к переменной интерфейсного типа (с), упаковка p1 необходима

Второй вызов CompareTo. При втором вызове CompareTo упаковка p1 не производится, потому что Point реализует метод CompareTo, и компилятор может
вызывать его напрямую.

Третий вызов CompareTo. При третьем вызове CompareTo переменная c уже
ссылается на упакованный объект Point в куче. Поскольку переменная c сама
по себе имеет интерфейсный тип IComparable, можно вызывать только метод
CompareTo интерфейса, а ему требуется параметр Object


Приведение типа к Point. Когда выполняется приведение c к типу Point, объект в куче, на который указывает c, распаковывается, и ег







#== #equals 
что бы проверить равенство ссылок надо юзать #ReferenceEquals
не нужно использовать == тк мы не можем точно знать перегружен ли этот оператор на сравнение по значению


при создании значимого типа надо обязательно перегрузить == Equals
тк по дефолту используется отражение и это медленно
Определяя собственный тип и приняв решение переопределить Equals, обеспечьте поддержку четырех характеристик, присущих равенству
-Рефлексивность: x.Equals(x) должно возвращать true.
-Симметричность: x.Equals(y) и y.Equals(x) должны возвращать одно и то же значение
-Транзитивность: если x.Equals(y) возвращает true и y.Equals(z) возвращает
true, то x.Equals(z) также должно возвращать true.
-Постоянство: если в двух сравниваемых значениях не произошло изменений,
результат сравнения тоже не должен измениться.
Отступление от этих правил при создании собственной реализации Equals
грозит непредсказуемым поведением приложения.
При переопределении метода Equals может потребоваться выполнить несколько
дополнительных операций.
-Реализовать в типе метод Equals интерфейса System.IEquatable<T>. Этот
обобщенный интерфейс позволяет определить безопасный в отношении типов
метод Equals. Обычно Equals реализуют так, что, принимая параметр типа
Object, код метода вызывает безопасный в отношении типов метод Equals.
-Перегрузить методы операторов == и !=. Обычно код реализации этих операторных методов вызывает безопасный в отношении типов метод Equals.



#TODO не особо понимаю что это 
Ранее я уже говорил о том, что компилятор C# на этапе выполнения программы генерирует код полезной нагрузки, основываясь на действительных
типах объекта. Этот код полезной нагрузки использует класс, известный как
компоновщик (runtime binder). Различные языки программирования определяют собственных компоновщиков, инкапсулируя в них правила языка





#dynamic
можно "засунуть" в dynamic статику(вызов статических членов типа)
это не из коробки работает, можно написать -clr via c# стр 183







#const
Константы всегда связаны с типом,
а не с экземпляром типа, а на логическом уровне константы всегда являются
статическими членами

Константа (constant) — это идентификатор, значение которого никогда не меняется. Значение, связанное с именем константы, должно определяться во время
компиляции. Затем компилятор сохраняет значение константы в метаданных
модуля. Это значит, что константы можно определять только для таких типов,
которые компилятор считает примитивными. В C# следующие типы считаются
примитивными и могут использоваться для определения констант: Boolean, Char,
Byte, SByte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Decimal
и String.
можно объявить ссылочную константу если присвоить ей null


константы встраиваются сразу в il код(нет ссылок на саму константу, встраивается значение)
если констнта в другой сборке и константа изменена то надо перекомпилировать все сборки которые на нее ссылаются

что бы всего избежать этого можно юзать readonly




дружественная #сборка
В процессе создания сборки можно указать другие сборки, которые она будет
считать «друзьями», — для этого служит атрибут InternalsVisibleTo, определенный в пространстве имен System.Runtime.CompilerServices. У атрибута есть
строковый параметр, определяющий имя дружественной сборки и ее открытый ключ
(передаваемая атрибуту строка не должна содержать информацию о версии, региональных стандартах или архитектуре процессора). Заметьте, что дружественные
сборки получают доступ ко всем внутренним типам сборки, а также к внутренним
членам этих типов. 

// Внутренние типы этой сборки доступны из кода двух следующих сборок
// (независимо от версии или региональных стандартов)
[assembly:InternalsVisibleTo("Wintellect, PublicKey=12345678...90abcdef")]
[assembly:InternalsVisibleTo("Microsoft, PublicKey=b77a5c56...1934e089")]
internal sealed class SomeInternalType { ... }
internal sealed class AnotherInternalType { ... }



CLR 
C# 
Описание

-Private (закрытый) 
private 
Доступен только методам в определяющем типе и вложенных в него типах
-Family (родовой) 
protected 
Доступен только методам в определяющем типе
(и вложенных в него типах) или в одном из его производных типов независимо от сборки
-Family and Assembly (родовой и сборочный)
(не поддерживается)
Доступен только методам в определяющем типе (и вложенных в него типах) и производных типах в определяющей сборке
-Assembly (сборочный)
internal 
Доступен только методам в определяющейсборке
Assembly or Family(сборочный илиродовой)
protected internal
Доступен только методам вложенного типа, производного типа (независимо от сборки) и любым методам определяющей сборки Public (открытый) public Доступен всем методам во всех сборках


Если в производном типе переопределяется член базового типа, компилятор C#
требует, чтобы у членов базового и производного типов были одинаковые модификаторы доступа. То есть если член базового класса является защищенным, то и член
производного класса должен быть защищенным. Однако это ограничение языка C#,
а не CLR. При наследовании от базового класса CLR позволяет снижать, но не повышать ограничения доступа к члену. Например, защищенный метод базового класса
можно переопределить в производном классе в открытый, но не в закрытый. Дело
в том, что пользователь производного класса всегда может получить доступ к методу
базового класса путем приведения к базовому типу. Если бы среда CLR разрешала
устанавливать более жесткие ограничения на доступ к методу в производном типе,
то эти ограничения бы элементарно обходились







#il #ildasm.exe








при перегрузке методов
в il можно определить 2 одинаковых метода которые будут различаться только return типом
такая возможность блокируется языками программирования




методы могут компилироваться в разные команды il
call
callvirt - для виртуального метода, работает медленнее
не любой виртуальный метод вызывается через callvirt
например если перегружается метод ToString и вызывает в себе base.ToString()
то такой метод вызывается как call тк при вызове base.ToString должен вызываться тот же метод в котором уже сейчас выполняется код
(вызывается как бы родительский метод, но из за виртуальности вызовется дочерний)

Компиляторы стремятся использовать команду call при вызове методов, определенных значимыми типами, поскольку они запечатаны. В этом случае полиморфизм
невозможен даже для виртуальных методов, и вызов выполняется быстрее. Кроме
того, сама природа экземпляра значимого типа гарантирует, что он никогда не будет
равен null, поэтому исключение NullReferenceException не возникнет. Наконец,
для виртуального вызова виртуального метода значимого типа CLR необходимо
получить ссылку на объект значимого типа, чтобы воспользоваться его таблицей
методов, а это требует упаковки значимого типа






#abstract #constructor

Для абстрактных классов компилятор создает конструктор по умолчанию с модификатором protected, в противном случае область действия будет открытой
(public). Если в базовом классе нет конструктора без параметров, производный
класс должен явно вызвать конструктор базового класса, иначе компилятор вернет
ошибку. Для статических классов (запечатанных и абстрактных) компилятор не
создает конструктор по умолчанию

В редких ситуациях экземпляр типа может создаваться без вызова конструктора экземпляров. В частности, метод MemberwiseClone объекта Object выделяет
память, инициализирует служебные поля объекта, а затем копирует байты исходного объекта в область памяти, выделенную для нового объекта. Кроме того,
конструктор обычно не вызывается при десериализации объекта. Код десериализации выделяет память для объекта без вызова конструктора, используя метод
GetUninitializedObject или GetSafeUninitializedObject типа System.Runtime.
Serialization.FormatterServices


Нельзя вызывать какие-либо виртуальные методы конструктора, которые могут
повлиять на создаваемый объект. Причина проста: если вызываемый виртуальный
метод переопределен в типе, экземпляр которого создается, происходит реализация производного типа, но к этому моменту еще не завершилась инициализация
всех полей в иерархии. В таких обстоятельствах последствия вызова виртуального
метода непредсказуемы

можно вот так написать, инициализация будет перенесена в начало всех! конструкторов компилятором
=> il код разрастется
internal sealed class SomeType {
 private Int32 m_x = 5; 
}


Конструктор экземпляра значимого типа выполняется только при явном вызове. Так что если конструктор объекта Rectangle не инициализировал его поля
m_topLeft и m_bottomRight вызовом с помощью оператора new конструктора Point,
поля m_x и m_y у обеих структур Point будут содержать 0.

 C# не позволяет определять для значимого типа конструкторы без параметров


internal struct SomeValType {
 // В значимый тип нельзя подставлять инициализацию экземплярных полей
 private Int32 m_x = 5;
}

 любой конструктор,
определенный для значимого типа, должен инициализировать все поля этого типа.
Следующий тип определяет конструктор для значимого типа, но не может инициализировать все его поля:
internal struct SomeValType {
 private Int32 m_x, m_y;
 // C# допускает наличие у значимых типов конструкторов с параметрами
 public SomeValType(Int32 x) {
 m_x = x;
// Обратите внимание: поле m_y здесь не инициализируется
 }
}
При компиляции этого типа компилятор C# генерирует сообщение об ошибке:
(ошибка CS0171: поле 'SomeValType.m_y' должно быть полностью определено до
возвращения управления конструктором):


для установки дефолтных значений можно заюзать абуз
// C# позволяет значимым типам иметь конструкторы с параметрами
public SomeValType(Int32 x) {
 // Выглядит необычно, но компилируется прекрасно,
 // и все поля инициализируются значениями 0 или null
 this = new SomeValType();
 m_x = x; // Присваивает m_x значение x
 // Обратите внимание, что поле m_y было инициализировано нулем
}




страница 223



#implicit #explicit #приведение

 // Неявно создает Rational из Int32 и возвращает полученный объект
 public static implicit operator Rational(Int32 num) {
 return new Rational(num); }
 // Неявно создает Rational из Single и возвращает полученный объект
 public static implicit operator Rational(Single num) {
 return new Rational(num); }
 // Явно возвращает объект типа Int32, полученный из Rational
 public static explicit operator Int32(Rational r) {
 return r.ToInt32(); }
 // Явно возвращает объект типа Single, полученный из Rational
 public static explicit operator Single(Rational r) {
 return r.ToSingle();
 }





#partial
всегда возвращают void
не может быть параметров ref out
обе части должны иметь одинаковые сигнатуры
если тело метода не было определено то он просто будет игнорироваться
Хотя частичные методы всегда считаются закрытыми, компилятор C# запрещает писать ключевое слово private перед объявлением частичного метод

internal sealed partial class Base {
 partial void OnNameChanging(String value) {
 }
}









#params
параметры по умолчанию


При вызове метода извне модуля изменение значения параметров по умолчанию
является потенциально опасным. Вызывающая сторона использует значение
по умолчанию в процессе работы. Если изменить его и не перекомпилировать
код, содержащий вызов, в вызываемый метод будет передано прежнее значение

// Не делайте так:
 private static String MakePath(String filename = "Untitled"

// Используйте следующее решение:
 private static String MakePath(String filename = null) {
 filename ?? "Untitled";



перегрузка параметров
нельзя перегрузить метод что бы он отличался только ref или out


#ref #out
с помощью таких ключевых слов нельзя передавать свойства




#params
Вызов метода, принимающего переменное число аргументов, снижает производительность, если, конечно, не передавать в явном виде значение null. В любом случае
всем объектам массива нужно выделить место в куче и инициализировать элементы
массива, а по завершении работы занятая массивом память должна быть очищена
сборщиком мусора. Чтобы уменьшить негативное влияние этих операций на производительность, можно определить несколько перегруженных методов, в которых
не используется ключевое слово params. За примерами обратитесь к методу Concat
класса System.String, который перегружен следующим образом:
public sealed class String : Object, ... {
 public static string Concat(object arg0);
 public static string Concat(object arg0, object arg1);
 public static string Concat(object arg0, object arg1, object arg2);
 public static string Concat(params object[] args);








при определении сигнатуры методы
параметры должны быть как можно более "слабыми" (самый первый интерфейс), которого хватит для выполнения определенной логики
return тип должен быть самый сильный, тк если вызывающему коду понадобится его родитель он его просто приведет к нему и все








#tuple
Tuple.Create(Math.Min(a, b), Math.Max(a, b));
Чтобы создать тип Tuple с более, чем восьмью элементами, передайте другой
объект Tuple в параметре Rest
var t = Tuple.Create(0, 1, 2, 3, 4, 5, 6, Tuple.Create(7, 8));
Console.WriteLine("{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}",
 t.Item1, t.Item2, t.Item3, t.Item4, t.Item5, t.Item6, t.Item7,
 t.Rest.Item1.Item1, t.Rest.Item1.Item2);



#dynamic #ExpandoObject

dynamic e = new System.Dynamic.ExpandoObject();
e.x = 6; // Добавление свойства 'x' типа Int32 // со значением 6
e.z = null; // Добавление свойста 'z' объекта // со значением null
// Просмотр всех свойств и других значений
foreach (var v in (IDictionary<String, Object>)e)
Console.WriteLine("Key={0}, V={1}", v.Key, v.Value);
// Удаление свойства 'x' и его значения
var d = (IDictionary<String, Object>)e;
d.Remove("x");





#индексатор #[]

его можно перегрузить
//компилятор назовет такой метод Item, если нужно переименовать то
 [IndexerName("Bit")]//переименовываем, необязательно
 public Boolean this[Int32 bitPos] { 
get { }
set { 
if (value) { 
}
}






#generic #обобщения
 рекомендациях Microsoft для проектировщиков указано, что переменные параметров должны называться T или, в крайнем случае, начинаться с T (как, например, TKey или TValue). T означает тип (type), а I означает интерфейс (например,
IComparable).


List<DateTime> dt = new List<DateTime>();
internal sealed class DateTimeList : List<DateTime>
//так делать нельзя если это делается только для упрощения читабельности потому что это считается новым типом
Boolean sameType = (typeof(List<DateTime>) == typeof(DateTimeList));//false
Это также значит, что методу,
в прототипе которого определено, что он принимает значение типа DateTimeList,
нельзя передать List<DateTime>. Тем не менее методу, который должен принимать
List<DateTime>, можно передать DateTimeList, потому что тип DateTimeList является производным от List<DateTime>


для каждого обобщенного класса list<int> list<string> должен сгенерировать отдельный класс
это приводит к разрастанию кода, поэтому начали оптимизировать
если
List<DateTime> используется в двух совершенно разных сборках (загруженных
в один домен приложений), CLR компилирует методы для List<DateTime> всего один раз

Кроме того, CLR считает все аргументы ссылочного типа тождественными, что
опять же обеспечивает совместное использование кода. Например, код, скомпилированный в CLR для методов List<String>, может применяться для методов
List<Stream>, потому что String и Stream — ссылочные типы. По сути, для всех
ссылочных типов используется одинаковый код
для значимых типов создается новый тип на каждое обобщение



Display("Jeff"); // Вызывает Display(String)
Display(123); // Вызывает Display<T>(T)
Display<String>("Aidan"); // Вызывает Display<T>(T)
В первом случае компилятор может вызвать либо метод Display, принимающий
String, либо обобщенный метод Display (заменяя T типом String). Но компилятор
C# всегда выбирает явное, а не обобщенное соответствие



#Array
Также отмечу, что класс System.Array, базовый для всех типов массивов, поддерживает множество статических обобщенных методов, в том числе
AsReadOnly, BinarySearch, ConvertAll, Exists, Find, FindAll, FindIndex, FindLast,
FindLastIndex, ForEach, IndexOf, LastIndexOf, Resize, Sort и TrueForAll







#вариантность

с ref\out применять нельзя
delegate void SomeDelegate<in T>(ref T t);








#interface

Компилятор C# требует, чтобы метод, реализующий интерфейс, отмечался
модификатором public. CLR требует, чтобы интерфейсные методы были виртуальными. Если метод явно не определен в коде как виртуальный, компилятор сделает
его таковым и, вдобавок, запечатанным. Это не позволяет производному классу
переопределять интерфейсные методы. Если явно задать метод как виртуальный,
компилятор сделает его таковым и оставит незапечатанным, что предоставит производному классу возможность переопределять интерфейсные методы.
Производный класс не в состоянии переопределять интерфейсные   методы,
объявленные запечатанными, но может повторно унаследовать тот же интерфейс
и предоставить собственную реализацию его методов.

Если в C# перед именем метода указано имя интерфейса, в котором определен
этот метод (в нашем примере — IDisposable.Dispose), то вы создаете явную реализацию интерфейсного метода (Explicit Interface Method Implementation, #EIMI).
Заметьте: при явной реализации интерфейсного метода в C# нельзя указывать
уровень доступа (открытый или закрытый). Однако когда компилятор создает
метаданные для метода, он назначает ему закрытый уровень доступа (private),
что запрещает любому коду использовать экземпляр класса простым вызовом
интерфейсного метода. Единственный способ вызвать интерфейсный метод — обратиться через переменную этого интерфейсного типа.
Обратите внимание на то, что EIMI-метод не может быть виртуальным, а значит,
его нельзя переопределить. Это происходит потому, что EIMI-метод в действительности не является частью объектной модели типа; это всего лишь средство связывания интерфейса (набора вариантов поведения, или методов) с типом






#char

Символы в .NET Framework всегда представлены 16-разрядными кодами стандарта
Юникод
 два открытых неизменяемых поля: константа MinValue,
определенная как '\0', и константа MaxValue, определенная как '\uffff'
 IsDigit, IsLetter, IsWhiteSpace, IsUpper, IsLower, IsPunctuation, IsLetterOrDigit, IsControl, IsNumber, IsSeparator, IsSurrogate, IsLowSurrogate,
IsHighSurrogate и IsSymbol


для создания объекта в clr используется il-команда newobj но строки создаются через ldstr - загрузка строки





#string
при сравнении строк если нужно привести к какому либо регистру, то надо приводить всегда к верхнему тк это более оптимизировано
что бы ничего не сломалось при переносе win-unix
надо писать так  Environment.NewLine


Обычно следует избегать использования флагов StringComparison.InvariantCulture
и StringComparison.InvariantCultureIgnoreCase. Хотя эти значения и позволяют выполнить лингвистически корректное сравнение, применение их для сравнения строк
в программе занимает больше времени, чем с флагом StringComparison.Ordinal
или StringComparison.OrdinalIgnoreCase. Кроме того, игнорирование региональных
стандартов — совсем неудачный выбор для сортировки строк, которые планируется
показывать пользователю.

ToUpperInvariant ToLowerInvariant



сравнение строк с учетом региональных стандартов стр 367 - clr via c#


при сравнении 2х строк сначала проверяется их длина, если разная то строки разные
НО если сравнивать с учетом региональных стандартов то строки разной длины могут быть одинаковыми


#интернирование
по дефолту интернирование отключено
При инициализации CLR создает внутреннюю хеш-таблицу, в которой ключами
являются строки, а значениями — ссылки на строковые объекты в управляемой
куче. Вначале таблица, разумеется, пуста. В классе String есть два метода, предоставляющие доступ к внутренней хеш-таблице:
public static String Intern(String str);
public static String IsInterned(String str);
#Intern, ищет String во внутренней хеш-таблице. Если строка
обнаруживается, возвращается ссылка на соответствующий объект String. Иначе
создается копия строки, она добавляется во внутреннюю хеш-таблицу, и возвращается ссылка на копию. Если приложение больше не удерживает ссылку на исходный объект String, уборщик мусора вправе освободить память, занимаемую этой
строкой. Обратите внимание, что уборщик мусора не вправе освободить строки, на
которые ссылается внутренняя хеш-таблица, поскольку в ней самой есть ссылки
на эти String. Объекты String, на которые ссылается внутренняя хеш-таблица,
нельзя освободить, пока не выгружен соответствующий домен приложения или
не закрыт поток.
#IsInterned - не вставляет в таблицу



пулы строк
//TODO надо понять чем отличается от интернирования
При обработке исходного кода компилятор должен каждую литеральную строку
поместить в метаданные управляемого модуля. Если одна строка встречается
в исходном коде много раз, размещение всех таких строк в метаданных приведет
к увеличению размера результирующего файла.
Чтобы не допустить роста объема кода, многие компиляторы (в том числе C#)
хранят литеральную строку в метаданных модуля только в одном экземпляре. Все
упоминания этой строки в исходном коде компилятор заменяет ссылками на ее
экземпляр в метаданных. Благодаря этому заметно уменьшается размер модуля. 




Insert, Remove, PadLeft, Replace,
Split, Join, ToLower, ToUpper, Trim, Concat, Format
ToString - return this
Substring - вернуть кусок
CopyTo - скопировать в массив
Copy - полностью новая строка, другой объект
Clone - ссылка на тотже объект


#stringBuilder
основан на внутреннем массиве
ToString выполяется быстро и если получить им строку, потом изменить что то в самом объекте то строка не изменится

у него есть емкость - длина массива
по дефолту-16
если массив начинает выходить за емкость то емкость удваивается и в новый массив происходит копирование


через свойство индексатор Chars можно получить доступ к массиву




есть интерфейс #IFormattable
там есть ToString с форматированием
В FCL у всех базовых типов (Byte, SByte, Int16/UInt16, Int32/UInt32, Int64/
UInt64, Single, Double, Decimal и DateTime) есть реализации этого интерфейса
String s = price.ToString("C", new CultureInfo("vi-VN"));


Чтобы расширить стандартное форматирование объекта, нужно добавить внутрь
фигурных скобок строку форматирования. В частности, следующий код отличается от предыдущего только наличием строк форматирования для подставляемых
параметров 0 и 2:
String s = String.Format("On {0:D}, {1} is {2:E} years old.",
 new DateTime(2012, 4, 22, 14, 35, 5), "Aidan", 9);


создание собственного средства форматирования
стр 386 - clr via c#

Защищенные строки
и в FCL безопасный строковый класс System.
Security.SecureString\неуправляемая память, уборщик мусора ничего про нее не знает, нужно вызывать dispose
содержимое шифруется
есть "уязвимости"







#enum
Color[] colors = (Color[]) Enum.GetValues(typeof(Color));
Console.WriteLine("Number of symbols defined: " + colors.Length);
Console.WriteLine("Value\tSymbol\n-----\t------");
foreach (Color c in colors) {
 // Выводим каждый идентификатор в десятичном и общем форматах
 Console.WriteLine("{0,5:D}\t{0:G}", c);
}


#IsDefined
public void SetColor(Color c) {
 if (!Enum.IsDefined(typeof(Color), c)) {
throw(new ArgumentOutOfRangeException("c", c, "Invalid Color value."));
 }

это проверка что бы не было такого SetColor((Color) 999999999);



перечисления можно объединять через |
но не все а только битовые и помеченные атрибутом #Flags
размещаться должны определенным образом

[Flags, Serializable]
public enum FileAttributes {
 ReadOnly = 0x0001,
 Hidden = 0x0002,
 System = 0x0004,
 Directory = 0x0010,
 Archive = 0x0020,
 Device = 0x0040,
 Normal = 0x0080,
 Temporary = 0x0100,
 SparseFile = 0x0200,
 ReparsePoint = 0x0400,
 Compressed = 0x0800,
 Offline = 0x1000,
 NotContentIndexed = 0x2000,
 Encrypted = 0x4000
//можно прям так объявлять внутри
//ReadWrite = Actions.Read | Actions.Write,
}

Actions actions = Actions.Read | Actions.Delete; // 0x0005
Console.WriteLine(actions.ToString()); // "Read, Delete"






#array
приведение типов
// Создание двухмерного массива FileStream
FileStream[,] fs2dim = new FileStream[5, 10];
// Неявное приведение к массиву типа Object
Object[,] o2dim = fs2dim;
// Невозможно приведение двухмерного массива к одномерному
// Ошибка компиляции CS0030: невозможно преобразовать тип 'object[*,*]'
// в 'System.IO.Stream[]'
Stream[] s1dim = (Stream[]) o2dim;
// Явное приведение к двухмерному массиву Stream
Stream[,] s2dim = (Stream[,]) o2dim;
// Явное приведение к двухмерному массиву String
// Компилируется, но во время выполнения
// возникает исключение InvalidCastException
String[,] st2dim = (String[,]) o2dim;
// Создание одномерного массива Int32 (значимый тип)
Int32[] i1dim = new Int32[5];
// Невозможно приведение массива значимого типа
// Ошибка компиляции CS0030: невозможно преобразовать
// тип 'int[]' в 'object[]'
Object[] o1dim = (Object[]) i1dim;
// Создание нового массива и приведение элементов к нужному типу
// при помощи метода Array.Copy
// Создаем массив ссылок на упакованные элементы типа Int32
Object[] ob1dim = new Object[i1dim.Length];
Array.Copy(i1dim, ob1dim, i1dim.Length);




Array.Copy не просто копирует элементы одного массива в другой. 
Метод Copy выполняет
следующие действия:
-Упаковка элементов значимого типа в элементы ссылочного типа, например
копирование Int32[] в Object[].
-Распаковка элементов ссылочного типа в элементы значимого типа, например
копирование Object[] в Int32[]
-Расширение (widening) примитивных значимых типов, например копирование
Int32[] в Double[].
-Понижающее приведение в случаях, когда совместимость массивов невозможно
определить по их типам. Сюда относится, к примеру, приведение массива типа
Object[] в массив типа IFormattable[]. Если все объекты в массиве Object[]
реализуют интерфейс IFormattable[], приведение пройдет успешно


#ковариантность
работает не быстро
String[] sa = new String[100];
Object[] oa = sa; // oa ссылается на массив элементов типа String
oa[5] = "Jeff"; // CLR проверяет принадлежность oa к типу String;
 // Проверка проходит успешно
oa[3] = 5; // CLR проверяет принадлежность oa к типу Int32;
 // Генерируется исключение ArrayTypeMismatchException




#array
FileStream[] fsArray;
можно засунуть в
void M1(IList<FileStream> fsList) { ... }
void M2(ICollection<Stream> sCollection) { ... }
void M3(IEnumerable<Object> oEnumerable) { ... }


если метод возвращает private массив или лист то внешний код сможет его редачить!!!!!
для фикса вернуть копию
 Array.Copy - поверхностное копирование


Массивы с ненулевой нижней границей
Создавать их можно при помощи статического метода CreateInstance типа Array
 // Требуется двухмерный массив [2005..2009][1..4]
 Int32[] lowerBounds = { 2005, 1 };
Int32[] lengths = { 5, 4 };
 Decimal[,] quarterlyRevenue = (Decimal[,])
 Array.CreateInstance(typeof(Decimal), lengths, lowerBounds);



Если производительность для вас критична, управляемый массив можно вместо
кучи разместить в стеке потока. Для этого вам потребуется инструкция stackalloc
Она позволяет создавать одномерные массивы элементов значимого типа с нулевой нижней
границей. При этом значимый тип не должен содержать никаких полей ссылочного
типа. По сути, вы выделяете блок памяти, с которым можно работать при помощи небезопасных указателей, поэтому адрес этого буфера нельзя передавать большинству
FCL-методов. Выделенная в стеке память (массив) автоматически освобождается
после завершения метода. Именно за счет этого и достигается выигрыш в производительности. При этом для компилятора C# должен быть задан параметр /unsafe
clr via c# стр 433




#вариантность
поддерживается только с ссылочными типами!





Метод #GetInvocationList работает с объектами классов, производных от
MulticastDelegate. Он возвращает массив ссылок, каждая из которых указывает
на какой-то делегат в цепочке. По сути, этот метод создает массив и инициализирует его элементы ссылками на соответствующие делегаты; в конце возвращается
ссылка на этот массив. Если поле _invocationList содержит null, возвращаемый
массив будет содержать всего один элемент, ссылающийся на единственного делегата в цепочке — экземпляр самого делегата

public abstract class MulticastDelegate : Delegate {
 // Создает массив, каждый элемент которого ссылается
 // на делегата в цепочке
 public sealed override Delegate[] GetInvocationList();
}







#func
можно явно указать типы
Func<Int32, String> f2 = (Int32 n) => n.ToString();





#attr
у атрибутов может быть префикс
[assembly: SomeAttr] // Применяется к сборке
[module: SomeAttr] // Применяется к модулю
[type: SomeAttr] // Применяется к типу - компилятор может определить сам
[field: SomeAttr] // Применяется к полю - компилятор может определить сам
[return: SomeAttr] // Применяется к возвращаемому значению
 [method: SomeAttr] // Применяется к методу- компилятор может определить сам
 [param: SomeAttr] // Применяется к параметру- компилятор может определить сам
 [property: SomeAttr] // Применяется к свойству- компилятор может определить сам
[method: SomeAttr] // Применяется к механизму доступа get- компилятор может определить сам
 [event: SomeAttr] // Применяется к событиям- компилятор может определить сам
 [field: SomeAttr] // Применяется к полям, созданным компилятором
 [method: SomeAttr] // Применяется к созданным
 // компилятором методам add и remov


можно применить атрибут к атрибуту, тк атрибут просто класс


так нельзя
[Flags][Flags]
internal enum Color {

но
Однако есть и атрибуты, многократное применение которых оправдано — в FCL
это класс атрибутов ConditionalAttribute. Для этого параметру AllowMultiple
должно быть присвоено значение true. В противном случае многократное применение атрибута невозможно.
Свойство Inherited класса AttributeUsageAttribute указывает, будет ли
атрибут, применяемый к базовому классу, применяться также к производным
классам и переопределенным методам






#условный атрибут #Conditional
//#define TEST
#define VERIFY
using System;
using System.Diagnostics;
[Conditional("TEST")][Conditional("VERIFY")]
public sealed class CondAttribute : Attribute {
}
[Cond]
public sealed class Program {
 public static void Main() {
 Console.WriteLine("CondAttribute is {0}applied to Program type.",
 Attribute.IsDefined(typeof(Program),
 typeof(CondAttribute)) ? "" : "not ");

Обнаружив, что был применен экземпляр CondAttribute, компилятор помещает
в метаданные информацию об атрибуте, только если при компиляции кода был
определен идентификатор TEST или VERIFY. При этом метаданные определения
и реализации класса атрибута все равно останутся в сборке.






#reflection #attr
определить есть ли у типа атрибут
 if (this.GetType().IsDefined(typeof(FlagsAttribute), false)) {
#IsDefined
#GetCustomAttributes
#GetCustomAttribute





#null #nullable
int? test=null;
Унарные операторы (+++, -, --, ! , ~). Если операнд равен null, результат тоже
равен null.
Бинарные операторы (+, -, *, /, %, &, |, ^, <<, >>). Результат равен значению null,
если этому значению равен хотя бы один операнд. Исключением является случай
воздействия операторов & и | 
Операторы равенства (==, !=). Если оба операнда имеют значение null, они
равны. Если только один из них имеет это значение, операнды не равны. Если
ни один из них не равен null, операнды сравниваются на предмет равенства.
Операторы сравнения (<, >, <=, >=). Если значение null имеет один из операндов, в результате получаем значение false. Если ни один из операндов не имеет
значения null, следует сравнить их значения.





#try
#catch #exception

При отладке блока catch в Microsoft Visual Studio для просмотра текущего исключения следует добавить в окно контрольных значений специальную переменную
$exception

Можно создать событие FirstChanceException класса AppDomain и получать информацию об исключениях еще до того, как CLR начнет искать их обработчики

#finally
Прерывание потока или выгрузка домена приложений является источником исключения
ThreadAbortException, обеспечивающего выполнение блока finally. Если же поток прерывается функцией TerminateThread или методом FailFast класса System.Environment, блок
finally не выполняется. Разумеется, Windows производит очистку всех ресурсов, которые
использовались прерванным процессом



Начиная с версии 2.0, в CLR появился класс RuntimeWrappedException, определенный в пространстве имен System.Runtime.CompilerServices. Являясь
производным от класса Exception, он представляет собой CLS-совместимый тип
исключений. Этот класс обладает закрытым полем типа Object, к которому можно
обратиться через предназначенное только для чтения свойство WrappedException
того же класса. В CLR 2.0 при генерации CLS-несовместимого исключения автоматически создается экземпляр класса RuntimeWrappedException, закрытому полю
которого присваивается ссылка на вброшенный объект. Таким способом несовместимые с CLS исключения превращаются в CLS-совместимые. В итоге любой код,
умеющий перехватывать исключения типа Exception, будет перехватывать и все
остальные исключения, что устраняет угрозу безопасности

 catch (Exception e) {

//вот так стек исключения будет указывать на эту строку
 throw e; // CLR считает, что исключение возникло тут. FxCop сообщает об ошибке
 //а вот так все норм
throw; // CLR не меняет информацию о начальной точке исключения.
 }


Если вы считаете, что состояние повреждено настолько, что остается только завершить весь процесс, используйте статический метод FailFast класса
Environment:
public static void #FailFast(String message);
public static void FailFast(String message, Exception exception);


#handle #TODO вроде это проглотит исключения
catch (AggregateException x) {
 // Считаем обработанными все объекты OperationCanceledException
 // Все остальные исключения попадают в новый объект AggregateException,
 // состоящий только из необработанных исключений
 x.Handle(e => e is OperationCanceledException);
 // Строка выполняется, если все исключения уже обработаны
 Console.WriteLine("Sum was canceled");
}




#gc #мусор

CLR  использует алгоритм отслеживания ссылок. Алгоритм отслеживания ссылок
работает только с переменными ссылочного типа, потому что только эти переменные
могут ссылаться на объекты в куче; переменные значимых типов просто содержат
данные экземпляра значимого типа. Ссылочные переменные могут использоваться во многих контекстах: статические и экземплярные поля классов, аргументы
методов, локальные переменные. Все переменные ссылочных типов называются
корнями (roots)
Когда среда CLR запускает уборку мусора, она сначала приостанавливает все
программные потоки в процессе. Тем самым предотвращается обращение к объектам
и возможное изменение состояния во время их анализа CLR. Затем CLR переходит к этапу уборки мусора, называемому маркировкой (marking). CLR перебирает
все объекты в куче, задавая биту в поле индекса блока синхронизации значение 0.
Это означает, что все эти объекты могут быть удалены. Затем CLR проверяет все
активные корни и объекты, на которые они ссылаются. Если корень содержит null,
CLR игнорирует его и переходит к следующему корню
Если корень ссылается на объект, в поле индекса блока синхронизации устанавливается бит — это и есть признак маркировки объекта. После маркировки объекта
CLR проверяет все корни в этом объекте и маркирует объекты, на которые они
ссылаются. Встретив уже маркированный объект, уборщик мусора останавливается,
чтобы избежать возникновения бесконечного цикла в случае циклических ссылок

После проверки всех корней куча содержит набор маркированных и немаркированных объектов. Маркированные объекты переживут уборку мусора, потому что
на них ссылается хотя бы один объект; можно сказать, что они достижимы из кода
приложения. Немаркированные объекты недостижимы, потому что в приложении
не существует корня, через который приложение могло бы к ним обратиться.


Теперь, когда CLR знает, какие объекты должны остаться, а какие можно удалить, начинается следующая фаза уборки мусора, называемая сжатием (compacting
phase). В этой фазе CLR перемещает вниз все «немусорные» объекты, чтобы
они занимали смежный блок памяти. Перемещение имеет много преимуществ.
Во-первых, оставшиеся объекты будут находиться поблизости друг от друга; это
приводит к сокращению размера рабочего набора приложения, а следовательно,
повышает производительность обращения к этим объектам в будущем. Во-вторых,
свободное пространство тоже становится непрерывным, что позволяет освободить
эту область адресного пространства. Наконец, сжатие позволяет избежать проблем
фрагментации адресного пространства при использовании управляемой кучи.

в фазе сжатия
CLR вычитает из каждого корня количество байт, на которое объект был сдвинут 
вниз в памяти. Тем самым гарантируется, что каждый корень будет ссылаться на тот
же объект, что и прежде; просто сейчас этот объект оказался в другом месте памяти


Уборщик мусора с поддержкой поколений (generational garbage collector), который
также называют эфемерным уборщиком мусора (ephemeral garbage collector), хотя
я не использую такой термин в своей книге, работает на основе следующих предположений:

-чем младше объект, тем короче его время жизни
-чем старше объект, тем длиннее его время жизни
-уборка мусора в части кучи выполняется быстрее, чем во всей куче



ПОКОЛЕНИЯ
Сразу после инициализации в управляемой куче нет объектов. Говорят, что
создаваемые в куче объекты составляют поколение 0. Проще говоря, к нулевому
поколению относятся только что созданные объекты, которых не касался уборщик
мусора

у поколений есть пороговое значение(если память превышает это значение то пора убирать мусор)

Если
в результате выделения памяти для нового объекта размер поколения 0 превышает пороговое значение, должна начаться уборка мусора
после уборки мусор объекты которые выжилы становятся поколением 1

снова ваделяется память и объекты помещаются в поколение 0
поколение 0 заполнено
Начиная уборку мусора, уборщик определяет, сколько памяти занято поколением 1. Пока поколение 1 занимает намного меньше отведенной памяти, поэтому
уборщик проверяет только объекты поколения 0 и перемещает из нулевого в 1, те что до этого были в 1 остаются там
после того как в очередной раз что то перенеслось в поколение 1 и его пороговое значение привысилось, приложение продолжает работать пока не заполнится 0 поколение
и потом когда 0 поколение заполнено, проверяются все поколения которые заполнены и все что выжило смещается в поколение+1


В поколении 2 находятся объекты, проверенные уборщиком мусора не меньше двух раз.
Операций уборки мусора может быть много, но объекты поколения 1 проверяются
только тогда, когда их суммарный размер достигает порогового значения — до этого
обычно проходит несколько операций уборки мусора в поколении 0.

Управляемая куча поддерживает только три поколения: 0, 1 и 2. Поколения 3 не
существует

clr сам может менять пороговое значение и настраиваться

 если уборщик освобождает недостаточно памяти, перед генерированием исключения OutOfMemoryException он выполняет полную уборку мусора


Режимы уборки мусора
-Режим рабочей станции
-Режим сервера

=======такая инфа
Ясно, что игнорирование объектов поколения 1 повышает быстродействие уборщика. Однако его производительность растет еще больше благодаря выборочной
проверки объектов в управляемой куче. Если корень или объект ссылается на объект
из старшего поколения, уборщик игнорирует все внутренние ссылки старшего объекта, сокращая время построения графа доступных объектов. Конечно, возможна
ситуация, когда старый объект ссылается на новый. Чтобы не пропустить обновленные поля этих старых объектов, уборщик использует внутренний механизм
JIT-компилятора, устанавливающий флаг при изменении ссылочного поля объекта.
Он позволяет уборщику выяснить, какие из старых объектов (если они есть) были
изменены с момента последней уборки мусора. Остается проверять только старые
объекты с измененными полями, чтобы выяснить, не ссылаются ли они на новые
объекты из поколения 0

=====

=====
если уборка мусора длится слишком долго, может завершиться время ожидания клиентских запросов. Чтобы избежать
подобных ситуаций, в классе GC имеется метод RegisterForFullGCNotification.
С его помощью и при использовании дополнительных вспомогательных методов
(WaitForFullGCApproach, WaitForFullGCComplete и CancelFullGCNotification)
можно оповестить приложение о том, что уборщик мусора близок к выполнению
полной уборки. В результате приложение сможет вызвать метод GC.Collect для
принудительной уборки мусора в более подходящее время или свяжется с другими
серверами, чтобы лучше распределить клиентские запросы. Дополнительную информацию об этих методах вы можете найти в документации на .NET Framework
SDK. Имейте в виду, что методы WaitForFullGCApproach и WaitForFullGCComplete
всегда вызываются вместе, так как CLR обрабатывает их попарно.


===




#~
#finalize
#TODO
возможно при финализации все неуправляемые ресурсы сами уничтожатся\закроются
но про это надо почитать

Методы Finalize вызываются при завершении уборки мусора для объектов,
которые уборщик мусора определил для уничтожения. Это означает, что память
таких объектов не может быть освобождена немедленно, потому что метод Finalize
может выполнить код с обращением к полю. Так как финализируемый объект
должен пережить уборку мусора, он переводится в другое поколение, вследствие
чего такой объект живет намного дольше, чем следует. Ситуация не идеальна в отношении использования памяти, поэтому финализации следует по возможности
избегать. Проблема усугубляется тем, что при преобразовании поколения финализируемых объектов все объекты, на которые они ссылаются в своих полях, тоже
преобразуются, потому что они должны продолжать свое существование. Итак,
старайтесь по возможности обойтись без создания финализируемых объектов
с полями ссылочного типа.

Как вы думаете, что было бы, не будь кода, явно вызывающего метод Dispose?
Уборщик мусора однажды правильно определил бы, что эти объекты стали мусором, и финализировал их. Но он не может гарантировать определенной очередности вызова методов финализации. 


Иногда системный ресурс требует много памяти, а управляемый объект, являющийся его «оберткой», занимает очень мало памяти. 
С точки зрения CLR до уборки
мусора процесс может выделять сотни растровых изображений (которые займут
мало управляемой памяти). Однако если процесс манипулирует множеством изображений, расходование памяти процессом начнет расти с огромной скоростью.
Для исправления ситуации в классе GC предусмотрены два статических метода
следующего вида:
public static void AddMemoryPressure(Int64 bytesAllocated);
public static void RemoveMemoryPressure(Int64 bytesAllocated);





#reflection
#type #TypeInfo

Type typeReference = ...; // Например: o.GetType() или typeof(Object)
TypeInfo typeDefinition = typeReference.GetTypeInfo();
И хотя эта возможность менее полезна, объект TypeInfo можно преобразовать
в объект Type вызовом метода AsType класса TypeInfo.
TypeInfo typeDefinition = ...;
Type typeReference = typeDefinition.AsType();



Среда CLR не требует, чтобы у значимого типа был конструктор. И это создает проблемы, так как все перечисленные механизмы создают объект путем вызова его конструктора. Однако версии метода CreateInstance типа Activator позволяют создавать
экземпляры значимых типов без вызова их конструкторов. Чтобы создать экземпляр
значимого типа, не вызывая его конструктор, нужно вызвать версию CreateInstance,
принимающую единственный параметр Type, или версию, принимающую параметры
Type и Boolean.

Эти механизмы позволяют создавать объекты любых типов, кроме массивов
(то есть типов, производных от System.Array) и делегатов (потомков типа System.
MulticastDelegate)

Чтобы создать массив, надо вызвать статический метод CreateInstance объекта Array
Для создания делегата следует вызвать статический метод CreateDelegate объекта Delegate

generic
Для создания экземпляра обобщенного типа сначала нужно получить ссылку на
открытый тип, а затем вызвать открытый экземплярный метод MakeGenericType
объекта Type, передав массив типов, который нужно использовать в качестве параметров типа. Затем надо получить возвращенный объект Type и передать его в один
из описанных ранее методов
 // Получаем ссылку на объект Type обобщенного типа
 Type openType = typeof(Dictionary<,>);
 // Закрываем обобщенный тип, используя TKey=String, TValue=Int32
 Type closedType = openType.MakeGenericType(
 new Type[] { typeof(String), typeof(Int32) });
 // Создаем экземпляр закрытого типа
 Object o = Activator.CreateInstance(closedType);


type & #MemberInfo сохраняются в определенной коллекции. Позже приложение ищет нужный объект в
коллекции и вызывает его
объекты Type и объекты, производные от MemberInfo, занимают много места в памяти
Внутренние механизмы CLR поддерживают более компактную форму хранения
этой информации. CLR создает такие объекты в приложениях лишь для того, чтобы
упростить работу программиста. Самой среде CLR для работы эти большие объекты  не нужны

можно сократить потребление памяти, если
использовать не объекты, а описатели времени выполнения. В FCL определены
три типа таких описателей (все в пространстве имен System): #RuntimeTypeHandle,
#RuntimeFieldHandle и #RuntimeMethodHandle. 
Все они — значимые типы с единственным полем IntPtr; за счет чего расходуют очень мало ресурсов (то есть памяти).
Поле IntPtr представляет собой дескриптор, ссылающийся на тип, поле или метод
в куче загрузчика домена приложений. Так что теперь нам достаточно научиться
просто и эффективно преобразовывать «тяжелые» объекты Type и MemberInfo
в «легкие» дескрипторы времени выполнения, и наоборот. Это не сложно, если
задействовать перечисленные далее методы и свойства.
-Чтобы преобразовать объект Type в RuntimeTypeHandle, вызовите статический
метод GetTypeHandle объекта Type, передав ему ссылку на объект Type
-Чтобы преобразовать RuntimeTypeHandle в объект Type, вызовите статический
метод GetTypeFromHandle объекта Type, передав ему RuntimeTypeHandle
-Чтобы преобразовать объект FieldInfo в RuntimeFieldHandle, запросите экземплярное неизменяемое свойство FieldHandle объекта FieldInfo
-Чтобы преобразовать RuntimeTypeHandle в объект FieldInfo, вызовите статический метод GetTypeFromHandle объекта FieldInfo
-Чтобы преобразовать объект MethodInfo в RuntimeMethodHandle, запросите
экземплярное неизменяемое свойство MethodHandle объекта MethodInfo
-Чтобы преобразовать RuntimeTypeHandle в объект MethodInfo, вызовите статический метод GetMethodFromHandle объекта MethodInfo.


List<RuntimeMethodHandle> methodHandles =
 methodInfos.ConvertAll<RuntimeMethodHandle>(mb => mb.MethodHandle);
methodInfos = methodHandles.ConvertAll<MethodBase>(
 rmh=> MethodBase.GetMethodFromHandle(rmh));




#xml
Начиная с версии 3.5, в .NET Framework класс #SoapFormatter считается устаревшим
и не рекомендуется к использованию. Однако его имеет смысл применять при отладке
кода сериализации, так как он создает доступный для чтения текст в формате XML.
Если в выходном коде вы хотите воспользоваться механизмами XML-сериализации
и XML-десериализации, обратитесь к классам #XmlSerializer и #DataContractSerializer



[#Serializable]
internal class Circle {
 private Double m_radius;
 [#NonSerialized]
 private Double m_area;

[#OnDeserialized] - после
 private void OnDeserialized(StreamingContext context) {

 [#OnDeserializing] - перед
 [#OnSerializing] - перед
 [#OnSerialized] - после
все они обязательно принимают StreamingContext и возвращают void

В C# внутри типов, помеченных атрибутом [Serializable], не стоит определять автоматически реализуемые свойства. Дело в том, что имена полей, генерируемые компилятором, могут
меняться после каждой следующей компиляции, что сделает невозможной десериализацию
экземпляров типа.


еще сериализация есть через #сурогаты #surrogate







#datetime

// Переход от локального к мировому времени
  ((DateTime)obj).ToUniversalTime().ToString("u");
 // Переход от мирового времени к локальному
 return DateTime.ParseExact( info.GetString("Date"), "u", null).ToLocalTime();





#thread
Каждый поток состоит из нескольких частей стр 726 clr via c#
-Объект ядра потока (thread kernel object)
-Блок окружения потока (Thread Environment Block, TEB).
-Стек пользовательского режима (user-mode stack). 
-Стек режима ядра (kernel-mode stack)
-Уведомления о создании и завершении потоков

В произвольный момент времени Windows передает процессору на исполнение
один поток. Этот поток исполняется в течение некоторого временного интервала,
иногда называемого тактом (quantum). После завершения этого интервала контекст Windows переключается на другой поток. При этом обязательно происходит
следующее:
1. Значения регистров процессора исполняющегося в данный момент потока сохраняются в структуре контекста, которая располагается в ядре потока.
2. Из набора имеющихся потоков выделяется тот, которому будет передано управление. Если выбранный поток принадлежит другому процессу, Windows переключает для процессора виртуальное адресное пространство. Только после этого
возможно выполнение какого-либо кода или доступ к каким-либо данным.
3. Значения из выбранной структуры контекста потока загружаются в регистры
процессора.

После переключения контекста процессор исполняет выбранный поток, пока
не истечет выделенное потоку время, после этого снова происходит переключение
контекста. Windows делает это примерно каждые 30 мс. Никакого выигрыша в производительности или потреблении памяти переключение контекстов не дает. Оно требуется только для того, чтобы операционная система была надежной и быстро
реагировала на действия конечных пользователей.

Не стоит забывать и о том, что компьютер с несколькими процессорами может
исполнять несколько потоков одновременно, что улучшает масштабируемость
системы (способность выполнения большей работы за меньшее время). Каждому
ядру процессора назначается свой поток, и это ядро организует собственное переключение контекстов. Операционная система следит за тем, чтобы один поток не
планировался одновременно на нескольких ядрах, так как это привело бы к хаосу. 


Если думать только о производительности, оптимальное число потоков на машине
должно быть равно числу установленных на ней процессоров, в таком случае не будет переключения контекста



причины не пользовать пулом потоков, а создавать его явно
-Поток требуется запустить с нестандартным приоритетом (все потоки пула
выполняются с обычным приоритетом). Хотя изменить приоритет можно, но
делать это не рекомендуется, кроме того, изменение приоритета не сохраняется
между операциями с пулом потоков
-Чтобы приложение не закрылось до завершения потоком задания, требуется,
чтобы поток исполнялся в фоновом режиме. Эта тема подробно рассмотрена
в разделе «Фоновые и активные потоки» далее в этой главе. Потоки из пула
всегда являются фоновыми, и существует риск, что они не успеют выполнить
задание из-за того, что CLR решит завершить процесс
-Задания, связанные с вычислениями, обычно выполняются крайне долго; для
подобных заданий я не стал бы отдавать решение о необходимости создания
нового потока на откуп логике пула потоков.
-Возможно возникнет необходимость преждевременно завершить исполняющийся поток методом Abort класса Thread


создание объекта c# потока -быстро, ту не создается сам поток в системе
поток создается при методе start



подождать поток .Join();


Windows называют многопоточной операционной системой с вытесняющей
многозадачностью, потому что каждый поток может быть остановлен в произвольный момент времени и вместо него выбран для исполнения другой.


Каждому потоку назначается уровень приоритета с нулевого (самого низкого)
до 31 (самого высокого). При выборе потока, который будет передан процессору,
сначала рассматриваются потоки с самым высоким приоритетом и ставятся в очередь в цикле. 
Потоки с высоким приоритетом всегда исполняются перед потоками с низким
приоритетом вне зависимости от того, какие задания выполняют последние. Если
в системе работает поток с приоритетом 5 и система определяет, что поток с более
высоким приоритетом готов к работе, исполнение немедленно приостанавливается (даже если поток находится в середине такта) и процессору передается
новый поток
В процессе загрузки система создает поток обнуления страниц (zero page thread),
которому назначается нулевой приоритет. Это единственный поток в системе с таким приоритетом. Его задача состоит в обнулении свободных страниц и исполняется
он только при отсутствии других потоков.


При разработке приложения следует решить, должно ли оно реагировать быстрее
или медленнее, чем другие запущенные на этой же машине приложения. В соответствии с этим решением выбирается класс приоритета для процесса. В Windows
поддерживаются шесть классов приоритетов: Idle (холостого хода), Below Normal
(ниже обычного), Normal (обычный), Above Normal (выше обычного), High (высокий) и Realtime (реального времени). По умолчанию выбирается приоритет Normal,
он же является самым распространенным.

 В Windows поддерживаются семь относительных приоритетов
потоков: Idle (холостого хода), Lowest (самый низкий), Below Normal (ниже обычного), Normal (обычный), Above Normal (выше обычного), Highest (самый высокий)
и Time-Critical (требующий немедленной обработки). Эти приоритеты соотносятся с классами приоритетов процесса. По умолчанию для потоков используется
обычный приоритет, соответственно, он применяется чаще всего.

. Определение уровня приоритета определяется на основе класса приоритета
процесса и относительного приоритета потока (742 clr vai c#)

В CLR все потоки делятся на активные (foreground) и фоновые (background). При
завершении активных потоков в процессе CLR принудительно завершает также
все запущенные на этот момент фоновые потоки. При этом завершение фоновых
потоков происходит немедленно и без появления исключений.
Следовательно, активные потоки имеет смысл использовать для исполнения
заданий, которые обязательно требуется завершить


Поток можно превращать из активного в фоновый и обратно. Основной поток
приложения и все потоки, в явном виде созданные путем конструирования объекта
Thread, по умолчанию являются активными. А вот потоки из пула по умолчанию
являются фоновыми. Также потоки, создаваемые машинным кодом и попадающие
в управляемую среду исполнения, помечаются как фоновые.

 // Превращение потока в фоновый
 t.IsBackground = true;



#pool #threadpool
можно задать максимальное количество потоков в пуле, но делать так не стоит
среда CLR способна управлять собственным пулом потоков, то есть набором готовых
потоков, доступных для использования приложениями. Для каждого экземпляра
CLR существует свой пул, используемый всеми доменами приложений, находящимися под управлением экземпляра CLR. Если в один процесс загружаются
несколько экземпляров CLR, для каждого из них формируется собственный пул

При инициализации CLR пул потоков пуст. В его внутренней реализации поддерживается очередь запросов на выполнение операций. Для выполнения приложением
асинхронной операции вызывается метод, размещающий соответствующий запрос
в очереди пула потоков. Код пула извлекает записи из очереди и распределяет их
среди потоков из пула. Если пул пуст, создается новый поток. Как уже отмечалось,
создание потока отрицательно сказывается на производительности. Однако по
завершении исполнения своего задания поток не уничтожается, а возвращается
в пул и ожидает следующего запроса. Поскольку поток не уничтожается, производительность не страдает.

Когда приложение отправляет пулу много запросов, он пытается обслужить их
все с помощью одного потока. Однако если приложение создает очередь запросов
быстрее, чем поток из пула их обслуживает, создаются дополнительные потоки.
Такой подход позволяет обойтись при обработке запросов небольшим количеством
потоков.
Когда приложение прекращает отправлять запросы в пул, появляются незанятые
потоки, впустую занимающие память. Поэтому через некоторое время бездействия
(различное для разных версий CLR) поток пробуждается и самоуничтожается, освобождая ресурсы. Это опять отрицательно сказывается на производительности, но в
данном случае это уже не столь важно, поскольку уничтожаемый поток все равно простаивал, а значит, приложение в данный момент не было особо загружено работой.

Для добавления в очередь пула потоков асинхронных вычислительных операций
обычно вызывают один из следующих методов класса ThreadPool:
static Boolean QueueUserWorkItem(WaitCallback callBack);
static Boolean QueueUserWorkItem(WaitCallback callBack, Object state);
Эти методы ставят «рабочий элемент» вместе с дополнительными данными
состояния в очередь пула потоков и сразу возвращают управление приложению.
Рабочим элементом называется указанный в параметре callback метод, который
будет вызван потоком из пула. Этому методу можно передать один параметр
через аргумент state (данные состояния). Без этого параметра версия метода
QueueUserWorkItem передает методу обратного вызова значение null. Все заканчивается тем, что один из потоков пула обработает рабочий элемент, приводя к вызову
указанного метода. Создаваемый метод обратного вызова должен соответствовать
делегату System.Threading.WaitCallback, который определяется так:
delegate void WaitCallback(Object state);

Если метод обратного вызова генерирует необработанное исключение, CLR завершает процесс (если это не противоречит политике хоста)

С каждым потоком связан определенный контекст исполнения. Он включает в себя параметры безопасности (сжатый стек, свойство Principal объекта
Thread и идентификационные данные Windows), параметры хоста (System.
Threading.HostExecutionContextManager) и контекстные данные логического
вызова (см. методы LogicalSetData и LogicalGetData класса System.Runtime.
Remoting.Messaging.CallContext)

По умолчанию CLR автоматически копирует контекст исполнения самого
первого потока во все вспомогательные потоки. Это гарантирует безопасность,
но в ущерб производительности, потому что в контексте исполнения содержится
много информации. Сбор всей информации и ее копирование во вспомогательные
потоки занимает немало времени. Вспомогательный поток может, в свою очередь, использовать вспомогательные потоки, при этом создаются и инициализируются
дополнительные структуры данных.
Класс ExecutionContext в пространстве имен System.Threading позволяет
управлять копированием контекста исполнения потока. Вот как он выглядит:
public sealed class ExecutionContext : IDisposable, ISerializable {
 [SecurityCritical] public static AsyncFlowControl SuppressFlow();
 public static void RestoreFlow();
 public static Boolean IsFlowSuppressed();
 // Не показаны редко применяемые методы
}



// Помещаем данные в контекст логического вызова потока метода Main
 CallContext.LogicalSetData("Name", "Jeffrey");
 // Заставляем поток из пула работать
 // Поток из пула имеет доступ к данным контекста логического вызова
 ThreadPool.QueueUserWorkItem(
 state => Console.WriteLine("Name={0}",
 CallContext.LogicalGetData("Name")));
 // Запрещаем копирование контекста исполнения потока метода Main
 ExecutionContext.SuppressFlow();



#cancel
Этот объект содержит все состояния, необходимые для управляемой отмены.
После создания объекта #CancellationTokenSource (ссылочный тип) получить один или несколько экземпляров #CancellationToken (значимый тип) можно из
свойства Token

Чтобы предотвратить отмену операции, ей можно передать экземпляр
CancellationToken, возвращенный статическим свойством None структуры
CancellationToken. Это очень удобное свойство возвращает специальный экземпляр
CancellationToken, не связанный с каким-либо объектом CancellationTokenSource (его
закрытое поле имеет значение null).


можно зарегистрировать один или несколько методов таким
образом, чтобы они вызывались при отмене объекта CancellationTokenSource. метод Register
varcts = new CancellationTokenSource();
cts.Token.Register(() => Console.WriteLine("Canceled 1"));
cts.Token.Register(() => Console.WriteLine("Canceled 2"));



// Создание нового объекта CancellationTokenSource,
// отменяемого при отмене cts1 или ct2
var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
 cts1.Token, cts2.Token);


отмена по таймеру
public sealed class CancellationTokenSource : IDisposable { // Ссылочный тип
 public CancellationTokenSource(Int32 millisecondsDelay);
 public CancellationTokenSource(TimeSpan delay);
 public void CancelAfter(Int32 millisecondsDelay);
 public void CancelAfter(TimeSpan delay);
 ...
}


для таски можно написать класс расширения что бы удобно отменять их
clr via c# стр 814




#task
ThreadPool.QueueUserWorkItem(ComputeBoundOp, 5); // Вызов QueueUserWorkItem
new Task(ComputeBoundOp, 5).Start(); // Аналог предыдущей строки
Task.Run(() => ComputeBoundOp(5)); // Еще один аналог


почему надо бзать task а не потоки:
-Задания требуют меньше памяти, чем потоки, кроме того, они намного быстрее
создаются и уничтожаются.
-Пул потоков автоматически распределяет задания среди доступных процессоров
-По мере того как каждое задание завершает свой этап, выполнявший его поток
возвращается в пул, где может заняться другой работой, если таковая имеется.
-Пул потоков видит все задания сразу и поэтому может лучше планировать их
выполнение, сокращая количество потоков в процессе, а значит, и количество
переключений контекста.



await Task.#Delay(2000);


#TODO
если асинхронный метод возвращает void а не task то его нормально не использовать await
и не получить исключения которые выброшены в методе


async анонимный метод
Task.Run(async () => {
 await XxxAsync(); // Инициирование асинхронной операции
});



#TODO
#ConfigureAwait
return await msg.Content.ReadAsStringAsync().ConfigureAwait(false); 

 вызов ConfigureAwait(false) должен быть
применен к каждому объекту Task, используемому с await. Это связано с тем, что
асинхронные операции могут завершаться синхронно, и когда это происходит, вызывающий поток просто продолжает выполняться без возвращения управления
стороне вызова; вы никогда не знаете, какой операции потребуется игнорировать
объект SynchronizationContext, поэтому необходимо приказать всем операциям
игнорировать его



раньше вместо task использовали 
Begin...
End...
сейчас это можно засунуть в таску
await Task.Factory.FromAsync(begin,end,null);

еще есть событийная модель
var wc = new System.Net.WebClient(); 
var tcs = new TaskCompletionSource<String>(); //штука благодаря которой асунем в таск
// При завершении загрузки строки объект WebClient инициирует
 // событие DownloadStringCompleted, завершающее TaskCompletionSource
 wc.DownloadStringCompleted += (s, e) => {
 if (e.Cancelled) tcs.SetCanceled();
 else if (e.Error != null) tcs.SetException(e.Error);
 else tcs.SetResult(e.Result);
 }; 
 // Начало асинхронной операции
 wc.DownloadStringAsync(uri);
 // Теперь мы можем взять объект Task из TaskCompletionSource
 // и обработать результат обычным способом.
 String result = await tcs.Task; 




#async
-Асинхронная функция не может иметь параметры out и ref
Оператор await не может использоваться в блоке catch, finally или unsafe
-Не допускается установление блокировки, поддерживающей владение потоком или рекурсию, до операции await, и ее снятие после оператора await. Это
ограничение объясняется тем, что один поток может выполнить код до await,
а другой поток может выполнить код после await. При использовании await
с командой C# lock компилятор выдает сообщение об ошибке. Если вместо
этого явно вызвать методы Enter и Exit класса Monitor, то код откомпилируется, но Monitor.Exit выдаст исключение SynchronizationLockException во
время выполнения
-В выражениях запросов оператор await может использоваться только в первом
выражении коллекции условия from или в выражении коллекции условия
join.


=====такое
При вызове потоком метода Wait система проверяет, началось ли выполнение задания
Task, которого ожидает поток. В случае положительного результата проверки поток,
вызывающий метод Wait, блокируется до завершения задания. Но если задание еще
не начало выполняться, система может (в зависимости от объекта TaskScheduler)
выполнить его при помощи потока, вызывающего метод Wait. В этом случае данный поток не блокируется. Он выполняет задание Task и немедленно возвращает
управление. Это снижает затраты ресурсов (вам не приходится создавать поток
взамен заблокированного), повышает производительность (на создание потока
и переключение контекста не тратится время). Однако и это может быть не очень
хорошо. Например, если перед вызовом метода Wait в рамках синхронизации потока
происходит его блокирование, а затем задание пытается получить доступ к тем же
запертым ресурсам, возникает взаимная блокировка (deadlock)
====

Если вы ни разу не вызывали методы Wait или Result и не обращались к свойству
Exception класса Task, код не «узнает» о появившихся исключениях. Иначе говоря,
вы не получите информации о том, что программа столкнулась с неожиданной
проблемой. Для распознавания скрытых исключений можно зарегистрировать метод обратного вызова со статическим событием UnobservedTaskException класса
TaskScheduler. При уничтожении задания со скрытым исключением в ходе уборки
мусора это событие активизируется потоком финализации уборщика мусора CLR.
После этого обработчику события передается объект UnobservedTaskExceptionEve
ntArgs, содержащий скрытое исключение AggregateException.



System.Web.Mvc.#AsyncController
почитать, от этого надо наследовать контроллер




передаем токен отмены
CancellationTokenSource cts = new CancellationTokenSource();
Task<Int32> t = new Task<Int32>(() => Sum(cts.Token, 10000), cts.Token);


Следует также упомянуть, что во внутренней реализации объект Task содержит
коллекцию ContinueWith. Это дает возможность несколько раз вызвать метод
ContinueWith при помощи единственного объекта Task. Когда это задание завершится, все задания из коллекции ContinueWith окажутся в очереди в пуле потоков.
Кроме того, при вызове метода #ContinueWith можно установить флаги перечисления #TaskContinuationOptions.
там можно настроить когда вызовется таска, например только при отмене и тд

Task<Int32> t = Task.Run(() => Sum(10000));
t.ContinueWith(task => Console.WriteLine("The sum is: " + task.Result),
 TaskContinuationOptions.OnlyOnRanToCompletion);
t.ContinueWith(task => Console.WriteLine("Sum threw: " + task.Exception),
 TaskContinuationOptions.OnlyOnFaulted);

 
таску можно присоеденить к родительской таске а #TaskCreationOptions.#AttachedToParent


узнать статус таски можно так task.Status
узнать исключения таски можно  task.#AggregateException

#todo
файбрика заданий  #TaskFactory


#TODO #TaskScheduler
 http://code.msdn.microsoft.com/ParExtSamples




#tpl #parallel

Если у вас есть выбор между Parallel.For и Parallel.ForEach, лучше используйте цикл For, так
как он работает быстрее.
Parallel.For(0, 1000, i => DoWork(i));
Parallel.ForEach(collection, item => DoWork(item));

// Потоки из пула выполняют методы одновременно
Parallel.Invoke(
 () => Method1(),
 () => Method2(),
 () => Method3());

Выполнение вызывающего потока не возобновляется, пока
не будет завершена вся работа. Если какая-либо операция станет источником необработанного исключения, вызванный вами метод Parallel выдаст исключение
AggregateException.




#ParallelEnumerable
есть методы
 Where, Select, SelectMany, GroupBy, Join, OrderBy, Skip, Take
для их использования надо сначала вызвать метод .AsParallel()


 существует возможность в ходе операций переключиться с параллельного режима на последовательный

метод  AsSequential класса ParallelEnumerable
Этот метод преобразует ParallelQuery<T> в интерфейс IEnumerable<T>, и все
операции начинают выполняться всего одним потоком.

Так как при параллельном LINQ-запросе элементы обрабатываются несколькими потоками одновременно, результаты возвращаются в произвольном порядке.
Для сохранения очередности обработки элементов применяется метод #AsOrdered
класса ParallelEnumerable.
 Вот операторы, предназначенные для выполнения неупорядоченных операций: Distinct, Except, Intersect, Union, Join,
GroupBy, GroupJoin и ToLookup. После любого из этих операторов можно вызвать
метод AsOrdered, чтобы упорядочить элементы

Следующие операторы выполняют упорядоченные операции: OrderBy,
OrderByDescending, ThenBy и ThenByDescending. Если вы хотите вернуться к неупорядоченным операциям, чтобы повысить производительность, после любого из
этих операторов также можно вызвать метод AsUnordered.



#directory 

= Directory.EnumerateFiles(path, searchPattern, searchOption);





#filestream
При создании объекта FileStream флаг FileOptions.Asynchronous позволяет указать, какие операции — синхронные или асинхронные — будут использоваться для
взаимодействия




#атомарность
CLR гарантирует атомарность чтения и записи следующих типов данных: Boolean,
Char, (S)Byte, (U)Int16, (U)Int32, (U)IntPtr, Single и ссылочных типов. Это означает, что все байты переменной читаются или записываются одновременно.








#lock #блокировка

есть 3 типа синхронизации
1 Примитивные конструкции пользовательского режима 
2 Примитивные конструкции режима ядра
3 комбинированные (гибридные)


То есть если поток пула пытается получить
доступ к запертому ресурсу и не получает его, скорее всего, пул создаст еще один
поток для сохранения загрузки процессора.  Но хуже всего то, что после разблокирования старый поток появляется
в пуле вместе с новым; то есть операционной системе приходится планировать
выполнение потоков, количество которых превышает количество процессоров,
а значит, увеличивается частота переключений контекста, что, опять же, отрицательно сказывается на производительности.


!!!
Старайтесь по возможности работать со значимыми типами, потому что они
всегда копируются, и каждый поток в итоге работает с собственной копией. Ну и,
наконец, нет ничего страшного в одновременном доступе разных потоков к общим
данным, если эти данные предназначены только для чтения.


тип 1 пользовательского режима 
По возможности нужно задействовать их
так как они значительно быстрее
вторых и используют для координации потоков специальные директивы процессора. То есть координация имеет место уже на аппаратном уровне (и именно это
обеспечивает быстродействие). Однако одновременно это означает, что блокировка
потоков на уровне примитивной конструкции пользовательского режима операционной системой Windows просто не распознается. А так как заблокированным
таким способом поток пула не считается таковым, пул не создает дополнительных
потоков для восполнения загрузки процессора. Кроме того, блокировка происходит
на очень короткое время

 поток, который
пытается, но не может получить некоторый ресурс, начинает циклически существовать в пользовательском режиме. Потенциально это является пустым расходованием
времени процессора, которое лучше было бы потратить с пользой — или просто
разрешить процессору простаивать для экономии энергии.


тип 2 еще делится на 3 типа
#Volatile-конструкции выполняют для переменной, содержащей данные простого #TODO
типа, атомарную операцию чтения или записи

Interlocked-конструкции выполняют для переменной, содержащей данные простого типа, атомарную операцию чтения и записи.
выполняются атомарно, ставится барьер

#SpinLock
надо убедиться что они никуда не передаются, тк они копируются
нельзя помечать readonly


тип 2 режима ядра

К примитивным конструкциям синхронизации потоков в режиме ядра относятся события (events) и семафоры (semaphores). На их основе строятся 
более сложные конструкции аналогичного назначения, например мьютексы
(mutex)
классы AutoResetEvent, ManualResetEvent, Semaphore
и Mutex являются производными от класса WaitHandle, то есть наследуют методы
этого класса и их поведение.


Конструкции режима ядра часто используются для создания приложений, которые в любой момент времени могут существовать только в одном экземпляре. 


 Они
предоставляются самой операционной системой Windows и требуют от потоков
приложения вызова функций, реализованных в ядре. Переход потока между пользовательским режимом и режимом ядра требует значительных затрат ресурсов,
поэтому конструкций режима ядра крайне желательно избегать

Если один поток использует конструкцию режима ядра для
получения доступа к ресурсу, с которым уже работает другой поток, Windows блокирует его, чтобы не тратить понапрасну время процессора. А затем, когда ресурс
становится доступным, блокировка снимается, и поток получает доступ к ресурсу.

Если поток, использующий в данный момент конструкцию, не освободит ее,
ожидающий конструкции поток может оказаться заблокированным навсегда. В этом
случае в пользовательском режиме поток бесконечно исполняется процессором;
этот вариант блокировки называется активной (живой) блокировкой (livelock)

Многие из конструкций синхронизации потоков в CLR являются всего лишь объектно-ориентированными оболочками классов, построенных на базе конструкций
синхронизации потоков Win32. В конце концов, CLR-потоки являются потоками
операционной системы Windows, которая планирует и контролирует их синхронизацию


Для синхронизации потоков в Windows существует несколько конструкций режима
ядра. Они работают намного медленнее конструкций пользовательского режима,
так как требуют координации со стороны операционной системы. Кроме того,
каждый вызов метода для объекта ядра заставляет вызывающий поток перейти из
управляемого в машинный код, затем в код режима ядра, после чего возвращается
назад. Такие переходы требуют много процессорного времени и их частое выполнение значительно снижает производительность приложения.
Впрочем, у конструкций режима ядра есть и свои преимущества перед конструкциями пользовательского режима:

-Если конструкция режима ядра выявляет конкуренцию за ресурс, Windows
блокирует проигравший поток, останавливая зацикливание, которое ведет к напрасному расходованию ресурсов процессора
-Конструкции режима ядра могут осуществлять взаимную синхронизацию неуправляемых и управляемых потоков
-Конструкции режима ядра умеют синхронизировать потоки различных процессов, запущенных на одной машине.
-Конструкции режима ядра можно наделить атрибутами безопасности, ограничивая несанкционированный доступ к ним
-Поток можно заблокировать, пока не станут доступны все конструкции режима
ядра или пока не станет доступна хотя бы одна такая конструкция
-Поток можно заблокировать конструкцией режима ядра, указав время ожидания;
если за указанное время поток не получит доступа к нужному ему ресурсу, он
будет разблокирован и сможет выполнять другие задания.


#mutex #мьютекс

Мьютексы снабжены дополнительной логикой, что делает их более сложными
по сравнению с другими конструкциями. Во-первых, объекты Mutex сохраняют
информацию о том, какие потоки ими владеют. Для этого они запрашивают идентификатор потока (Int32). Если поток вызывает метод ReleaseMutex, объект Mutex
сначала убеждается, что это именно владеющий им поток. Если это не так, состояние
объекта Mutex не меняется, а метод ReleaseMutex генерирует исключение System.
ApplicationException. Если владеющий объектом Mutex поток по какой-то причине завершается, пробуждается другой поток, ожидающий мьютекса, и генерирует
исключение System.Threading.AbandonedMutexException.

мьютекс поддерживает рекурсию тк хранит в себе поток который его заблокировал

 private readonly Mutex m_lock = new Mutex();
 public void Method1() {
 m_lock.WaitOne();
 Method2(); // Метод Method2, рекурсивно получающий право на блокировку
 m_lock.ReleaseMutex();
 }
 public void Method2() {
 m_lock.WaitOne();
 m_lock.ReleaseMutex();
 }



Подытожим, каким образом ведут себя  примитива режима ядра
-При наличии нескольких потоков в режиме ожидания событие с автосбросом
освобождает только один из них
-Событие с ручным сбросом снимает блокировку со всех ожидающих его потоков.
-При наличии нескольких потоков, ожидающих семафора, его появление снимает
блокировку с потоков releaseCount (здесь releaseCount — это аргумент, переданный методу Release класса Semaphore).



тип 3 гибридные конструкции
В идеальном мире у нас были бы конструкции, сочетающие лучшие особенности
обоих типов: быстро работающие и не блокирующиеся (как конструкции пользовательского режима) в условиях отсутствия конкуренции. А если конструкции начинали бы соперничать друг другом, их блокировало бы ядро операционной системы

При отсутствии конкуренции потоков гибридные конструкции
дают даже более высокую производительность, чем простейшие конструкции
пользовательского режима. В них также применяются простейшие конструкции
режима ядра, что позволяет избежать зацикливания (пустой траты процессорного времени) при попытке нескольких потоков одновременно получить доступ
к процессору. Так как в большинстве приложений потоки редко конкурируют за
доступ к конструкции, повышение производительности способствует ускорению
работы приложения.



#ManualResetEventSlim #SemaphoreSlim
Они функционируют точно так же,
как их аналоги режима ядра, отличаясь только зацикливанием в пользовательском 
режиме, а также тем, что они не создают конструкций режима ядра до возникновения конкуренции. Их методы Wait позволяют передать информацию о времени
ожидания и объект CancellationToken




#monitor
 обеспечивающий взаимоисключающее блокирование с зацикливанием, владением потоком и рекурсией.
всегда надо кидать в него private поле или локальное, никогда не кидать this, type, string, не ссылочный тип(тк будет упаковка и ничего не заблокируется вообще)


#lock
раскладывается в это
private void SomeMethod() {
 Boolean lockTaken = false;
 try {
 //
 Monitor.Enter(this, ref lockTaken);
 // Этот код имеет монопольный доступ к данным...
 }
 finally {
 if (lockTaken) Monitor.Exit(this);
 }



#ReaderWriterLockSlim

#OneManyLock - не официальная, вроде должна быть норм
#CountdownEvent

#Barrier
выставляются что бы 1 участок был пройден разными потоками одновременно


#SemaphoreSlim
есть метод WaitAsync




у каждого объекта есть блок синхронизации(или такова изначальная задумка) #TODO
Очевидно, что привязка блока синхронизации к каждому объекту в куче является достаточно расточительной, особенно если учесть тот факт, что большинство объектов никогда не пользуются этим блоком. Чтобы снизить потребление
памяти, разработчики CLR применили более эффективный вариант реализации
описанной функциональности. Во время инициализации CLR выделяется массив
блоков синхронизации. Как уже не раз упоминалось в этой книге, при создании
объекта в куче с ним связываются два дополнительных служебных поля. Первое
поле — указатель на объект-тип — содержит адрес этого объекта в памяти. Второе поле содержит индекс блока синхронизации (sync block index), то есть индекс
в массиве таких блоков.





В FCL существует четыре безопасных в отношении потоков класса коллекций, принадлежащих пространству имен System.Collections.#Concurrent: #ConcurrentQueue,
#ConcurrentStack, #ConcurrentDictionary и #ConcurrentBag
Эти классы коллекций являются неблокирующими. При попытке извлечь несуществующий элемент поток немедленно возвращает управление, а не блокируется,
ожидая появления элемента. Именно поэтому такие методы, как TryDequeue, TryPop,
TryTake и TryGetValue, при получении элемента возвращают значение true, а при
его невозможности — false.

Обратите внимание, что все рассматриваемые классы обладают методом
GetEnumerator, обычно используемым в инструкции C# foreach, но допустимым
и в языке LINQ. Для классов ConcurrentStack, ConcurrentQueue и ConcurrentBag
метод GetEnumerator создает снимок содержимого коллекции и возвращает зафиксированные элементы; при этом реальное содержимое коллекции уже может
измениться. Метод GetEnumerator класса ConcurrentDictionary не фиксирует 
содержимое коллекции, а значит, в процессе просмотра словаря его вид может
поменяться; об этом следует помнить. Свойство Count возвращает количество
элементов в коллекции на момент запроса. Если другие потоки в это время добавляют элементы в коллекцию или извлекают их оттуда, возвращенное значение
может оказаться неверным







#lazy
#LazyInitializer.#EnsureInitialized - можно использовать вместо lazy






794 страница - надо записать










































