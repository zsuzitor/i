#CLR/#CTS - это всечто может clr-100% функционала
языки которые построены на clr используют только часть функционала, и каждый разную часть
#CLS - это функционал(часть clr)(тимы методы и тд) которые обязан реализовывать язык из clr

using System;

// Приказываем компилятору проверять код
// на совместимость с CLS
[assembly: CLSCompliant(true)]

namespace SomeLibrary { 

псевдонимы типов(например long) на самом деле в fcl называются system.Int64 и тд, не все типы поддерживаются fcl
стр 143 clr via c#







сборка с отложенным подписанием - стр 108 clr via c#

сборка с строгим именем TODO



Оператор #new выполняет следующие действия
1. Вычисление количества байтов, необходимых для хранения всех экземплярных полей типа и всех его базовых типов, включая System.Object (в котором
отсутствуют собственные экземплярные поля). Кроме того, в каждом объекте
кучи должны присутствовать дополнительные члены, называемые указателем
на объект-тип (type object pointer) и индексом блока синхронизации (sync block
index); они необходимы CLR для управления объектом. Байты этих дополнительных членов добавляются к байтам, необходимым для размещения самого
объекта.
2. Выделение памяти для объекта с резервированием необходимого для данного
типа количества байтов в управляемой куче. Выделенные байты инициализируются нулями (0).
3. Инициализация указателя на объект-тип и индекса блока синхронизации.
4. Вызов конструктора экземпляра типа с параметрами, указанными при вызове
new (в предыдущем примере это строка ConstructorParam1). Большинство
компиляторов автоматически включает в конструктор код вызова конструктора
базового класса. Каждый конструктор выполняет инициализацию определенных
в соответствующем типе полей. В частности, вызывается конструктор System.
Object, но он ничего не делает и просто возвращает управление.
Выполнив все эти операции, new возвращает ссылку (или указатель) на вновь
созданный объект. В предыдущем примере кода эта ссылка сохраняется в переменной e типа Employee.





#struct #ValueType
Все структуры являются прямыми потомками абстрактного типа System.
ValueType, который, в свою очередь, является производным от типа System.
Object. По умолчанию все значимые типы должны быть производными от System.
ValueType. Все перечисления являются производными от типа System.Enum, производного от System.ValueType.

При определении собственного значимого типа нельзя выбрать произвольный
базовый тип, однако значимый тип может реализовать один или несколько выбранных вами интерфейсов. Кроме того, в CLR значимый тип является изолированным,
то есть он не может служить базовым типом для какого-либо другого ссылочного
или значимого типа. 

System.ValueType переопределяет
метод Equals, который возвращает true, если значения полей в обоих объектах
совпадают. Кроме того, в System.ValueType переопределен метод GetHashCode,
который создает хеш-код по алгоритму, учитывающему значения полей экземпляра объекта. Из-за проблем с производительностью в реализации по умолчанию(рефлексия), определяя собственные значимые типы значений, надо переопределить
и написать свою реализацию методов Equals == и GetHashCode
см #equals



можно изменить порядок полей объекта(то как будут храниться)
System.Runtime.InteropServices.StructLayoutAttribute.
Чтобы порядок полей устанавливался CLR, нужно передать конструктору атрибута параметр LayoutKind.Auto, чтобы сохранить установленный программистом порядок — параметр LayoutKind.Sequential, а параметр LayoutKind.
Explicit позволяет разместить поля в памяти, явно задав смещения. Если в описании типа не применен атрибут StructLayoutAttribute, порядок полей выберет
компилятор

Для ссылочных типов (классов) компилятор C# выбирает вариант LayoutKind.
Auto, а для значимых типов (структур) — LayoutKind.Sequential
// Для повышения производительности разрешим CLR
// установить порядок полей для этого типа
[StructLayout(LayoutKind.Auto)]
internal struct SomeValType {
 private readonly Byte m_b; 






#упаковка
При упаковке экземпляра значимого типа происходит следующее.
1. В управляемой куче выделяется память. Ее объем определяется длиной значимого типа и двумя дополнительными членами — указателем на типовой объект
и индексом блока синхронизации. Эти члены необходимы для всех объектов
в управляемой куче.
2. Поля значимого типа копируются в память, только что выделенную в куче.
3. Возвращается адрес объекта. Этот адрес является ссылкой на объект, то есть
значимый тип превращается в ссылочный.


#распаковка
При распаковке упакованного значимого типа происходит следующее.
1. Если переменная, содержащая ссылку на упакованный значимый тип, равна
null, генерируется исключение NullReferenceException.
2. Если ссылка указывает на объект, не являющийся упакованным значением
требуемого значимого типа, генерируется исключение InvalidCastException
нельзя распаковать int32 в int16, но можно сначала распаковать а потом явно привести тип





//TODO это надо записать короче - страница 168
Хотя неупакованные значимые типы не имеют указателя на типовой объект, вы
все равно можете вызывать виртуальные методы (такие, как Equals, GetHashCode
или ToString), унаследованные или прееопределенные этим типом. Если ваш значимый тип переопределяет один из этих виртуальных методов, CLR может вызвать
метод невиртуально, потому что значимые типы неявно запечатываются и поэтому
не могут выступать базовыми классами других типов. Кроме того, экземпляр значимого типа, используемый для вызова виртуального метода, не упаковывается.
Но если ваше переопределение виртуального метода вызывает реализацию этого
метода из базового типа, экземпляр значимого типа упаковывается при вызове
реализации базового типа, чтобы в указателе this базового метода передавалась
ссылка на объект в куче.
Вместе с тем вызов невиртуального унаследованного метода (такого, как GetType
или MemberwiseClone) всегда требует упаковки значимого типа, так как эти методы
определены в System.Object, поэтому методы ожидают, что в аргументе this передается указатель на объект в куче.
Кроме того, приведение неупакованного экземпляра значимого типа к одному
из интерфейсов этого типа требует, чтобы экземпляр был упакован, так как интерфейсные переменные всегда должны содержать ссылку на объект в куче. 


internal struct Point : IComparable {
 private Int32 m_x, m_y;
 // Конструктор, просто инициализирующий поля
 public Point(Int32 x, Int32 y) {
 m_x = x;
 m_y = y;
 }
 // Переопределяем метод ToString, унаследованный от System.ValueType
 public override String ToString() {
 // Возвращаем Point как строку (вызов ToString предотвращает упаковку)
 return String.Format("({0}, {1})", m_x.ToString(), m_y.ToString());
 }
 // Безопасная в отношении типов реализация метода CompareTo
 public Int32 CompareTo(Point other) {
 // Используем теорему Пифагора для определения точки,
 // наиболее удаленной от начала координат (0, 0)
 return Math.Sign(Math.Sqrt(m_x * m_x + m_y * m_y)
 - Math.Sqrt(other.m_x * other.m_x + other.m_y * other.m_y));
 }
 // Реализация метода CompareTo интерфейса IComparable
 public Int32 CompareTo(Object o) {
 if (GetType() != o.GetType()) { 
throw new ArgumentException("o is not a Point");
 }
 // Вызов безопасного в отношении типов метода CompareTo
 return CompareTo((Point) o);
 }
}
public static class Program {
 public static void Main() {
 // Создаем в стеке два экземпляра Point
 Point p1 = new Point(10, 10);
 Point p2 = new Point(20, 20);
 // p1 НЕ пакуется для вызова ToString (виртуальный метод)
 Console.WriteLine(p1.ToString()); // "(10, 10)"
 // p1 ПАКУЕТСЯ для вызова GetType (невиртуальный метод)
 Console.WriteLine(p1.GetType()); // "Point"
 // p1 НЕ пакуется для вызова CompareTo
 // p2 НЕ пакуется, потому что вызван CompareTo(Point)
 Console.WriteLine(p1.CompareTo(p2)); // "-1"
 // p1 пакуется, а ссылка размещается в c
 IComparable c = p1;
 Console.WriteLine(c.GetType()); // "Point"
 // p1 НЕ пакуется для вызова CompareTo
 // Поскольку в CompareTo не передается переменная Point,
 // вызывается CompareTo(Object), которому нужна ссылка
 // на упакованный Point
 // c НЕ пакуется, потому что уже ссылается на упакованный Point
 Console.WriteLine(p1.CompareTo(c)); // "0"
 // c НЕ пакуется, потому что уже ссылается на упакованный Point
 // p2 ПАКУЕТСЯ, потому что вызывается CompareTo(Object)
 Console.WriteLine(c.CompareTo(p2));// "-1"
 // c пакуется, а поля копируются в p2
 p2 = (Point) c;
 // Убеждаемся, что поля скопированы в p2
 Console.WriteLine(p2.ToString());// "(10, 10)"


// p упаковывается, упакованный объект изменяется и освобождается
 ((IChangeBoxedPoint) p).Change(4, 4);
 Console.WriteLine(p);
 // Упакованный объект изменяется и выводится
 ((IChangeBoxedPoint) o).Change(5, 5);
 Console.WriteLine(o); 

 }
}


Вызов ToString
При вызове ToString упаковка p1 не требуется
 метод ToString переопределен в Point

Вызов GetType. При вызове невиртуального метода GetType упаковка p1 необходима, поскольку тип Point не реализует GetType, а наследует его от System.
Object

Первый вызов CompareTo. При первом вызове CompareTo упаковка p1 не нужна,
так как Point реализует метод CompareTo, и компилятор может просто вызвать его
напрямую. 

Приведение типа к IComparable. Когда выполняется приведение типа p1 к переменной интерфейсного типа (с), упаковка p1 необходима

Второй вызов CompareTo. При втором вызове CompareTo упаковка p1 не производится, потому что Point реализует метод CompareTo, и компилятор может
вызывать его напрямую.

Третий вызов CompareTo. При третьем вызове CompareTo переменная c уже
ссылается на упакованный объект Point в куче. Поскольку переменная c сама
по себе имеет интерфейсный тип IComparable, можно вызывать только метод
CompareTo интерфейса, а ему требуется параметр Object


Приведение типа к Point. Когда выполняется приведение c к типу Point, объект в куче, на который указывает c, распаковывается, и ег







#== #equals 
что бы проверить равенство ссылок надо юзать #ReferenceEquals
не нужно использовать == тк мы не можем точно знать перегружен ли этот оператор на сравнение по значению


при создании значимого типа надо обязательно перегрузить == Equals
тк по дефолту используется отражение и это медленно
Определяя собственный тип и приняв решение переопределить Equals, обеспечьте поддержку четырех характеристик, присущих равенству
-Рефлексивность: x.Equals(x) должно возвращать true.
-Симметричность: x.Equals(y) и y.Equals(x) должны возвращать одно и то же значение
-Транзитивность: если x.Equals(y) возвращает true и y.Equals(z) возвращает
true, то x.Equals(z) также должно возвращать true.
-Постоянство: если в двух сравниваемых значениях не произошло изменений,
результат сравнения тоже не должен измениться.
Отступление от этих правил при создании собственной реализации Equals
грозит непредсказуемым поведением приложения.
При переопределении метода Equals может потребоваться выполнить несколько
дополнительных операций.
-Реализовать в типе метод Equals интерфейса System.IEquatable<T>. Этот
обобщенный интерфейс позволяет определить безопасный в отношении типов
метод Equals. Обычно Equals реализуют так, что, принимая параметр типа
Object, код метода вызывает безопасный в отношении типов метод Equals.
-Перегрузить методы операторов == и !=. Обычно код реализации этих операторных методов вызывает безопасный в отношении типов метод Equals.



#TODO не особо понимаю что это 
Ранее я уже говорил о том, что компилятор C# на этапе выполнения программы генерирует код полезной нагрузки, основываясь на действительных
типах объекта. Этот код полезной нагрузки использует класс, известный как
компоновщик (runtime binder). Различные языки программирования определяют собственных компоновщиков, инкапсулируя в них правила языка





#dynamic
можно "засунуть" в dynamic статику(вызов статических членов типа)
это не из коробки работает, можно написать -clr via c# стр 183







#const
Константы всегда связаны с типом,
а не с экземпляром типа, а на логическом уровне константы всегда являются
статическими членами

Константа (constant) — это идентификатор, значение которого никогда не меняется. Значение, связанное с именем константы, должно определяться во время
компиляции. Затем компилятор сохраняет значение константы в метаданных
модуля. Это значит, что константы можно определять только для таких типов,
которые компилятор считает примитивными. В C# следующие типы считаются
примитивными и могут использоваться для определения констант: Boolean, Char,
Byte, SByte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Decimal
и String.
можно объявить ссылочную константу если присвоить ей null


константы встраиваются сразу в il код(нет ссылок на саму константу, встраивается значение)
если констнта в другой сборке и константа изменена то надо перекомпилировать все сборки которые на нее ссылаются

что бы всего избежать этого можно юзать readonly




дружественная #сборка
В процессе создания сборки можно указать другие сборки, которые она будет
считать «друзьями», — для этого служит атрибут InternalsVisibleTo, определенный в пространстве имен System.Runtime.CompilerServices. У атрибута есть
строковый параметр, определяющий имя дружественной сборки и ее открытый ключ
(передаваемая атрибуту строка не должна содержать информацию о версии, региональных стандартах или архитектуре процессора). Заметьте, что дружественные
сборки получают доступ ко всем внутренним типам сборки, а также к внутренним
членам этих типов. 

// Внутренние типы этой сборки доступны из кода двух следующих сборок
// (независимо от версии или региональных стандартов)
[assembly:InternalsVisibleTo("Wintellect, PublicKey=12345678...90abcdef")]
[assembly:InternalsVisibleTo("Microsoft, PublicKey=b77a5c56...1934e089")]
internal sealed class SomeInternalType { ... }
internal sealed class AnotherInternalType { ... }



CLR 
C# 
Описание

-Private (закрытый) 
private 
Доступен только методам в определяющем типе и вложенных в него типах
-Family (родовой) 
protected 
Доступен только методам в определяющем типе
(и вложенных в него типах) или в одном из его производных типов независимо от сборки
-Family and Assembly (родовой и сборочный)
(не поддерживается)
Доступен только методам в определяющем типе (и вложенных в него типах) и производных типах в определяющей сборке
-Assembly (сборочный)
internal 
Доступен только методам в определяющейсборке
Assembly or Family(сборочный илиродовой)
protected internal
Доступен только методам вложенного типа, производного типа (независимо от сборки) и любым методам определяющей сборки Public (открытый) public Доступен всем методам во всех сборках


Если в производном типе переопределяется член базового типа, компилятор C#
требует, чтобы у членов базового и производного типов были одинаковые модификаторы доступа. То есть если член базового класса является защищенным, то и член
производного класса должен быть защищенным. Однако это ограничение языка C#,
а не CLR. При наследовании от базового класса CLR позволяет снижать, но не повышать ограничения доступа к члену. Например, защищенный метод базового класса
можно переопределить в производном классе в открытый, но не в закрытый. Дело
в том, что пользователь производного класса всегда может получить доступ к методу
базового класса путем приведения к базовому типу. Если бы среда CLR разрешала
устанавливать более жесткие ограничения на доступ к методу в производном типе,
то эти ограничения бы элементарно обходились







#il #ildasm.exe








при перегрузке методов
в il можно определить 2 одинаковых метода которые будут различаться только return типом
такая возможность блокируется языками программирования




методы могут компилироваться в разные команды il
call
callvirt - для виртуального метода, работает медленнее
не любой виртуальный метод вызывается через callvirt
например если перегружается метод ToString и вызывает в себе base.ToString()
то такой метод вызывается как call тк при вызове base.ToString должен вызываться тот же метод в котором уже сейчас выполняется код
(вызывается как бы родительский метод, но из за виртуальности вызовется дочерний)

Компиляторы стремятся использовать команду call при вызове методов, определенных значимыми типами, поскольку они запечатаны. В этом случае полиморфизм
невозможен даже для виртуальных методов, и вызов выполняется быстрее. Кроме
того, сама природа экземпляра значимого типа гарантирует, что он никогда не будет
равен null, поэтому исключение NullReferenceException не возникнет. Наконец,
для виртуального вызова виртуального метода значимого типа CLR необходимо
получить ссылку на объект значимого типа, чтобы воспользоваться его таблицей
методов, а это требует упаковки значимого типа






#abstract #constructor

Для абстрактных классов компилятор создает конструктор по умолчанию с модификатором protected, в противном случае область действия будет открытой
(public). Если в базовом классе нет конструктора без параметров, производный
класс должен явно вызвать конструктор базового класса, иначе компилятор вернет
ошибку. Для статических классов (запечатанных и абстрактных) компилятор не
создает конструктор по умолчанию

В редких ситуациях экземпляр типа может создаваться без вызова конструктора экземпляров. В частности, метод MemberwiseClone объекта Object выделяет
память, инициализирует служебные поля объекта, а затем копирует байты исходного объекта в область памяти, выделенную для нового объекта. Кроме того,
конструктор обычно не вызывается при десериализации объекта. Код десериализации выделяет память для объекта без вызова конструктора, используя метод
GetUninitializedObject или GetSafeUninitializedObject типа System.Runtime.
Serialization.FormatterServices


Нельзя вызывать какие-либо виртуальные методы конструктора, которые могут
повлиять на создаваемый объект. Причина проста: если вызываемый виртуальный
метод переопределен в типе, экземпляр которого создается, происходит реализация производного типа, но к этому моменту еще не завершилась инициализация
всех полей в иерархии. В таких обстоятельствах последствия вызова виртуального
метода непредсказуемы

можно вот так написать, инициализация будет перенесена в начало всех! конструкторов компилятором
=> il код разрастется
internal sealed class SomeType {
 private Int32 m_x = 5; 
}


Конструктор экземпляра значимого типа выполняется только при явном вызове. Так что если конструктор объекта Rectangle не инициализировал его поля
m_topLeft и m_bottomRight вызовом с помощью оператора new конструктора Point,
поля m_x и m_y у обеих структур Point будут содержать 0.

 C# не позволяет определять для значимого типа конструкторы без параметров


internal struct SomeValType {
 // В значимый тип нельзя подставлять инициализацию экземплярных полей
 private Int32 m_x = 5;
}

 любой конструктор,
определенный для значимого типа, должен инициализировать все поля этого типа.
Следующий тип определяет конструктор для значимого типа, но не может инициализировать все его поля:
internal struct SomeValType {
 private Int32 m_x, m_y;
 // C# допускает наличие у значимых типов конструкторов с параметрами
 public SomeValType(Int32 x) {
 m_x = x;
// Обратите внимание: поле m_y здесь не инициализируется
 }
}
При компиляции этого типа компилятор C# генерирует сообщение об ошибке:
(ошибка CS0171: поле 'SomeValType.m_y' должно быть полностью определено до
возвращения управления конструктором):


для установки дефолтных значений можно заюзать абуз
// C# позволяет значимым типам иметь конструкторы с параметрами
public SomeValType(Int32 x) {
 // Выглядит необычно, но компилируется прекрасно,
 // и все поля инициализируются значениями 0 или null
 this = new SomeValType();
 m_x = x; // Присваивает m_x значение x
 // Обратите внимание, что поле m_y было инициализировано нулем
}




страница 223



#implicit #explicit #приведение

 // Неявно создает Rational из Int32 и возвращает полученный объект
 public static implicit operator Rational(Int32 num) {
 return new Rational(num); }
 // Неявно создает Rational из Single и возвращает полученный объект
 public static implicit operator Rational(Single num) {
 return new Rational(num); }
 // Явно возвращает объект типа Int32, полученный из Rational
 public static explicit operator Int32(Rational r) {
 return r.ToInt32(); }
 // Явно возвращает объект типа Single, полученный из Rational
 public static explicit operator Single(Rational r) {
 return r.ToSingle();
 }





#partial
всегда возвращают void
не может быть параметров ref out
обе части должны иметь одинаковые сигнатуры
если тело метода не было определено то он просто будет игнорироваться
Хотя частичные методы всегда считаются закрытыми, компилятор C# запрещает писать ключевое слово private перед объявлением частичного метод

internal sealed partial class Base {
 partial void OnNameChanging(String value) {
 }
}









#params
параметры по умолчанию


При вызове метода извне модуля изменение значения параметров по умолчанию
является потенциально опасным. Вызывающая сторона использует значение
по умолчанию в процессе работы. Если изменить его и не перекомпилировать
код, содержащий вызов, в вызываемый метод будет передано прежнее значение

// Не делайте так:
 private static String MakePath(String filename = "Untitled"

// Используйте следующее решение:
 private static String MakePath(String filename = null) {
 filename ?? "Untitled";



перегрузка параметров
нельзя перегрузить метод что бы он отличался только ref или out


#ref #out
с помощью таких ключевых слов нельзя передавать свойства




#params
Вызов метода, принимающего переменное число аргументов, снижает производительность, если, конечно, не передавать в явном виде значение null. В любом случае
всем объектам массива нужно выделить место в куче и инициализировать элементы
массива, а по завершении работы занятая массивом память должна быть очищена
сборщиком мусора. Чтобы уменьшить негативное влияние этих операций на производительность, можно определить несколько перегруженных методов, в которых
не используется ключевое слово params. За примерами обратитесь к методу Concat
класса System.String, который перегружен следующим образом:
public sealed class String : Object, ... {
 public static string Concat(object arg0);
 public static string Concat(object arg0, object arg1);
 public static string Concat(object arg0, object arg1, object arg2);
 public static string Concat(params object[] args);








при определении сигнатуры методы
параметры должны быть как можно более "слабыми" (самый первый интерфейс), которого хватит для выполнения определенной логики
return тип должен быть самый сильный, тк если вызывающему коду понадобится его родитель он его просто приведет к нему и все








#tuple
Tuple.Create(Math.Min(a, b), Math.Max(a, b));
Чтобы создать тип Tuple с более, чем восьмью элементами, передайте другой
объект Tuple в параметре Rest
var t = Tuple.Create(0, 1, 2, 3, 4, 5, 6, Tuple.Create(7, 8));
Console.WriteLine("{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}",
 t.Item1, t.Item2, t.Item3, t.Item4, t.Item5, t.Item6, t.Item7,
 t.Rest.Item1.Item1, t.Rest.Item1.Item2);



#dynamic #ExpandoObject

dynamic e = new System.Dynamic.ExpandoObject();
e.x = 6; // Добавление свойства 'x' типа Int32 // со значением 6
e.z = null; // Добавление свойста 'z' объекта // со значением null
// Просмотр всех свойств и других значений
foreach (var v in (IDictionary<String, Object>)e)
Console.WriteLine("Key={0}, V={1}", v.Key, v.Value);
// Удаление свойства 'x' и его значения
var d = (IDictionary<String, Object>)e;
d.Remove("x");





#индексатор #[]

его можно перегрузить
//компилятор назовет такой метод Item, если нужно переименовать то
 [IndexerName("Bit")]//переименовываем, необязательно
 public Boolean this[Int32 bitPos] { 
get { }
set { 
if (value) { 
}
}






#generic #обобщения
 рекомендациях Microsoft для проектировщиков указано, что переменные параметров должны называться T или, в крайнем случае, начинаться с T (как, например, TKey или TValue). T означает тип (type), а I означает интерфейс (например,
IComparable).


List<DateTime> dt = new List<DateTime>();
internal sealed class DateTimeList : List<DateTime>
//так делать нельзя если это делается только для упрощения читабельности потому что это считается новым типом
Boolean sameType = (typeof(List<DateTime>) == typeof(DateTimeList));//false
Это также значит, что методу,
в прототипе которого определено, что он принимает значение типа DateTimeList,
нельзя передать List<DateTime>. Тем не менее методу, который должен принимать
List<DateTime>, можно передать DateTimeList, потому что тип DateTimeList является производным от List<DateTime>


для каждого обобщенного класса list<int> list<string> должен сгенерировать отдельный класс
это приводит к разрастанию кода, поэтому начали оптимизировать
если
List<DateTime> используется в двух совершенно разных сборках (загруженных
в один домен приложений), CLR компилирует методы для List<DateTime> всего один раз

Кроме того, CLR считает все аргументы ссылочного типа тождественными, что
опять же обеспечивает совместное использование кода. Например, код, скомпилированный в CLR для методов List<String>, может применяться для методов
List<Stream>, потому что String и Stream — ссылочные типы. По сути, для всех
ссылочных типов используется одинаковый код
для значимых типов создается новый тип на каждое обобщение



Display("Jeff"); // Вызывает Display(String)
Display(123); // Вызывает Display<T>(T)
Display<String>("Aidan"); // Вызывает Display<T>(T)
В первом случае компилятор может вызвать либо метод Display, принимающий
String, либо обобщенный метод Display (заменяя T типом String). Но компилятор
C# всегда выбирает явное, а не обобщенное соответствие



#Array
Также отмечу, что класс System.Array, базовый для всех типов массивов, поддерживает множество статических обобщенных методов, в том числе
AsReadOnly, BinarySearch, ConvertAll, Exists, Find, FindAll, FindIndex, FindLast,
FindLastIndex, ForEach, IndexOf, LastIndexOf, Resize, Sort и TrueForAll







#вариантность

с ref\out применять нельзя
delegate void SomeDelegate<in T>(ref T t);








#interface

Компилятор C# требует, чтобы метод, реализующий интерфейс, отмечался
модификатором public. CLR требует, чтобы интерфейсные методы были виртуальными. Если метод явно не определен в коде как виртуальный, компилятор сделает
его таковым и, вдобавок, запечатанным. Это не позволяет производному классу
переопределять интерфейсные методы. Если явно задать метод как виртуальный,
компилятор сделает его таковым и оставит незапечатанным, что предоставит производному классу возможность переопределять интерфейсные методы.
Производный класс не в состоянии переопределять интерфейсные   методы,
объявленные запечатанными, но может повторно унаследовать тот же интерфейс
и предоставить собственную реализацию его методов.

Если в C# перед именем метода указано имя интерфейса, в котором определен
этот метод (в нашем примере — IDisposable.Dispose), то вы создаете явную реализацию интерфейсного метода (Explicit Interface Method Implementation, #EIMI).
Заметьте: при явной реализации интерфейсного метода в C# нельзя указывать
уровень доступа (открытый или закрытый). Однако когда компилятор создает
метаданные для метода, он назначает ему закрытый уровень доступа (private),
что запрещает любому коду использовать экземпляр класса простым вызовом
интерфейсного метода. Единственный способ вызвать интерфейсный метод — обратиться через переменную этого интерфейсного типа.
Обратите внимание на то, что EIMI-метод не может быть виртуальным, а значит,
его нельзя переопределить. Это происходит потому, что EIMI-метод в действительности не является частью объектной модели типа; это всего лишь средство связывания интерфейса (набора вариантов поведения, или методов) с типом






#char

Символы в .NET Framework всегда представлены 16-разрядными кодами стандарта
Юникод
 два открытых неизменяемых поля: константа MinValue,
определенная как '\0', и константа MaxValue, определенная как '\uffff'
 IsDigit, IsLetter, IsWhiteSpace, IsUpper, IsLower, IsPunctuation, IsLetterOrDigit, IsControl, IsNumber, IsSeparator, IsSurrogate, IsLowSurrogate,
IsHighSurrogate и IsSymbol


для создания объекта в clr используется il-команда newobj но строки создаются через ldstr - загрузка строки





#string
при сравнении строк если нужно привести к какому либо регистру, то надо приводить всегда к верхнему тк это более оптимизировано
что бы ничего не сломалось при переносе win-unix
надо писать так  Environment.NewLine


Обычно следует избегать использования флагов StringComparison.InvariantCulture
и StringComparison.InvariantCultureIgnoreCase. Хотя эти значения и позволяют выполнить лингвистически корректное сравнение, применение их для сравнения строк
в программе занимает больше времени, чем с флагом StringComparison.Ordinal
или StringComparison.OrdinalIgnoreCase. Кроме того, игнорирование региональных
стандартов — совсем неудачный выбор для сортировки строк, которые планируется
показывать пользователю.

ToUpperInvariant ToLowerInvariant



сравнение строк с учетом региональных стандартов стр 367 - clr via c#


при сравнении 2х строк сначала проверяется их длина, если разная то строки разные
НО если сравнивать с учетом региональных стандартов то строки разной длины могут быть одинаковыми


#интернирование
по дефолту интернирование отключено
При инициализации CLR создает внутреннюю хеш-таблицу, в которой ключами
являются строки, а значениями — ссылки на строковые объекты в управляемой
куче. Вначале таблица, разумеется, пуста. В классе String есть два метода, предоставляющие доступ к внутренней хеш-таблице:
public static String Intern(String str);
public static String IsInterned(String str);
#Intern, ищет String во внутренней хеш-таблице. Если строка
обнаруживается, возвращается ссылка на соответствующий объект String. Иначе
создается копия строки, она добавляется во внутреннюю хеш-таблицу, и возвращается ссылка на копию. Если приложение больше не удерживает ссылку на исходный объект String, уборщик мусора вправе освободить память, занимаемую этой
строкой. Обратите внимание, что уборщик мусора не вправе освободить строки, на
которые ссылается внутренняя хеш-таблица, поскольку в ней самой есть ссылки
на эти String. Объекты String, на которые ссылается внутренняя хеш-таблица,
нельзя освободить, пока не выгружен соответствующий домен приложения или
не закрыт поток.
#IsInterned - не вставляет в таблицу



пулы строк
//TODO надо понять чем отличается от интернирования
При обработке исходного кода компилятор должен каждую литеральную строку
поместить в метаданные управляемого модуля. Если одна строка встречается
в исходном коде много раз, размещение всех таких строк в метаданных приведет
к увеличению размера результирующего файла.
Чтобы не допустить роста объема кода, многие компиляторы (в том числе C#)
хранят литеральную строку в метаданных модуля только в одном экземпляре. Все
упоминания этой строки в исходном коде компилятор заменяет ссылками на ее
экземпляр в метаданных. Благодаря этому заметно уменьшается размер модуля. 




Insert, Remove, PadLeft, Replace,
Split, Join, ToLower, ToUpper, Trim, Concat, Format
ToString - return this
Substring - вернуть кусок
CopyTo - скопировать в массив
Copy - полностью новая строка, другой объект
Clone - ссылка на тотже объект


#stringBuilder
основан на внутреннем массиве
ToString выполяется быстро и если получить им строку, потом изменить что то в самом объекте то строка не изменится

у него есть емкость - длина массива
по дефолту-16
если массив начинает выходить за емкость то емкость удваивается и в новый массив происходит копирование


через свойство индексатор Chars можно получить доступ к массиву




есть интерфейс #IFormattable
там есть ToString с форматированием
В FCL у всех базовых типов (Byte, SByte, Int16/UInt16, Int32/UInt32, Int64/
UInt64, Single, Double, Decimal и DateTime) есть реализации этого интерфейса
String s = price.ToString("C", new CultureInfo("vi-VN"));


Чтобы расширить стандартное форматирование объекта, нужно добавить внутрь
фигурных скобок строку форматирования. В частности, следующий код отличается от предыдущего только наличием строк форматирования для подставляемых
параметров 0 и 2:
String s = String.Format("On {0:D}, {1} is {2:E} years old.",
 new DateTime(2012, 4, 22, 14, 35, 5), "Aidan", 9);


создание собственного средства форматирования
стр 386 - clr via c#

Защищенные строки
и в FCL безопасный строковый класс System.
Security.SecureString\неуправляемая память, уборщик мусора ничего про нее не знает, нужно вызывать dispose
содержимое шифруется
есть "уязвимости"







#enum
Color[] colors = (Color[]) Enum.GetValues(typeof(Color));
Console.WriteLine("Number of symbols defined: " + colors.Length);
Console.WriteLine("Value\tSymbol\n-----\t------");
foreach (Color c in colors) {
 // Выводим каждый идентификатор в десятичном и общем форматах
 Console.WriteLine("{0,5:D}\t{0:G}", c);
}


#IsDefined
public void SetColor(Color c) {
 if (!Enum.IsDefined(typeof(Color), c)) {
throw(new ArgumentOutOfRangeException("c", c, "Invalid Color value."));
 }

это проверка что бы не было такого SetColor((Color) 999999999);



перечисления можно объединять через |
но не все а только битовые и помеченные атрибутом #Flags
размещаться должны определенным образом

[Flags, Serializable]
public enum FileAttributes {
 ReadOnly = 0x0001,
 Hidden = 0x0002,
 System = 0x0004,
 Directory = 0x0010,
 Archive = 0x0020,
 Device = 0x0040,
 Normal = 0x0080,
 Temporary = 0x0100,
 SparseFile = 0x0200,
 ReparsePoint = 0x0400,
 Compressed = 0x0800,
 Offline = 0x1000,
 NotContentIndexed = 0x2000,
 Encrypted = 0x4000
//можно прям так объявлять внутри
//ReadWrite = Actions.Read | Actions.Write,
}

Actions actions = Actions.Read | Actions.Delete; // 0x0005
Console.WriteLine(actions.ToString()); // "Read, Delete"






#array
приведение типов
// Создание двухмерного массива FileStream
FileStream[,] fs2dim = new FileStream[5, 10];
// Неявное приведение к массиву типа Object
Object[,] o2dim = fs2dim;
// Невозможно приведение двухмерного массива к одномерному
// Ошибка компиляции CS0030: невозможно преобразовать тип 'object[*,*]'
// в 'System.IO.Stream[]'
Stream[] s1dim = (Stream[]) o2dim;
// Явное приведение к двухмерному массиву Stream
Stream[,] s2dim = (Stream[,]) o2dim;
// Явное приведение к двухмерному массиву String
// Компилируется, но во время выполнения
// возникает исключение InvalidCastException
String[,] st2dim = (String[,]) o2dim;
// Создание одномерного массива Int32 (значимый тип)
Int32[] i1dim = new Int32[5];
// Невозможно приведение массива значимого типа
// Ошибка компиляции CS0030: невозможно преобразовать
// тип 'int[]' в 'object[]'
Object[] o1dim = (Object[]) i1dim;
// Создание нового массива и приведение элементов к нужному типу
// при помощи метода Array.Copy
// Создаем массив ссылок на упакованные элементы типа Int32
Object[] ob1dim = new Object[i1dim.Length];
Array.Copy(i1dim, ob1dim, i1dim.Length);




Array.Copy не просто копирует элементы одного массива в другой. 
Метод Copy выполняет
следующие действия:
-Упаковка элементов значимого типа в элементы ссылочного типа, например
копирование Int32[] в Object[].
-Распаковка элементов ссылочного типа в элементы значимого типа, например
копирование Object[] в Int32[]
-Расширение (widening) примитивных значимых типов, например копирование
Int32[] в Double[].
-Понижающее приведение в случаях, когда совместимость массивов невозможно
определить по их типам. Сюда относится, к примеру, приведение массива типа
Object[] в массив типа IFormattable[]. Если все объекты в массиве Object[]
реализуют интерфейс IFormattable[], приведение пройдет успешно


#ковариантность
работает не быстро
String[] sa = new String[100];
Object[] oa = sa; // oa ссылается на массив элементов типа String
oa[5] = "Jeff"; // CLR проверяет принадлежность oa к типу String;
 // Проверка проходит успешно
oa[3] = 5; // CLR проверяет принадлежность oa к типу Int32;
 // Генерируется исключение ArrayTypeMismatchException




#array
FileStream[] fsArray;
можно засунуть в
void M1(IList<FileStream> fsList) { ... }
void M2(ICollection<Stream> sCollection) { ... }
void M3(IEnumerable<Object> oEnumerable) { ... }


если метод возвращает private массив или лист то внешний код сможет его редачить!!!!!
для фикса вернуть копию
 Array.Copy - поверхностное копирование


Массивы с ненулевой нижней границей
Создавать их можно при помощи статического метода CreateInstance типа Array
 // Требуется двухмерный массив [2005..2009][1..4]
 Int32[] lowerBounds = { 2005, 1 };
Int32[] lengths = { 5, 4 };
 Decimal[,] quarterlyRevenue = (Decimal[,])
 Array.CreateInstance(typeof(Decimal), lengths, lowerBounds);



Если производительность для вас критична, управляемый массив можно вместо
кучи разместить в стеке потока. Для этого вам потребуется инструкция stackalloc
Она позволяет создавать одномерные массивы элементов значимого типа с нулевой нижней
границей. При этом значимый тип не должен содержать никаких полей ссылочного
типа. По сути, вы выделяете блок памяти, с которым можно работать при помощи небезопасных указателей, поэтому адрес этого буфера нельзя передавать большинству
FCL-методов. Выделенная в стеке память (массив) автоматически освобождается
после завершения метода. Именно за счет этого и достигается выигрыш в производительности. При этом для компилятора C# должен быть задан параметр /unsafe
clr via c# стр 433




#вариантность
поддерживается только с ссылочными типами!





Метод #GetInvocationList работает с объектами классов, производных от
MulticastDelegate. Он возвращает массив ссылок, каждая из которых указывает
на какой-то делегат в цепочке. По сути, этот метод создает массив и инициализирует его элементы ссылками на соответствующие делегаты; в конце возвращается
ссылка на этот массив. Если поле _invocationList содержит null, возвращаемый
массив будет содержать всего один элемент, ссылающийся на единственного делегата в цепочке — экземпляр самого делегата

public abstract class MulticastDelegate : Delegate {
 // Создает массив, каждый элемент которого ссылается
 // на делегата в цепочке
 public sealed override Delegate[] GetInvocationList();
}







#func
можно явно указать типы
Func<Int32, String> f2 = (Int32 n) => n.ToString();





#attr
у атрибутов может быть префикс
[assembly: SomeAttr] // Применяется к сборке
[module: SomeAttr] // Применяется к модулю
[type: SomeAttr] // Применяется к типу - компилятор может определить сам
[field: SomeAttr] // Применяется к полю - компилятор может определить сам
[return: SomeAttr] // Применяется к возвращаемому значению
 [method: SomeAttr] // Применяется к методу- компилятор может определить сам
 [param: SomeAttr] // Применяется к параметру- компилятор может определить сам
 [property: SomeAttr] // Применяется к свойству- компилятор может определить сам
[method: SomeAttr] // Применяется к механизму доступа get- компилятор может определить сам
 [event: SomeAttr] // Применяется к событиям- компилятор может определить сам
 [field: SomeAttr] // Применяется к полям, созданным компилятором
 [method: SomeAttr] // Применяется к созданным
 // компилятором методам add и remov


можно применить атрибут к атрибуту, тк атрибут просто класс


так нельзя
[Flags][Flags]
internal enum Color {

но
Однако есть и атрибуты, многократное применение которых оправдано — в FCL
это класс атрибутов ConditionalAttribute. Для этого параметру AllowMultiple
должно быть присвоено значение true. В противном случае многократное применение атрибута невозможно.
Свойство Inherited класса AttributeUsageAttribute указывает, будет ли
атрибут, применяемый к базовому классу, применяться также к производным
классам и переопределенным методам






474 страница - надо записать










































