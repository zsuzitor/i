






#xml

запрещены некоторые символы(для хранения в тегах), их надо менять на специальные последовательности

такой штуки лучше избегать
<tag>
<![CDATA[вот тут можно писать что угодно с любыми символами(кроме последовательности символов "]]") и все будет интерпретироваться как строка]]</tag>
внутри тега не может быть тега CDATA


xml документ должен в самом начале содержать тег
<?xml .... >

в документе должен быть только 1 корневой документ
все элементы должны иметь закрывающий тег или быть пустым(самозакрывающийся-- <tag/>)
xml чувствителен к регистру языка
атрибуты должны быть помещены в кавычки(или одинарные или двойные)
<tag attr="123"/>
<tag attr='123'/>


#namespace

<maintag
xml:b="http...."
xml:c="http...."
xml="http...."
>
<b:tag></b:tag>
<c:tag></c:tag>
<-->если тут указать тег без префикса неймспейса и есть нейспейс без тега то все что без тега войдет в него<-->
</maintag>




#xmlreader

будет идти прям по порядку находя(сверху вниз идя вглубь) и пробелы+закрывающие теги тоже 

var reader=XmlReader.Create("a.xml");
while(reader.Read()){
//reader.NodeType
//reader.Name
//reader.Value
}

reader много разных методов

#xmlWritter
xmlWritter.WriteStartElement("CD",ns);

типы элемента можно посмотреть тут #XmlNodeType.

//!!закрывающие теги прописываются отдельно независимот от тега который надо закрыть
xmlWritter.WriteEndElement();


#xlinq #xmllinq

var xml = new XElement("nameTag",new XElement("childTag","value",new XAttribute("type","valattr")));



var ns = XNamespace.Get("namespace");


#XmlConvert - конвертит по правилам xml









































linq to xml
var data = (new XElement("Orders",
                from x1 in listForConvert
                select new XElement("Order",
                    new XAttribute("OrderID", x1.OrderID),
                    new XElement("CustomerID", x1.CustomerID),
                    new XElement("EmployeeID", x1.EmployeeID),

using (MemoryStream ms = new MemoryStream())
            {
                data.Save(ms);
                return ms.ToArray();
            }



<?xml version="1.0" encoding="utf-8"?>
<MainElement>
  <Orders>
    <Order OrderID="5">
      <CustomerID />
      <EmployeeID />
      <OrderDate>2020-02-20T07:25:55.47</OrderDate>
      <RequiredDate>2020-02-20T07:25:55.473</RequiredDate>
      <ShippedDate>2020-02-20T07:25:55.473</ShippedDate>
      <ShipVia />
    </Order>
  </Orders>
</MainElement>



string xml = Encoding.UTF8.GetString(responseData);
            string _byteOrderMarkUtf8 = Encoding.UTF8.GetString(Encoding.UTF8.GetPreamble());
            if (xml.StartsWith(_byteOrderMarkUtf8))
            {
                xml = xml.Remove(0, _byteOrderMarkUtf8.Length);
            }

            var x = XElement.Parse(xml);
//////если в xml есть namespace (атрибут xmlns)  :<catalog xmlns="http://library.by/catalog"
//то его надо указывать для доступа к каждому элементу
//получаем его
var nm = x.GetDefaultNamespace();
XNamespace nm = "http://library.by/catalog";
//используем
var g_=x.Elements(nm+"book");
если у чайлд элеемнтов не задать неймспейс но задать у родительского, то у всех чайлд будет явно добавлен неймспейс но в виде пустой строки
///////
if ( x.Element("Orders") != null)//это проверка не самого внешнего элемента а того что в нем-- см пример xml
                    {
                        var notificationList = x.Element("Orders")
                            .Elements("Order")
                            .Select(e =>
                            {
                                var g_2=e.Element("CustomerID").Value;
                                return new Orders();
                            })
                                .ToList();
                    }



#error
"Data at the root level is invalid" жалуется на 1 строку 1 позицию

string _byteOrderMarkUtf8 = Encoding.UTF8.GetString(Encoding.UTF8.GetPreamble());
if (xml.StartsWith(_byteOrderMarkUtf8))
{
    xml = xml.Remove(0, _byteOrderMarkUtf8.Length);
}

можно еще так сравнивать xmlStartsWith(byteOrderMarkUtf8, StringComparison.Ordinal

xml.LoadXml(myString.Substring(myString.IndexOf(Environment.NewLine)));


