



#regexp #regex #регулярки #регулярные #выражения

//спецсимволы которые надо экранировать символом \
Можно экранировать целую последовательность символов, заключив её между \Q и \E
[ ] \ / ^ $ . | ? * + ( ) { }

. - 1 любой символ но в некоторых реализациях исключая символ новой строки. Вместо символа . можно использовать [\s\S] (все пробельные и непробельные символы, включая символ новой строки)

////////Набор символов в квадратных скобках [ ] именуется символьным классом и позволяет указать интерпретатору регулярных выражений, что на данном месте в строке может стоять один из перечисленных символов.
[abd] - 1 из символов в скобках можно описать через (|)
[А-Яа-я] соответствует всем буквам русского алфавита, за исключением букв «Ё» и «ё»
^ в квадратных скобках  -символы, которые не входят в указанный набор.  [^0-9] означает любой символ, кроме цифр.

\d	[0-9]	Цифровой символ
\D	[^0-9]	Нецифровой символ
\s	[ \f\n\r\t\v]	Пробельный символ
\S	[^ \f\n\r\t\v]	Непробельный символ
\w	[[:word:]]	Буквенный или цифровой символ или знак подчёркивания
\W	[^[:word:]]	Любой символ, кроме буквенного или цифрового символа или знака подчёркивания


^	Начало текста (или строки при модификаторе ?m)	^a	Aaa aaa
$	Конец текста (или строки при модификаторе ?m)	a$	aaa aaA
\b	Граница слова	a\b	aaA aaA
			\ba	Aaa Aaa
\B	Не граница слова	\Ba\B	aAa aAa
\G	Предыдущий успешный поиск	\Ga	AAA aaa (поиск остановился на 4-й позиции — там, где не нашлось a)


() - Круглые скобки используются для определения области действия и приоритета операций. Шаблон внутри группы обрабатывается как единое целое и может быть квантифицирован

| - допустимые варианты - a|b -найдет a и b
gray|grey  === gr(a|e)y ===(можно и так)gr[ae]y




?	Ноль или одно	{0,1}	colou?r	color, colour
*	Ноль или более	{0,}	colou*r	color, colour, colouur и т. д.
+	Одно или более	{1,}	colou+r	colour, colouur и т. д. (но не color)
{n}	Ровно n раз	colou{3}r	colouuur
{m,n}	От m до n включительно	colou{2,4}r	colouur, colouuur, colouuuur
{m,}	Не менее m	colou{2,}r	colouur, colouuur, colouuuur и т. д.
{,n}	Не более n	colou{,3}r	color, colour, colouur, colouuur


!!!
Жадная и ленивая квантификация
(<.*>) - с жадной выделит весь html тела

Жадный	Ленивый
*	*?
+	+?
{n,}	{n,}?

#TODO
ab(xa)*+a	abxaabxaa; но не abxaabxaa, так как буква a уже занята
Жадный	Ревнивый
*	*+
?	?+
+	++
{n,}	{n,}+




А(?#тут комментарий)Б соответствует строке АБ


Флаги указываются после регулярного выражения (порядок флагов значения не имеет) /[0-9]$/m
g — глобальный поиск (обрабатываются все совпадения с шаблоном поиска).
i — регистр букв не имеет значения;
m — многострочный поиск.
s — текст трактуется как одна строка, в этом случае метасимволу . (точка) соответствует любой одиночный символ, включая символ новой строки;
u — unicode трактовка. Выражение может содержать специальные паттерны, характерные для уникода, `/\p{Lu}/ - заглавные буквы` например.






можно искать не создавая объект
Regex.Matches((string)sentence, (string)pattern)


//поиск вхождений всех
string pattern = @"\b\w+es\b";
      Regex rgx = new Regex(pattern);
      string sentence = "Who writes these notes?";
      
//можно указать с какой позиции начать поиск --rgx.Matches(sentence, match.Index + match.Length)  
      foreach (Match match in rgx.Matches(sentence))
         Console.WriteLine("Found '{0}' at position {1}", 
                           match.Value, match.Index);


//поиск вхождений по порядку
Match match = regex.Match(input);
while (match.Success) {
      // Handle match here...

      match = match.NextMatch();




js
''.replace(/\[/g,'<');//регулярка без кавычек



var str = '<h1>Привет, мир!</h1>';
var reg = /<(.*?)>/;
alert( str.match(reg) );

//найти все вхождения
while ((match = reg.exec(str)) !== null) {
  alert(match);









foreach (Match match in Regex.Matches(input, pattern, 
                                            RegexOptions.IgnoreCase))


var reg=new Regex($@"<\s*{tag}.*+{prop}.*+>", RegexOptions.IgnoreCase);//gi//| RegexOptions.Multiline
            return reg.Matches(html).Select(x1=>x1.Value).ToList();


#GROUP #группы
 var reg=new Regex($@"<\s*{tag}.*?{prop}.*?""(.*?)"".*?>", RegexOptions.IgnoreCase);//gi//| RegexOptions.Multiline
            return reg.Matches(html).Select(x1=>x1.Groups[0].Value).ToList();
группа '0' указывает на все вхождение, по факту нумерация начинается с '1'







