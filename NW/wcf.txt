

#wcf
если есть несколько серверов\приложений и их надо связать, данные в приложении А должны быть из приложения Б например
использует @soa

связанность бывает 2х видов:
-приложение с приложением
-приложение с предпиятием

используется soap-> xml для приведения всех запросов\ответов к общему виду


//#ServiceContract - не наследуется, если наследуем интерфейс от интерфейса его надо указать для каждого

//контракт--# , объявляется и на хосте и на клиенте
[ServiceContract]
interface IContract
{
[OperationContract]//атрибут для методов к которым можно будет обращаться удаленно -- #OperationContract
//[OperationContract(Name="")]--можем переопределить имя-- в случае перегрузки метода надо задавать разные имена
//если мы изменяем имена то мы меняем имя на 1 стороне(клиент или сервер) а на другой мы САМ метод так должны назвать
void Say(string input);//может возвращать значения
}
//реализовать интерфейс
Service:IContract

#uri=url+urn
#url-уникальный указатель ресположения ресурса
#urn-уникальный указатель имени ресурса (название сервиса в данном случае)

насколько понял если задать адрес для связи "net.tcp://local.../IContract" то можно общаться через tcp

#abc
adress
binding
contract


//создание хоста
Uri adress=new Uri("http://local.../IContract");
BasicHttpBinding binding = new BasicHttpBinding();
Type contract = typeof(IContract);
//вот этот класс будет создан при получении запроса, вызваны нужные методы, и отправлен результат
ServiceHost host=new ServiceHost(typeof(Service));
host.AddServiceEndpoint(contract,binding,address);
//host.AddServiceEndpoint(contract2,binding2,address2);//можем подключить не только 1, и тогда можем на клиенте конектиться к разным указывая разный интерфейс... в таком случае надо для каждого задать разные порты
host.open();
//можно закрыть подключение, в таком случае сервис вообще перестанет принимать запросы
host.Close();

//создание клиента
Uri adress=new Uri("http://local.../IContract");
BasicHttpBinding binding = new BasicHttpBinding();
EndpointAdress endpoint = new EndpointAdress(adress);
ChannelFactory<IContact> factory = new ChannelFactory<IContract>(binding,endpoint);
//паттерн прокси- посол
IContract channel=factory.CreateChannel();

//все что выше для клиента можно переписать так
//IInterface channel = ChannelFactory<IInterface>.CreateChannel(new BasicHttpBinding(),new EndpointAdress("http://.."))
//using(channel as IDisposable){
//тут все как при обычном способе создания}

//все вот такие вызовы будут отправлять лист xml в специальном формате
channel.Say("sends string");//#rpc - удаленный вызов процедур, мы просто используем интерфейс но на самом дела отправляются запросы


подходы:
1- независимая модификация
можно включать и отключать сервисы, не останавливая системы
2- асинхронный однонаправленный обмен сообщениями
это что то проде отсутствия сокетов, => сервер не может инициировать общение с клиентом
3- алптформенная консолидация
4- безопасность
5- надежность
не более 1 раза
хотя бы 1 раз
по порядку
6- поддержка транзакций
7- сетевое взаимодействие
8- производительность
9- расширяемость
можно создать: 
свой протокол(myhttp)
каналы
привязки
кодировки
аритектурные парадигмы
10- возможность конфигурирования
