записать 
надо
https://metanit.com/sharp/tutorial/9.2.php
https://metanit.com/sharp/tutorial/11.2.php  +дальше все про потоки
 https://metanit.com/sharp/tutorial/12.2.php +дальше все про task
https://metanit.com/sharp/tutorial/13.4.php   обработка исключений
https://metanit.com/sharp/tutorial/13.6.php
https://metanit.com/sharp/tutorial/14.2.php  вся глава про рефлексию даже не читал
https://metanit.com/sharp/tutorial/15.1.php   тут все методы linq надо бы записать + дальше
https://metanit.com/sharp/tutorial/16.2.php   xml
так

https://metanit.com/sharp/tutorial/7.4.php
https://metanit.com/sharp/tutorial/18.1.php  процессы


https://metanit.com/sharp/tutorial/7.5.php




#TODO
при отрисовке формы генерится токен и при отправки формы он проверяется на серве уже, так можно исключить отправку запроса пользователя без отрисовки страницы
@Html.AntiForgeryToken()


ToFrequency -?
FrornFrequency -?


#TODO

#PredicateBuilder.False<Foo>(); #where #linq #or #Predicate



AppDomain.CurrentDomain.BaseDirectory

ar a=(RolesProject)Enum.Parse(typeof(RolesProject), "", true);

#for #html
<label><input type="checkbox">Some text</label>





скорее всего треугольники с закругленными концами
div - before-font-size: 225px; content: "\E90E";



System.Numerics. #Complex.







#Layout = null;





#TypeDescriptor
val- eventArgs - мб только для событий
foreach(var i in TypeDescriptor.GetProperties(val)){

i.DisplayName();
i.GetValue();

}







#full text search
если не обновляется индекс
//пытаемся достроить недостающие записи
--ALTER FULLTEXT INDEX on FETexts START UPDATE POPULATION; 

--отключить автоматическое отслеживание 
--ALTER FULLTEXT INDEX ON FETexts SET CHANGE_TRACKING MANUAL;
//полностью перестраиваем
ALTER FULLTEXT INDEX ON FETexts START FULL POPULATION; 







#iis #https #ssl

C:\Users\zsuz\Documents\IISExpress\
включение iis manager  https://www.youtube.com/watch?v=kLhhvCE2IZg
панель управления-> удаление программ->слева "включение или отключение компонентов windows"-> найти "internet information services (Службы IIS)" и включить то что нужно
Убедитесь, что вы выбрали поддержку ASP.NET. Для этого раскройте узел Службы Интернета --> Компоненты разработки приложений --> ASP.NET (Internet Information Services --> World Wide Web Services --> Application Development Features --> ASP.NET):
Если вы хотите использовать поддержку IIS в Visual Studio, которая позволяет вам создавать виртуальные каталоги IIS непосредственно в диалоговом окне New Web Site, вам нужно выбрать пункт «Совместимость управления IIS 6» в разделе «Средства управления веб-сайтом» (Web Management Tools --> IIS 6 Management Compatibility).


Нажмите клавишу Windows и введите "Свойства Windows", выберите первую запись. Включите или выключите функции Windows.
IIS #manager #диспетчер #служб должен вернуться в Панель управления >\Все элементы панели управления\> Администрирование

https://docs.microsoft.com/en-us/iis/manage/configuring-security/how-to-set-up-ssl-on-iis

иконка в центре сертификаты сервера
создать самоподписанный,  
сайт слева выбрал дефолтный
для этого сайта справа bindings
добавить, имя не указывать , выбрать сертификат, указать https


в проекте visual
нажать на название проекта в solution explorer? снизу появятся настройки\свойства(properties) там включить ssl
проект(сверху)->свойства там базовую страницу поменять на ту которая отрисовалась в предыдущем пункте в строке https 





#professorweb #диспетчер #служб #iis #certificate #sertificate
http://professorweb.ru/my/ASP_NET/sites/level3/3_1.php





































#clr
#CLR/#CTS - это всечто может clr-100% функционала
языки которые построены на clr используют только часть функционала, и каждый разную часть
#CLS - это функционал(часть clr)(тимы методы и тд) которые обязан реализовывать язык из clr
// Приказываем компилятору проверять код
// на совместимость с CLS
[assembly: CLSCompliant(true)]

namespace SomeLibrary { 

псевдонимы типов(например long) на самом деле в fcl называются system.Int64 и тд, не все типы поддерживаются fcl
стр 143 clr via c#
сборка с отложенным подписанием - стр 108 clr via c#

сборка с строгим именем TODO




Оператор #new выполняет следующие действия
1. Вычисление количества байтов, необходимых для хранения всех экземплярных полей типа и всех его базовых типов, включая System.Object (в котором
отсутствуют собственные экземплярные поля). Кроме того, в каждом объекте
кучи должны присутствовать дополнительные члены, называемые указателем
на объект-тип (type object pointer) и индексом блока синхронизации (sync block
index); они необходимы CLR для управления объектом. Байты этих дополнительных членов добавляются к байтам, необходимым для размещения самого
объекта.
2. Выделение памяти для объекта с резервированием необходимого для данного
типа количества байтов в управляемой куче. Выделенные байты инициализируются нулями (0).
3. Инициализация указателя на объект-тип и индекса блока синхронизации.
4. Вызов конструктора экземпляра типа с параметрами, указанными при вызове
new (в предыдущем примере это строка ConstructorParam1). Большинство
компиляторов автоматически включает в конструктор код вызова конструктора
базового класса. Каждый конструктор выполняет инициализацию определенных
в соответствующем типе полей. В частности, вызывается конструктор System.
Object, но он ничего не делает и просто возвращает управление.
Выполнив все эти операции, new возвращает ссылку (или указатель) на вновь
созданный объект. В предыдущем примере кода эта ссылка сохраняется в переменной e типа Employee.







можно изменить порядок полей объекта(то как будут храниться)
System.Runtime.InteropServices.StructLayoutAttribute.
Чтобы порядок полей устанавливался CLR, нужно передать конструктору атрибута параметр LayoutKind.Auto, чтобы сохранить установленный программистом порядок — параметр LayoutKind.Sequential, а параметр LayoutKind.
Explicit позволяет разместить поля в памяти, явно задав смещения. Если в описании типа не применен атрибут StructLayoutAttribute, порядок полей выберет
компилятор

Для ссылочных типов (классов) компилятор C# выбирает вариант LayoutKind.Auto,
 а для значимых типов (структур) — LayoutKind.Sequential
// Для повышения производительности разрешим CLR
// установить порядок полей для этого типа
[StructLayout(LayoutKind.Auto)]
internal struct SomeValType {
 private readonly Byte m_b; 





#il #ildasm.exe










#c#


#struct
при создании нового типа надо перегружать определенные ментоды, см "equals"
в структуре нельзя создать конструктор по умолчанию(он генерируется системой В ЛЮБОМ СЛУЧАЕ даже если мы определим другие, в отличии от класса)
если в конструкторе не инициализировать поля то комплятор НЕ сгенерирует им значения, а в классе сгенерирует
в структуре нельзя инициализировать переменные в месте их объявления
в структуре можно засунуть индексатор и статик конструктор
не ссылочный тип данных
не наследуется от класса и от структур и не может быть родителем для них, но может от интерфейса
нельзя определять деструкторы
члены структуры нельзя указывать как abstract virtual protected
объект может быть создан через new(но может и без него)
struct b{}
b perem;perem.val=10;//не вызывая конструктор

 #ValueType
при создании нового типа надо перегружать определенные ментоды, см "equals"
Все структуры являются прямыми потомками абстрактного типа System.ValueType,
 который, в свою очередь, является производным от типа System.Object.
 По умолчанию все значимые типы должны быть производными от System.ValueType.
 Все перечисления являются производными от типа System.Enum, производного от System.ValueType.

При определении собственного значимого типа нельзя выбрать произвольный
базовый тип, однако значимый тип может реализовать один или несколько выбранных вами интерфейсов. Кроме того, в CLR значимый тип является изолированным,
то есть он не может служить базовым типом для какого-либо другого ссылочного
или значимого типа. 

System.ValueType переопределяет
метод Equals, который возвращает true, если значения полей в обоих объектах
совпадают. Кроме того, в System.ValueType переопределен метод GetHashCode,
который создает хеш-код по алгоритму, учитывающему значения полей экземпляра объекта. Из-за проблем с производительностью в реализации по умолчанию(рефлексия), определяя собственные значимые типы значений, надо переопределить
и написать свою реализацию методов Equals == и GetHashCode
см #equals






#class  
полностью хранится в куче(то что объявлено в классе тоже)
#constructor
если класс наследуется , при вызове конструктора вызывается сначала конструктор родителя(даже если не применили слово #base)
public class cl{
}
cl perem=new cl();
cl perem=new cl(){val=10};//#инициализация
//такая инициализация может быть более сложной и вложенной new cl(){val=new cl2(){valt=10;};}
cl perem=new cl{val=10};//вызывается конструктор без параметров это скомпилируется в тот же код если бы мы создали объект и дальше через точку проставляли бы свойства

x:y{
public x():base(){//передаем в конструктор y
в конструкторе нельзя вызывать метод экземпляра
this.method();//#TODO нельзя???
}
public x():this(){//передаем в другой конструктор x
}
}
В классе Subclass должны быть "повторно определены" любые конструкторы, которые необходимо открыть





В редких ситуациях экземпляр типа может создаваться без вызова конструктора экземпляров. В частности, метод MemberwiseClone объекта Object выделяет
память, инициализирует служебные поля объекта, а затем копирует байты исходного объекта в область памяти, выделенную для нового объекта. Кроме того,
конструктор обычно не вызывается при десериализации объекта. Код десериализации выделяет память для объекта без вызова конструктора, используя метод
GetUninitializedObject или GetSafeUninitializedObject типа System.Runtime.
Serialization.FormatterServices


Нельзя вызывать какие-либо виртуальные методы конструктора, которые могут
повлиять на создаваемый объект. Причина проста: если вызываемый виртуальный
метод переопределен в типе, экземпляр которого создается, происходит реализация производного типа, но к этому моменту еще не завершилась инициализация
всех полей в иерархии. В таких обстоятельствах последствия вызова виртуального
метода непредсказуемы

можно вот так написать, инициализация будет перенесена в начало всех! конструкторов компилятором
=> il код разрастется
internal sealed class SomeType {
 private Int32 m_x = 5; 
}


Конструктор экземпляра значимого типа выполняется только при явном вызове. Так что если конструктор объекта Rectangle не инициализировал его поля
m_topLeft и m_bottomRight вызовом с помощью оператора new конструктора Point,
поля m_x и m_y у обеих структур Point будут содержать 0.

 C# не позволяет определять для значимого типа конструкторы без параметров


internal struct SomeValType {
 // В значимый тип нельзя подставлять инициализацию экземплярных полей
 private Int32 m_x = 5;
}

 любой конструктор,
определенный для значимого типа, должен инициализировать все поля этого типа.
Следующий тип определяет конструктор для значимого типа, но не может инициализировать все его поля:
internal struct SomeValType {
 private Int32 m_x, m_y;
 // C# допускает наличие у значимых типов конструкторов с параметрами
 public SomeValType(Int32 x) {
 m_x = x;
// Обратите внимание: поле m_y здесь не инициализируется
 }
}
При компиляции этого типа компилятор C# генерирует сообщение об ошибке:
(ошибка CS0171: поле 'SomeValType.m_y' должно быть полностью определено до
возвращения управления конструктором):


для установки дефолтных значений можно заюзать абуз
// C# позволяет значимым типам иметь конструкторы с параметрами
public SomeValType(Int32 x) {
 // Выглядит необычно, но компилируется прекрасно,
 // и все поля инициализируются значениями 0 или null
 this = new SomeValType();
 m_x = x; // Присваивает m_x значение x
 // Обратите внимание, что поле m_y было инициализировано нулем
}




страница 223










???подкласс может иметь меньшую доступность, чем базовый класс, но не большую
public class TopLevel 
{ 
puЬlic class Nested { / / Вложенный класс 
public enum Color { Red, Blue, Tan } / / Вложенное  перечисление 
Вложенный тип
}
Он может получать доступ к закрытым членам включающего типа и ко всему остальному, к чему имеет доступ включающий тип.
• Он может быть объявлен с полным диапазоном модификаторов доступа, а не только public и internal.
• Стандартной доступностью вложенного типа является private, а не internal.
• Доступ к вложенному типу извне требует указания имени включающего типа (как при обращении к статическим членам).
Например, для доступа к члену Color.Red извне класса 
TopLevel необходимо записать так: 
TopLevel.Color color = TopLevel.Color.Red; 
Все типы могут быть вложенными, однако содержать вложенные типы могут только классы и структуры.



Любой совместимый метод экземпляра всегда будет иметь преимущество над расширяющим методом - даже когда параметры 
расширяющего метода дают более точное соответствие по типам.

правило более специфичных параметров TODO





#== #equals 
что бы проверить равенство ссылок надо юзать #ReferenceEquals
не нужно использовать == тк мы не можем точно знать перегружен ли этот оператор на сравнение по значению


при создании значимого типа надо обязательно перегрузить == Equals
тк по дефолту используется отражение и это медленно
Определяя собственный тип и приняв решение переопределить Equals, обеспечьте поддержку четырех характеристик, присущих равенству
-Рефлексивность: x.Equals(x) должно возвращать true.
-Симметричность: x.Equals(y) и y.Equals(x) должны возвращать одно и то же значение
-Транзитивность: если x.Equals(y) возвращает true и y.Equals(z) возвращает
true, то x.Equals(z) также должно возвращать true.
-Постоянство: если в двух сравниваемых значениях не произошло изменений,
результат сравнения тоже не должен измениться.
Отступление от этих правил при создании собственной реализации Equals
грозит непредсказуемым поведением приложения.
При переопределении метода Equals может потребоваться выполнить несколько
дополнительных операций.
-Реализовать в типе метод Equals интерфейса System.IEquatable<T>. Этот
обобщенный интерфейс позволяет определить безопасный в отношении типов
метод Equals. Обычно Equals реализуют так, что, принимая параметр типа
Object, код метода вызывает безопасный в отношении типов метод Equals.
-Перегрузить методы операторов == и !=. Обычно код реализации этих операторных методов вызывает безопасный в отношении типов метод Equals.



#TODO не особо понимаю что это 
Ранее я уже говорил о том, что компилятор C# на этапе выполнения программы генерирует код полезной нагрузки, основываясь на действительных
типах объекта. Этот код полезной нагрузки использует класс, известный как
компоновщик (runtime binder). Различные языки программирования определяют собственных компоновщиков, инкапсулируя в них правила языка

















#модификаторы #modificators

#virtual - для возможности переопределения в наследниках
#override - для переопределения чего либо

#sealed - если перед class то запретить наследование
если перед методом то только перед тем для которого должны были указать override - запретит переопределение через override,но метод будет унаследован
class Subclass1 : Base {
   public sealed override void Test() { ... }
}
class Subclass2 : Subclass1 {
   public override void Test() { ... } // Does not compile!
   // If `Subclass1.Test` was not sealed, it would've compiled correctly.
}



#static
если для класса то нельзя создавать экземпляры 
все что в классе должно быть помечено как static
для получения доступа к чему либо в нем className.Meth();






#readonly
только для чтения, можно задать в конструкторе или при объявлении

структуры гарантирующие свою неизменяемость
могут содержать только readonly-поля и get-свойства
public readonly struct ImmutableStruct





#const
только для чтения, константа, можно задать только при объявлении

Константы всегда связаны с типом,
а не с экземпляром типа, а на логическом уровне константы всегда являются
статическими членами

Константа (constant) — это идентификатор, значение которого никогда не меняется. Значение, связанное с именем константы, должно определяться во время
компиляции. Затем компилятор сохраняет значение константы в метаданных
модуля. Это значит, что константы можно определять только для таких типов,
которые компилятор считает примитивными. В C# следующие типы считаются
примитивными и могут использоваться для определения констант: Boolean, Char,
Byte, SByte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Decimal
и String.
можно объявить ссылочную константу если присвоить ей null


константы встраиваются сразу в il код(нет ссылок на саму константу, встраивается значение)
если констнта в другой сборке и константа изменена то надо перекомпилировать все сборки которые на нее ссылаются

что бы всего избежать этого можно юзать readonly




#volatile
значение поля может быть изменено параллельно выполняющимися потоками, значение не кешируется в потоках=> всегда будет актуальным

#extern
1-метод предоставляется внешним кодом
2- псевдоним для внешней сборки








#checked  #unchecked
исключения при переполнении
что из этого используется по умолчанию нельзя сказать тк зависит от компилятора
существует 2 формы
checked((byte)(int_1*int_2))
checked{(byte)(int_1*int_2)}







#case #switch

#goto case х (переход на другую конструкцию case); 
 goto defaul t
switch (num)
{ 
case 13: 
//если тут нет кода то можно пропустить break; и 2 case объединятся
case 12: 
break;

case 12 when(y<10): 
break;

case int val: 
break;

default:
break;

case null:
break;

}




public static RGBColor FromRainbow(Rainbow colorBand) =>
    colorBand switch
    {
        Rainbow.Red    => new RGBColor(0xFF, 0x00, 0x00),
        _              => throw new ArgumentException(message: "invalid enum value", paramName: nameof(colorBand)),
    };


public static string RockPaperScissors(string first, string second)
    => (first, second) switch
    {
        ("rock", "paper") => "rock is covered by paper. Paper wins.",
        ("rock", "scissors") => "rock breaks scissors. Rock wins.",
        (_, _) => "tie"
    };



#if #else







#get #set
нельзя просто объявить свойство в методе потому что само раскладывается на методы
можно в классе, интерфейсе
public int Response { get; }
public int Maximum { get; } = 999;
Свойство только для чтения public decimal Worth => currentPrice * sharesOwned;
указать для каждого ключевого слова отдельно уровень доступа нельзя
public int Response { get;private set; }//но то что в скобках может быть только более ограничивающим


public int Response { get{
return val;
}
set{
val=value;
} }


#types



#object
главный тип, от него наследуется все остальные

#упаковка #распаковка
в объект типа object можем упаковать объект любого другого типа, и распаковать обратно в тот же тип или в тип родителя того класса который упаковывали
object tt=new object();
a tta=new a();
a ttb=new b();
tt=ttb;
tta=(a)tt;
при упаковке ссылка object == той ссылке которую упаковали(если упаковывали ссылочный тип)

если упаковываем не ссылочный тип
создается объект
значение в объекте это копия!! исходного значения

при распаковке
значение по ссылке копируется, после распаковки нет связи ссылки с распакованным значением






#упаковка
При упаковке экземпляра значимого типа происходит следующее.
1. В управляемой куче выделяется память. Ее объем определяется длиной значимого типа и двумя дополнительными членами — указателем на типовой объект
и индексом блока синхронизации. Эти члены необходимы для всех объектов
в управляемой куче.
2. Поля значимого типа копируются в память, только что выделенную в куче.
3. Возвращается адрес объекта. Этот адрес является ссылкой на объект, то есть
значимый тип превращается в ссылочный.


#распаковка
При распаковке упакованного значимого типа происходит следующее.
1. Если переменная, содержащая ссылку на упакованный значимый тип, равна
null, генерируется исключение NullReferenceException.
2. Если ссылка указывает на объект, не являющийся упакованным значением
требуемого значимого типа, генерируется исключение InvalidCastException
нельзя распаковать int32 в int16, но можно сначала распаковать а потом явно привести тип


//#TODO это надо записать короче - страница 168
Хотя неупакованные значимые типы не имеют указателя на типовой объект, вы
все равно можете вызывать виртуальные методы (такие, как Equals, GetHashCode
или ToString), унаследованные или прееопределенные этим типом. Если ваш значимый тип переопределяет один из этих виртуальных методов, CLR может вызвать
метод невиртуально, потому что значимые типы неявно запечатываются и поэтому
не могут выступать базовыми классами других типов. Кроме того, экземпляр значимого типа, используемый для вызова виртуального метода, не упаковывается.
Но если ваше переопределение виртуального метода вызывает реализацию этого
метода из базового типа, экземпляр значимого типа упаковывается при вызове
реализации базового типа, чтобы в указателе this базового метода передавалась
ссылка на объект в куче.
Вместе с тем вызов невиртуального унаследованного метода (такого, как GetType
или MemberwiseClone) всегда требует упаковки значимого типа, так как эти методы
определены в System.Object, поэтому методы ожидают, что в аргументе this передается указатель на объект в куче.
Кроме того, приведение неупакованного экземпляра значимого типа к одному
из интерфейсов этого типа требует, чтобы экземпляр был упакован, так как интерфейсные переменные всегда должны содержать ссылку на объект в куче. 




internal struct Point : IComparable {
 private Int32 m_x, m_y;
 // Конструктор, просто инициализирующий поля
 public Point(Int32 x, Int32 y) {
 m_x = x;
 m_y = y;
 }
 // Переопределяем метод ToString, унаследованный от System.ValueType
 public override String ToString() {
 // Возвращаем Point как строку (вызов ToString предотвращает упаковку)
 return String.Format("({0}, {1})", m_x.ToString(), m_y.ToString());
 }
 // Безопасная в отношении типов реализация метода CompareTo
 public Int32 CompareTo(Point other) {
 // Используем теорему Пифагора для определения точки,
 // наиболее удаленной от начала координат (0, 0)
 return Math.Sign(Math.Sqrt(m_x * m_x + m_y * m_y)
 - Math.Sqrt(other.m_x * other.m_x + other.m_y * other.m_y));
 }
 // Реализация метода CompareTo интерфейса IComparable
 public Int32 CompareTo(Object o) {
 if (GetType() != o.GetType()) { 
throw new ArgumentException("o is not a Point");
 }
 // Вызов безопасного в отношении типов метода CompareTo
 return CompareTo((Point) o);
 }
}
public static class Program {
 public static void Main() {
 // Создаем в стеке два экземпляра Point
 Point p1 = new Point(10, 10);
 Point p2 = new Point(20, 20);
 // p1 НЕ пакуется для вызова ToString (виртуальный метод)
 Console.WriteLine(p1.ToString()); // "(10, 10)"
 // p1 ПАКУЕТСЯ для вызова GetType (невиртуальный метод)
 Console.WriteLine(p1.GetType()); // "Point"
 // p1 НЕ пакуется для вызова CompareTo
 // p2 НЕ пакуется, потому что вызван CompareTo(Point)
 Console.WriteLine(p1.CompareTo(p2)); // "-1"
 // p1 пакуется, а ссылка размещается в c
 IComparable c = p1;
 Console.WriteLine(c.GetType()); // "Point"
 // p1 НЕ пакуется для вызова CompareTo
 // Поскольку в CompareTo не передается переменная Point,
 // вызывается CompareTo(Object), которому нужна ссылка
 // на упакованный Point
 // c НЕ пакуется, потому что уже ссылается на упакованный Point
 Console.WriteLine(p1.CompareTo(c)); // "0"
 // c НЕ пакуется, потому что уже ссылается на упакованный Point
 // p2 ПАКУЕТСЯ, потому что вызывается CompareTo(Object)
 Console.WriteLine(c.CompareTo(p2));// "-1"
 // c пакуется, а поля копируются в p2
 p2 = (Point) c;
 // Убеждаемся, что поля скопированы в p2
 Console.WriteLine(p2.ToString());// "(10, 10)"


// p упаковывается, упакованный объект изменяется и освобождается
 ((IChangeBoxedPoint) p).Change(4, 4);
 Console.WriteLine(p);
 // Упакованный объект изменяется и выводится
 ((IChangeBoxedPoint) o).Change(5, 5);
 Console.WriteLine(o); 

 }
}


Вызов ToString
При вызове ToString упаковка p1 не требуется
 метод ToString переопределен в Point

Вызов GetType. При вызове невиртуального метода GetType упаковка p1 необходима, поскольку тип Point не реализует GetType, а наследует его от System.
Object

Первый вызов CompareTo. При первом вызове CompareTo упаковка p1 не нужна,
так как Point реализует метод CompareTo, и компилятор может просто вызвать его
напрямую. 

Приведение типа к IComparable. Когда выполняется приведение типа p1 к переменной интерфейсного типа (с), упаковка p1 необходима

Второй вызов CompareTo. При втором вызове CompareTo упаковка p1 не производится, потому что Point реализует метод CompareTo, и компилятор может
вызывать его напрямую.

Третий вызов CompareTo. При третьем вызове CompareTo переменная c уже
ссылается на упакованный объект Point в куче. Поскольку переменная c сама
по себе имеет интерфейсный тип IComparable, можно вызывать только метод
CompareTo интерфейса, а ему требуется параметр Object


Приведение типа к Point. Когда выполняется приведение c к типу Point, объект в куче, на который указывает c, распаковывается, и ег



















#enum

[:int]- тип перечисления
enum apple[:type]{val1,val2,val3,val4=10}
enum apple:int{val1,val2,val3,val4=10}
(int)apple.val1;//0
(int)apple.val4;//10

for(apple i=apple.val1;i<apple.val4&&(i)<20;++i)
console.writeline(i);//val1...

//#role
foreach (RolesProject roleName in (RolesProject[])Enum.GetValues(typeof(RolesProject)))
                var role = new IdentityRole { Name = roleName.ToString() };

парсим из строки
RolesProject role = (RolesProject)Enum.Parse(typeof(RolesProject), roleNameString, true);

BorderSide b = (BorderSide) 12345; //даже если в BorderSide нет такого числа
Console.WriteLine (b)//12345




Color[] colors = (Color[]) Enum.GetValues(typeof(Color));
Console.WriteLine("Number of symbols defined: " + colors.Length);
Console.WriteLine("Value\tSymbol\n-----\t------");
foreach (Color c in colors) {
 // Выводим каждый идентификатор в десятичном и общем форматах
 Console.WriteLine("{0,5:D}\t{0:G}", c);
}


#IsDefined
public void SetColor(Color c) {
 if (!Enum.IsDefined(typeof(Color), c)) {
throw(new ArgumentOutOfRangeException("c", c, "Invalid Color value."));
 }

это проверка что бы не было такого SetColor((Color) 999999999);



перечисления можно объединять через |
но не все а только битовые и помеченные атрибутом #Flags
размещаться должны определенным образом

[Flags, Serializable]
public enum FileAttributes {
 ReadOnly = 0x0001,
 Hidden = 0x0002,
 System = 0x0004,
 Directory = 0x0010,
 Archive = 0x0020,
 Device = 0x0040,
 Normal = 0x0080,
 Temporary = 0x0100,
 SparseFile = 0x0200,
 ReparsePoint = 0x0400,
 Compressed = 0x0800,
 Offline = 0x1000,
 NotContentIndexed = 0x2000,
 Encrypted = 0x4000
//можно прям так объявлять внутри
//ReadWrite = Actions.Read | Actions.Write,
}

Actions actions = Actions.Read | Actions.Delete; // 0x0005
Console.WriteLine(actions.ToString()); // "Read, Delete"




[Flags] 
public enum BorderSides 
{ 
None= O, 
Left=l, Right=2, Тор=4, Bottom=8, 
LeftRiqht = Left | Riqht, 
TopBottom = Тор | Bottom, 
All = LeftRiqht | TopBottom
}
BorderSides leftRight = BorderSides.Left | BorderSides.Right; 
if ((leftRight & BorderSides.Left) ! = О) 
Console.WriteLine ("Includes Left"); //Includes Left 
string formatted = leftRight.ToString() ;//"Left, Right" 
BorderSides s = BorderSides.Left; 
s |= BorderSides.Right; 
Console.WriteLine (s == leftRight); / / True

то что применяется к enum
+= -
! = < > <= >= + 
++ sizeof




#dynamic #dlr
#Динамическое #связывание противоположность #статического #связывания #статическое

DLR--dynamic language runtime
проверка типа откладывается до выполнения
Среде CLR о dynamic ничего не известно — любые
случаи использования dynamic в коде транслируются в тип object, к которому соответствующим образом применен атрибут #DynamicAttribute

dynamic val;
val="";

void meth(object o);
void meth(dynamic o);//перегрузить не получится, тк  dynamic считается object

typeof (dynamic) == typeof (object) //true

dynamic х = 2;
var у= х * 3; // Статическим типом у является dynamic 


можно "засунуть" в dynamic статику(вызов статических членов типа)
это не из коробки работает, можно написать -clr via c# стр 183


#IDynamicMetaObjectProvider #IDMOP #TODO
#Специальное связывание


Класс Duck в действительности не имеет метода Quack.
Вместо этого он использует специальное связывание для перехвата и интерпретации всех обращений к методам. 
puЬlic class Duck: DynamicObject
{
puЬlic override bool TryinvokeMember( InvokeMemЬerBinder binder, object[] args, out object result)
Console.WriteLine (binder.Name + "was called");
result = null;
return true; 
}
}
d.Quack(); // Выводит Quack was called
d.Waddle(); // Выводит Waddle was called



при вызове например метода которого нет(для обычного dynamic) выбросится исключение #RuntimeBinderException




#ExpandoObject
//такое
dynamic expando = new ExpandoObject();
IDictionary<string, object> dictionary = expando;
expando.First = "value set dynamically";
Console.WriteLine(dictionary["First"]);
dictionary["Second"] = "value set with dictionary";
Console.WriteLine(expando.Second);
//
dynamic expando = new ExpandoObject();
expando.AddOne = (Func<int, int>) (x => x + 1);
Console.Write(expando.AddOne(10));


dynamic e = new System.Dynamic.ExpandoObject();
e.x = 6; // Добавление свойства 'x' типа Int32 // со значением 6
e.z = null; // Добавление свойста 'z' объекта // со значением null
// Просмотр всех свойств и других значений
foreach (var v in (IDictionary<String, Object>)e)
Console.WriteLine("Key={0}, V={1}", v.Key, v.Value);
// Удаление свойства 'x' и его значения
var d = (IDictionary<String, Object>)e;
d.Remove("x");







статическое- #TODO
В простейшем случае компилятор осуществляет связывание за счет поиска в типе метода который необходимо вызвать с указанными параметрами.
Если не найдено то компилятор распространяет поиск на методы, принимающие необязательные параметры,
методы базовых классов  и расширяющие методы, которые принимают этот тип в своем первом параметре. Если ничего из этого
не найдено, возникает ошибка компиляции. Независимо от того,
к какому методу произведено связывание, суть в том, что связывание делается компилятором, и оно полностью зависит от 
статических сведений о типах операндов (в данном случае d). Именно
поэтому такой процесс называется статическим связыванием.













#Single представляет тип #float



#decimal
static Add
static Divide
static Myltiply
static Negate
static MaxValue
#TODO M







#double


const -
Epsilon


double.Negativeinfinity
double.NaN
#NaN
Not а Number - не число
+оо, -оо и -0



Console.WriteLine ( 1.0 /О.О);// Бесконечность 
Console.WriteLine (-1.0 /О.О);// Минус бесконечность 
Console.WriteLine ( 1.0 / -0.0); // Минус бесконечность 
Console.WriteLine (- 1.0 / -0.0); // Бесконечность
Console.Write (О.О/ О.О); //NaN
Console.Write ( (1.0 / О.О) - (1.0 /О.О)); //NaN

NaN==NaN;//false
object.Equals (0.0/0.0, double.NaN);//true
для проверки на NaN
(fload|double).IsNaN();







#int














#array
Char[]off=new Char[]{a,s}
Char[]off={a,s}
Int[,]cf={{0,3},{}}
char [] vowels = {'а', 'е', 'i', 'о', 'u'};
int[][] matrix = 
{ 
new int [] {О, 1, 2}, 
new int [] { 3, 4, 5} }
new []{1,2 }


класс System.Array, базовый для всех типов массивов, поддерживает множество статических обобщенных методов, в том числе
AsReadOnly, BinarySearch, ConvertAll, Exists, Find, FindAll, FindIndex, FindLast,
FindLastIndex, ForEach, IndexOf, LastIndexOf, Resize, Sort и TrueForAll



длина массива #Length 
размерность массива #Rank
#Createinstance динамическое создание массива
#GetValue #SetValue извлечение и установка элементов независимо от типа массива????
#GetLength
matrix.GetLength(0); //Метод GetLength массива возвращает длину для заданного измерения (начиная с 0):

System.Array.#CopyTo-- глубокое копирование
#clone-- поверхностное копирование



см также -collection
IsFixedSize - если фиксированного размера
IsSynchronized - если можно использовать в многопоточной среде
Rank - размерность массива
SyncRoot - объект для синхронизации доступа к массиву

если отсортированный и одномерный то
BinarySearch поиск эелемента по применению как IndexOf
IndexOf
Clear -очищает, размер остается
Clone - не полная копия(если внутри ссылки то будут ссылаться на теже элементы)
Find...
ForEach
GetValue
Reverse
Exist






приведение типов
// Создание двухмерного массива FileStream
FileStream[,] fs2dim = new FileStream[5, 10];
// Неявное приведение к массиву типа Object
Object[,] o2dim = fs2dim;
// Невозможно приведение двухмерного массива к одномерному
// Ошибка компиляции CS0030: невозможно преобразовать тип 'object[*,*]'
// в 'System.IO.Stream[]'
Stream[] s1dim = (Stream[]) o2dim;
// Явное приведение к двухмерному массиву Stream
Stream[,] s2dim = (Stream[,]) o2dim;
// Явное приведение к двухмерному массиву String
// Компилируется, но во время выполнения
// возникает исключение InvalidCastException
String[,] st2dim = (String[,]) o2dim;
// Создание одномерного массива Int32 (значимый тип)
Int32[] i1dim = new Int32[5];
// Невозможно приведение массива значимого типа
// Ошибка компиляции CS0030: невозможно преобразовать
// тип 'int[]' в 'object[]'
Object[] o1dim = (Object[]) i1dim;
// Создание нового массива и приведение элементов к нужному типу
// при помощи метода Array.Copy
// Создаем массив ссылок на упакованные элементы типа Int32
Object[] ob1dim = new Object[i1dim.Length];
Array.Copy(i1dim, ob1dim, i1dim.Length);




Array.Copy не просто копирует элементы одного массива в другой. 
Метод Copy выполняет
следующие действия:
-Упаковка элементов значимого типа в элементы ссылочного типа, например
копирование Int32[] в Object[].
-Распаковка элементов ссылочного типа в элементы значимого типа, например
копирование Object[] в Int32[]
-Расширение (widening) примитивных значимых типов, например копирование
Int32[] в Double[].
-Понижающее приведение в случаях, когда совместимость массивов невозможно
определить по их типам. Сюда относится, к примеру, приведение массива типа
Object[] в массив типа IFormattable[]. Если все объекты в массиве Object[]
реализуют интерфейс IFormattable[], приведение пройдет успешно


#ковариантность
работает не быстро
String[] sa = new String[100];
Object[] oa = sa; // oa ссылается на массив элементов типа String
oa[5] = "Jeff"; // CLR проверяет принадлежность oa к типу String;
 // Проверка проходит успешно
oa[3] = 5; // CLR проверяет принадлежность oa к типу Int32;
 // Генерируется исключение ArrayTypeMismatchException




#array
FileStream[] fsArray;
можно засунуть в
void M1(IList<FileStream> fsList) { ... }
void M2(ICollection<Stream> sCollection) { ... }
void M3(IEnumerable<Object> oEnumerable) { ... }


если метод возвращает private массив или лист то внешний код сможет его редачить!!!!!
для фикса вернуть копию
 Array.Copy - поверхностное копирование


Массивы с ненулевой нижней границей
Создавать их можно при помощи статического метода CreateInstance типа Array
 // Требуется двухмерный массив [2005..2009][1..4]
 Int32[] lowerBounds = { 2005, 1 };
Int32[] lengths = { 5, 4 };
 Decimal[,] quarterlyRevenue = (Decimal[,])
 Array.CreateInstance(typeof(Decimal), lengths, lowerBounds);



Если производительность для вас критична, управляемый массив можно вместо
кучи разместить в стеке потока. Для этого вам потребуется инструкция stackalloc
Она позволяет создавать одномерные массивы элементов значимого типа с нулевой нижней
границей. При этом значимый тип не должен содержать никаких полей ссылочного
типа. По сути, вы выделяете блок памяти, с которым можно работать при помощи небезопасных указателей, поэтому адрес этого буфера нельзя передавать большинству
FCL-методов. Выделенная в стеке память (массив) автоматически освобождается
после завершения метода. Именно за счет этого и достигается выигрыш в производительности. При этом для компилятора C# должен быть задан параметр /unsafe
clr via c# стр 433








#Range
#Enumerable
//не создает  коллекцию но выдает в подходящие моменты времени от 0 до 9 включительно -- 0 1 2...9
//отложенное выполнения
//к такой штуке можно применить например Reverse
foreach(var i in Enumerable.Range(0,10)){}









#collection #array #list #interface


#приведение #типов #Необобщенное в #обобщенное #object
var classicList = new System.Collections.ArrayList(); 
classicList.AddRange ( new int[] { 3, 4, 5} ) ; 
IEnumerable<int> sequencel = classicList. #Cast<int>()//когда встретит не int элемент(не сможет привести через is) то сгенерит исключение
IEnumerable<int> sequencel = db.users.Cast<int>()
IEnumerable<int> sequencel = classicList. #OfType<int>()//когда встретит не int элемент(не сможет привести через is) то пропустит элемент




инициализация
List<char> lst = new List<char>() { 'С', 'А', 'Е', 'В', 'D', 'F' };
lst1=new SortedList<int, string>() { {1, "один"}, {2, "два" }, {3, "три"} };
такая инициализация интерпретируется как lst.Add();//=> нельзя так закидывать значения в коллекции в которых нет public Add



В среде .NET Framework поддерживаются пять типов коллекций: необобщенные,
специальные, с поразрядной организацией, обобщенные и параллельные
необобщенные- хранят только object
Специальные коллекции - оперируют данными конкретного типа или же делают это каким-то особым образом//--- #CollectionsUtil  #HybridDictionary  #ListDictionary #NameValueCollection #OrderedDictionary #StringCollection #StringDictionary
с поразрядной организацией-BitArray
Обобщенные коллекции-храниться только такие элементы данных,которые совместимы по типу с данной коллекцией. Благодаря этому исключается случайное несовпадение типов
Параллельные коллекции-  поддерживают многопоточный доступ к коллекции

должны реализовавывать IEnumerator и IEnumerable,  IEnumerator<T> и IEnumerable<T>




#перечислитель
#итератор

#IEnumerable
для #foreach,
IEnumerator GetEnumerator()
 IDictionaryEnumerator GetEnumerator()//если словарь
public IEnumerator GetEnumerator() {
return this;//так можно но лучше на надо смотри  IEnumerator
}
public void Reset() { idx = -1; }









#IEnumerator

для #foreach, 
любое изменение коллекции делает перечислитель недействительным

bool MoveNext() //true- если есть след элемент
Reset // устанавливает перечислитель в конец(не на последний элемент)(элемент перед первым, для получения первого после reset -MoveNext())
свойство
Current

очень нежелательно реализовывать сразу и IEnumerator и IEnumerable в 1 классе (через GetEnumerator(){return this;})тк тогда нельзя будет 
запустить сразу несколько foreach



тк желательно реализовать и обобщенную версию и нет, но просто так это не сделать нужно

class CountingEnumerable: IEnumerable<int>
{
public IEnumerator<int> GetEnumerator()
{

return new CountingEnumerator();
}
IEnumerator IEnumerable.GetEnumerator()
{

return GetEnumerator();
}
}
class CountingEnumerator : IEnumerator<int>
{
int current = -1;

public bool MoveNext()
{
current++;
return current < 10;
}
public int Current { get { return current; } }

object IEnumerator.Current { get { return Current; } }
public void Reset()
{

current = -1;
}
public void Dispose() {}
}



...
CountingEnumerable counter = new CountingEnumerable();
foreach (int x in counter)
{
Console.WriteLine(x);
}



















#IQueryable : IEnumerable
удаленные бд принимает expression при запросе происходит оптимизация




#IList : ICollection , IEnumerable
this[int index] { get; set; }
Add
Clear
Contains
IndexOf
Insert
Remove
RemoveAt
свойства
IsFixedSize
IsReadOnly



#ICollection: IEnumerable


int Count { get; }
bool IsReadOnly { get; }








#IDictionary: ICollection , IEnumerable
пустые ключи не допускаются
V this[T key] { get; set; }
Add
Clear
Contains
GetEnumerator
Remove
bool TryGetValue(TKey key, out TValue value) пытается извлечь по key и засунуть в value. если все норм то true. Если key не найден, value =значение выбираемое по умолчанию
свойства
IsFixedSize
IsReadOnly
Keys
Values



#IComparer 
int Compare(T х, T у)
(x>y) вернет положительное число



 #IEqualityComparer
bool Equals(T х, T у)
int GetHashCode(T obj)


#ISet<T>

: IEnumerable, IEnumerable<T>,ICollection<T>



#struct
#DictionaryEntry
коллекции словарей(вроде только не обобщенных) хранят в такой структуре key value
public DictionaryEntry(T key, T value)

#KeyValuePair<TKey, TValue>
коллекции словарей(вроде только обобщенных) хранят в такой структуре key value

class

абстрактные классы
 CollectionBase, ReadOnlyCollectionBase и DictionaryBase


#ArrayList , обобщенная форма называется #List
Определяет динамический массив, т.е. такой массив, который может при необходимости увеличивать свой размер

: ICollection, IList, IEnumerable , ICloneable

AddRange
BinarySearch
static #FixedSize Заключает коллекцию list в оболочку типа ArrayList с фиксированным размером и возвращает результат 
#InsertRange
static Readonly Заключает коллекцию list в оболочку типа ArrayList, доступную только для чтения
#SetRange Заменяет часть вызывающей коллекции  элементами коллекции переданной
Sort
 static Synchronized Возвращает синхронизированный вариант коллекции 
#TrimToSize Устанавливает значение свойства Capacity равным значению свойства Count(обрезает массив до количества элементов в нем)

свойства
Capacity - максимальный размер массива на данный момент, можно устанавливать но нельзя установить меньше чем количество элементов в массива сейчас




#Hashtable Определяет хеш-таблицу для пар “ключ-значение”   обобщенная форма называется #Dictionary
ключ хешируется=> скорость работы не зависит от количества элементов внутри
:IDictionary, ICollection, IEnumerable, ISerializable, IDeserializationCallback ,ICloneable



public Hashtable()
public Hashtable(IDictionary d)
public Hashtable(int capacity)
public Hashtable(int capacity, float loadFactor=1)
loadFactor - коэффициент заполнения(от 0,1 до 1,0)
Он определяет степень заполнения хеш-таблицы до увеличения ее размера. В частности, таблица расширяется, Count> loadFactor*емкость_таблицы


ContainsKey
ContainsValue
Synchronized


#Dictionary см Hashtable
:IDictionary,IDictionary<TKey, TValue>, ICollection, ICollection<KeyValuePair<TKey,TValue>>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>,ISerializable , IDeserializationCallback

//вызов метода #Add 2 раза
var dict = new Dictionary<int, string>()
{
{ 5 , " f i ve" } ,
{ 10, "ten" }
}; 
Или в случае версии С# 6: 
var dict = new Dictionary<int, string>()
{
[3] = "three",
}; 




теория--
Инициализация происходит либо при создании (если передана начальный размер коллекции), либо при добавлении первого элемента, причем в качестве размера будет выбрано ближайшее простое число (3). 
При этом создаются 2 внутренние коллекции — int[] buckets и Entry[] entries. 
Первая будет содержать индексы элементов во второй коллекции, а она, в свою очередь, — сами элементы


При добавлении элемента вычисляется хэшкод его ключа и затем — индекс корзины в которую он будет добавлен по модулю от величины коллекции:

проверяется нет ли уже такого ключа в коллекции, если есть — то операция Add выбросит исключение, а присваивание по индексу просто заменит элемент на новый. 
Если достигнут максимальный размер словаря, то происходит расширение (выбирается новый размер ближайшим простым числом).
Сложность оперции соответственно — O(n).
Если происходит коллизия (то есть в корзине с индексов bucketNum уже есть элемент), то новый элемент добавляется в коллекцию, его индекс сохраняется в корзине, а индекс старого элемента — в его поле next. 
Таким образом получаем однонаправленный связный список. 
Данный механизм разрешения коллизий называется chaining. Если при добавлении элемента число коллизий велико (больше 100 в текущей версии), 
то при расширении коллекции происходит операция перехэширования, перед выполнением которой случайным образом выбирается новый генератор хэшкодов.
Сложность добавления O(1) или O(n) в случае коллизии.


При удалении элементов мы затираем его содержимое значениями по умолчанию, меняем указатели next других элементов при неоходимости и сохраняем индекс этого элемента во внутреннее поле freeList, 
а старое значение — в поле next. Таким образом, при добавлении нового элемента мы можем повторно использовать такие свободные ячейки:
Сложность снова O(1) или O(n) в случае коллизии.


-----
Внутреннее устройство простейшего hash map со списком коллизий чрезвычайно примитивно: имеется массив T[N], каждый элемент которого — это список. 
Входом в таблицу (индексом) является хеш-значение ключа. Все ключи с одним и тем же хешем (по модулю N) попадают в один и тот же список, называемый списком коллизий.
=>
есть массив массивов ms[i][i2]
i- хэш элементов, если у некоторых элементов одинаковый хэш, они записываются в массив ms[i]->[i2_0],[i2_1],[i2_2]





#KeyValuePair
Определяет пару "ключ-значение", которая может быть задана или получена
обычный словарь можно переписать под список-, аналог для словаря с dict[1] = "one"; , но ключи для обращения это индексы в списке а не значения key
List<KeyValuePair<int, string>> listKVP = new List<KeyValuePair<int, string>>();
listKVP.Add(new KeyValuePair<int, string>(1, "one"));

Console.Write( "key:" + listKVP[0].Key + "value:" + listKVP[0].Value );









#SortedDictionary см Dictionary
IDictionary,IDictionary<TKey, TValue>, ICollection, ICollection<KeyValuePair<TKey,TValue>>, IEnumerable , IEnumerable<KeyValuePair<TKey, TValue>>



#SortedList см List



#HashSet
динамическая коллекция
множество уникальных значений, можно использовать пересечение, объединение и разноименность
: ICollection<T>, ISet<T>, IEnumerable,IEnumerable<T>, ISerializable, IDeserializationCallback

RemoveWhere
SymmetricExceptWith - разноименность с множеством
UnionWith - объекдинение множеств
ExceptWith - вычитание множеств

public IEqualityComparer<T> Comparer { get; }



#SortedSet






#Queue Определяет очередь, или список, действующий по принципу "первым пришел — первым обслужен"
ICollection, IEnumerable и ICloneable
при увеличении для создания места под 1 элемент, увеличивается  на коэффициент роста(по умолчанию 2)
public Queue (int capacity, float growFactor=2)//growFactor=от  1,0 до 10,0

Enqueue - поместить в очередь
Dequeue извлечь и удалить 1 объект в очереди
Рееk извлечь но не удалять след объект в очереди
TrimToSize



#SortedList Определяет отсортированный список пар "ключ-значение"
пары "ключзначение" хранятся в порядке, отсортированном по значению ключей. 
IDictionary, ICollection, IEnumerable ,ICloneable

GetBylndex
GetKeyList
GetValueList
IndexOfKey
SetBylndex
Synchronized
TrimToSize


#Stack Определяет #стек, или список, действующий по принципу "первым пришел — последним обслужен”
ICollection, IEnumerable и ICloneable
Peek() - вершина стека
Pop() -  вершина стека с удалением
Push()
Synchronized()





#LinkedList
двунаправленный список
:ICollection, ICollection<T>,IEnumerable, IEnumerable<T>, ISerializable , IDeserializationCallback

ссылки на предыдущий и следующий элемент хранятся в #LinkedListNode
LinkedListNode-
public LinkedListNode<T> Next { get; }//null если дальше пусто
public LinkedListNode<T> Previous { get; }
public LinkedList<T> List { get; }
public T Value { get; set; }

-
public LinkedListNode<T> First { get; }
public LinkedListNode<T> Last { get; }

AddAfter
AddBefore
AddFirst
AddLast
Find
Remove




#BitArray
хранит биты а не объекты, для хранения bool как 1 бит а не 1 байт



#SynchronizedCollection<T>
#SynchronizedReadOnlyCollection<T>
#KeyedByTypeCollection<T>




параллельные коллекции #parallel #collection
#BlockingCollection<T> Предоставляет оболочку для блокирующей реализации интерфейса IProducerConsumerCollection<T>
#ConcurrentBag<T> Обеспечивает неупорядоченную реализацию интерфейса IProducerConsumerCollection<T>, которая оказывается наиболее пригодной в том случае, когда информация вырабатывается и потребляется в одном потоке
#ConcurrentDictionary<TKey, TValue> Сохраняет пары "ключ-значение”, а значит, реализует параллельный словарь
#ConcurrentQueue<T> Реализует параллельную очередь и соответствующий вариантинтерфейса IProducerConsumerCollection<T>
#ConcurrentStack<T> Реализует параллельный стек и соответствующий вариант интерфейса IproducerConsumerCollection<T>





#var 
неявная типизация

Объявляемая переменная является локальной, но не статическим полем или полем экземпляра.
• Переменная инициализируется в виде части объявления.
• Выражение инициализации не является группой методов или анонимной функцией (без приведения).
• Выражение инициализации не дает в результате null.
• В операторе объявлена только одна переменная.
• Тип, который нужно назначить переменной, является типом выражения инициализации на этапе компиляции.
• В выражении инициализации не задействована объявляемая переменная







#bool
хранится как 1 байт
для хранения битом #BitArray



#char
Символы в .NET Framework всегда представлены 16-разрядными кодами стандарта
Юникод
 два открытых неизменяемых поля: константа MinValue,
определенная как '\0', и константа MaxValue, определенная как '\uffff'
 IsDigit, IsLetter, IsWhiteSpace, IsUpper, IsLower, IsPunctuation, IsLetterOrDigit, IsControl, IsNumber, IsSeparator, IsSurrogate, IsLowSurrogate,
IsHighSurrogate и IsSymbol


для создания объекта в clr используется il-команда newobj но строки создаются через ldstr - загрузка строки



#string  
ссылочный тип но передается по значению
не изменяемый(при попытыке изменения создает новую строку)
нет конструктора без параметров


при сравнении строк если нужно привести к какому либо регистру, то надо приводить всегда к верхнему тк это более оптимизировано
что бы ничего не сломалось при переносе win-unix
надо писать так  Environment.NewLine


Обычно следует избегать использования флагов StringComparison.InvariantCulture
и StringComparison.InvariantCultureIgnoreCase. Хотя эти значения и позволяют выполнить лингвистически корректное сравнение, применение их для сравнения строк
в программе занимает больше времени, чем с флагом StringComparison.Ordinal
или StringComparison.OrdinalIgnoreCase. Кроме того, игнорирование региональных
стандартов — совсем неудачный выбор для сортировки строк, которые планируется
показывать пользователю.

ToUpperInvariant ToLowerInvariant

сравнение строк с учетом региональных стандартов стр 367 - clr via c#

при сравнении 2х строк сначала проверяется их длина, если разная то строки разные
НО если сравнивать с учетом региональных стандартов то строки разной длины могут быть одинаковыми



#$ $"text{val}"
#интерполяция строки($"")

#@ @"\text"-> "\\text"
если применять вместе то в порядке
$@"ffg"
скобки дублировать
$@"she{{x1}}"




#Интернирование строк — это механизм, при котором одинаковые литералы представляют собой один объект в памяти.
в рамках процесса (именно процесса, а не домена приложения) существует одна внутренняя хеш-таблица, ключами которой являются строки, а значениями – ссылки на них. 
Во время JIT-компиляции литеральные строки последовательно заносятся в таблицу (каждая строка в таблице встречается только один раз). На этапе выполнения ссылки на литеральные строки присваиваются из этой таблицы. 

по дефолту интернирование отключено
При инициализации CLR создает внутреннюю хеш-таблицу, в которой ключами
являются строки, а значениями — ссылки на строковые объекты в управляемой куче.
 Вначале таблица, разумеется, пуста. В классе String есть два метода, предоставляющие доступ к внутренней хеш-таблице:
public static String Intern(String str);
public static String IsInterned(String str);
#Intern, ищет String во внутренней хеш-таблице. Если строка
обнаруживается, возвращается ссылка на соответствующий объект String. Иначе
создается копия строки, она добавляется во внутреннюю хеш-таблицу, и возвращается ссылка на копию. Если приложение больше не удерживает ссылку на исходный объект String, уборщик мусора вправе освободить память, занимаемую этой
строкой. Обратите внимание, что уборщик мусора не вправе освободить строки, на
которые ссылается внутренняя хеш-таблица, поскольку в ней самой есть ссылки
на эти String. Объекты String, на которые ссылается внутренняя хеш-таблица,
нельзя освободить, пока не выгружен соответствующий домен приложения или не закрыт поток.
#IsInterned - не вставляет в таблицу



пулы строк
//TODO надо понять чем отличается от интернирования
При обработке исходного кода компилятор должен каждую литеральную строку
поместить в метаданные управляемого модуля. Если одна строка встречается
в исходном коде много раз, размещение всех таких строк в метаданных приведет
к увеличению размера результирующего файла.
Чтобы не допустить роста объема кода, многие компиляторы (в том числе C#)
хранят литеральную строку в метаданных модуля только в одном экземпляре. Все
упоминания этой строки в исходном коде компилятор заменяет ссылками на ее
экземпляр в метаданных. Благодаря этому заметно уменьшается размер модуля. 





#Конкатенация  #Concat
String.Concat(s3, "!!!");//"123"+"332"
IndexOf
public int IndexOfAny(char[] anyOf)  индекс первого символа который равен символу из массива
StartsWith
contains
#Split(,#StringSplitOptions)
Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
string[] words = text.Split(new string[] { "," }, StringSplitOptions.RemoveEmptyEntries);

#Trim([params char[] trimChars]) - удаляет в начале и в конце символы из массива, если ничего не передали то удалит пробелы
функция TrimStart обрезает начальные символы, а функция TrimEnd обрезает конечные символы

Join
public string #PadLeft(int totalWidth) заполнит с начала пробелами что бы общая длина строки была==totalWidth
public string #PadLeft(int totalWidth, char paddingChar)
public string #PadRight(int totalWidth)
public string #Insert(int startIndex, string value)
public string Remove(int startIndex, int count)
public string Replace(string oldValue, string newValue)
public string #ToLower()
public string #ToUpper()
public string #Substring(int startIndex, int length)//вернет строку которая начинается с startIndex

#Compare Сравнение строк
Если первая строка по алфавиту стоит выше второй, то возвращается число меньше нуля. В противном случае возвращается число больше нуля. И третий случай - если строки равны, то возвращается число 0.
int result = String.Compare(s1, s2);

// обрезаем начиная с третьего символа #Substring
text = text.Substring(2);
// обрезаем сначала до последних двух символов
text = text.Substring(0, text.Length - 2);


public static string #Format(string format, params object[] args)
 String.Format("{0:F2}", v);//0-позиция аргумента
string str = 189.99.ToString("С");//тоже форматирование



Insert, Remove, PadLeft, Replace,
Split, Join, ToLower, ToUpper, Trim, Concat, Format
ToString - return this
Substring - вернуть кусок
CopyTo - скопировать в массив
Copy - полностью новая строка, другой объект
Clone - ссылка на тотже объект


#stringBuilder
основан на внутреннем массиве
ToString выполяется быстро и если получить им строку, потом изменить что то в самом объекте то строка не изменится

у него есть емкость - длина массива
по дефолту-16
если массив начинает выходить за емкость то емкость удваивается и в новый массив происходит копирование


через свойство индексатор Chars можно получить доступ к массиву





есть интерфейс #IFormattable
там есть ToString с форматированием
В FCL у всех базовых типов (Byte, SByte, Int16/UInt16, Int32/UInt32, Int64/
UInt64, Single, Double, Decimal и DateTime) есть реализации этого интерфейса
String s = price.ToString("C", new CultureInfo("vi-VN"));


Чтобы расширить стандартное форматирование объекта, нужно добавить внутрь
фигурных скобок строку форматирования. В частности, следующий код отличается от предыдущего только наличием строк форматирования для подставляемых
параметров 0 и 2:
String s = String.Format("On {0:D}, {1} is {2:E} years old.",
 new DateTime(2012, 4, 22, 14, 35, 5), "Aidan", 9);


создание собственного средства форматирования
стр 386 - clr via c#

Защищенные строки
и в FCL безопасный строковый класс System.
Security.SecureString\неуправляемая память, уборщик мусора ничего про нее не знает, нужно вызывать dispose
содержимое шифруется
есть "уязвимости"








#datetime #время #дата 
структура

#DateTimeRange
создание коллекции
 DateTime startDate = new DateTime(2008, 05, 1, 10, 2, 3, 4, DateTimeKind.Utc);
var dates = new DateTimeRange(startDate, endDate);
var dates = new DateTimeRange(SampleData.Start, SampleData.End);
var query = from date in dates
join defect in SampleData.AllDefects
on date equals defect.Created.Date
into joined
select new { Date = date, Count = joined.Count() };


// Переход от локального к мировому времени
  ((DateTime)obj).ToUniversalTime().ToString("u");
 // Переход от мирового времени к локальному
 return DateTime.ParseExact( info.GetString("Date"), "u", null).ToLocalTime();








#StringComparer: IComparer
CurrentCulture - с учетом регистра и культурной среды
CurrentCultureIgnoreCase - без учета регистра и культурной среды
InvariantCulture - с учетом регистра без культур
InvariantCultureIgnoreCase
OrdinalIgnoreCase - порядковое сравнение без учета регистра







#BitConverter
класс для преобразования базовых типов данных в байты










#? #?? #null #Nullable
структура  тип Nullable<T>
//эквивалент
Nullable<bool> val;
bool? val;
val=null;
val=false;

val.HasValue//проверить установлено ли значение
val.Value//получить значение, только для чтения, если null то исключение
#GetValueOrDefault()возвращает значение Value, если HasValue равно true, и результат new Т () или заданное стандартное значение в противном случае

var test=val??true;//если val==null то вернет 2 член(true) если не null то вернет val
var test=val??method();//если val!=null то method не вызовется

можно сравнивать но если хотя бы 1== null то
< > <= >= -всегда false
true||null -true
null||null -null
!null - null
общее правило- если необходимо сравнить null значит будет null, если можно получить результат без сравнения то он будет получен


Когда Т? упаковывается, упакованное значение в куче содержит Т, а не Т?, тк object-ссылочный тип



int? test=null;
Унарные операторы (+++, -, --, ! , ~). Если операнд равен null, результат тоже
равен null.
Бинарные операторы (+, -, *, /, %, &, |, ^, <<, >>). Результат равен значению null,
если этому значению равен хотя бы один операнд. Исключением является случай
воздействия операторов & и | 
Операторы равенства (==, !=). Если оба операнда имеют значение null, они
равны. Если только один из них имеет это значение, операнды не равны. Если
ни один из них не равен null, операнды сравниваются на предмет равенства.
Операторы сравнения (<, >, <=, >=). Если значение null имеет один из операндов, в результате получаем значение false. Если ни один из операндов не имеет
значения null, следует сравнить их значения.







#Random

#string
Random random = new Random();
            const string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
            return new string(Enumerable.Repeat(chars, length)
              .Select(s => s[random.Next(s.Length)]).ToArray());





#GC #мусор #сборка

CLR  использует алгоритм отслеживания ссылок. Алгоритм отслеживания ссылок
работает только с переменными ссылочного типа, потому что только эти переменные
могут ссылаться на объекты в куче; переменные значимых типов просто содержат
данные экземпляра значимого типа. Ссылочные переменные могут использоваться во многих контекстах: статические и экземплярные поля классов, аргументы
методов, локальные переменные. Все переменные ссылочных типов называются
корнями (roots)
Когда среда CLR запускает уборку мусора, она сначала приостанавливает все
программные потоки в процессе. Тем самым предотвращается обращение к объектам
и возможное изменение состояния во время их анализа CLR. Затем CLR переходит к этапу уборки мусора, называемому маркировкой (marking). CLR перебирает
все объекты в куче, задавая биту в поле индекса блока синхронизации значение 0.
Это означает, что все эти объекты могут быть удалены. Затем CLR проверяет все
активные корни и объекты, на которые они ссылаются. Если корень содержит null,
CLR игнорирует его и переходит к следующему корню
Если корень ссылается на объект, в поле индекса блока синхронизации устанавливается бит — это и есть признак маркировки объекта. После маркировки объекта
CLR проверяет все корни в этом объекте и маркирует объекты, на которые они
ссылаются. Встретив уже маркированный объект, уборщик мусора останавливается,
чтобы избежать возникновения бесконечного цикла в случае циклических ссылок

После проверки всех корней куча содержит набор маркированных и немаркированных объектов. Маркированные объекты переживут уборку мусора, потому что
на них ссылается хотя бы один объект; можно сказать, что они достижимы из кода
приложения. Немаркированные объекты недостижимы, потому что в приложении
не существует корня, через который приложение могло бы к ним обратиться.


Теперь, когда CLR знает, какие объекты должны остаться, а какие можно удалить, начинается следующая фаза уборки мусора, называемая сжатием (compacting
phase). В этой фазе CLR перемещает вниз все «немусорные» объекты, чтобы
они занимали смежный блок памяти. Перемещение имеет много преимуществ.
Во-первых, оставшиеся объекты будут находиться поблизости друг от друга; это
приводит к сокращению размера рабочего набора приложения, а следовательно,
повышает производительность обращения к этим объектам в будущем. Во-вторых,
свободное пространство тоже становится непрерывным, что позволяет освободить
эту область адресного пространства. Наконец, сжатие позволяет избежать проблем
фрагментации адресного пространства при использовании управляемой кучи.

в фазе сжатия
CLR вычитает из каждого корня количество байт, на которое объект был сдвинут 
вниз в памяти. Тем самым гарантируется, что каждый корень будет ссылаться на тот
же объект, что и прежде; просто сейчас этот объект оказался в другом месте памяти


Уборщик мусора с поддержкой поколений (generational garbage collector), который
также называют эфемерным уборщиком мусора (ephemeral garbage collector), хотя
я не использую такой термин в своей книге, работает на основе следующих предположений:

-чем младше объект, тем короче его время жизни
-чем старше объект, тем длиннее его время жизни
-уборка мусора в части кучи выполняется быстрее, чем во всей куче



ПОКОЛЕНИЯ
Сразу после инициализации в управляемой куче нет объектов. Говорят, что
создаваемые в куче объекты составляют поколение 0. Проще говоря, к нулевому
поколению относятся только что созданные объекты, которых не касался уборщик
мусора

у поколений есть пороговое значение(если память превышает это значение то пора убирать мусор)

Если
в результате выделения памяти для нового объекта размер поколения 0 превышает пороговое значение, должна начаться уборка мусора
после уборки мусор объекты которые выжилы становятся поколением 1

снова ваделяется память и объекты помещаются в поколение 0
поколение 0 заполнено
Начиная уборку мусора, уборщик определяет, сколько памяти занято поколением 1. Пока поколение 1 занимает намного меньше отведенной памяти, поэтому
уборщик проверяет только объекты поколения 0 и перемещает из нулевого в 1, те что до этого были в 1 остаются там
после того как в очередной раз что то перенеслось в поколение 1 и его пороговое значение привысилось, приложение продолжает работать пока не заполнится 0 поколение
и потом когда 0 поколение заполнено, проверяются все поколения которые заполнены и все что выжило смещается в поколение+1


В поколении 2 находятся объекты, проверенные уборщиком мусора не меньше двух раз.
Операций уборки мусора может быть много, но объекты поколения 1 проверяются
только тогда, когда их суммарный размер достигает порогового значения — до этого
обычно проходит несколько операций уборки мусора в поколении 0.

Управляемая куча поддерживает только три поколения: 0, 1 и 2. Поколения 3 не
существует

clr сам может менять пороговое значение и настраиваться

 если уборщик освобождает недостаточно памяти, перед генерированием исключения OutOfMemoryException он выполняет полную уборку мусора


Режимы уборки мусора
-Режим рабочей станции
-Режим сервера

=======такая инфа
Ясно, что игнорирование объектов поколения 1 повышает быстродействие уборщика. Однако его производительность растет еще больше благодаря выборочной
проверки объектов в управляемой куче. Если корень или объект ссылается на объект
из старшего поколения, уборщик игнорирует все внутренние ссылки старшего объекта, сокращая время построения графа доступных объектов. Конечно, возможна
ситуация, когда старый объект ссылается на новый. Чтобы не пропустить обновленные поля этих старых объектов, уборщик использует внутренний механизм
JIT-компилятора, устанавливающий флаг при изменении ссылочного поля объекта.
Он позволяет уборщику выяснить, какие из старых объектов (если они есть) были
изменены с момента последней уборки мусора. Остается проверять только старые
объекты с измененными полями, чтобы выяснить, не ссылаются ли они на новые
объекты из поколения 0

=====

=====
если уборка мусора длится слишком долго, может завершиться время ожидания клиентских запросов. Чтобы избежать
подобных ситуаций, в классе GC имеется метод RegisterForFullGCNotification.
С его помощью и при использовании дополнительных вспомогательных методов
(WaitForFullGCApproach, WaitForFullGCComplete и CancelFullGCNotification)
можно оповестить приложение о том, что уборщик мусора близок к выполнению
полной уборки. В результате приложение сможет вызвать метод GC.Collect для
принудительной уборки мусора в более подходящее время или свяжется с другими
серверами, чтобы лучше распределить клиентские запросы. Дополнительную информацию об этих методах вы можете найти в документации на .NET Framework
SDK. Имейте в виду, что методы WaitForFullGCApproach и WaitForFullGCComplete
всегда вызываются вместе, так как CLR обрабатывает их попарно.


===






дружественная #сборка
В процессе создания сборки можно указать другие сборки, которые она будет
считать «друзьями», — для этого служит атрибут InternalsVisibleTo, определенный в пространстве имен System.Runtime.CompilerServices. У атрибута есть
строковый параметр, определяющий имя дружественной сборки и ее открытый ключ
(передаваемая атрибуту строка не должна содержать информацию о версии, региональных стандартах или архитектуре процессора). Заметьте, что дружественные
сборки получают доступ ко всем внутренним типам сборки, а также к внутренним
членам этих типов. 

// Внутренние типы этой сборки доступны из кода двух следующих сборок
// (независимо от версии или региональных стандартов)
[assembly:InternalsVisibleTo("Wintellect, PublicKey=12345678...90abcdef")]
[assembly:InternalsVisibleTo("Microsoft, PublicKey=b77a5c56...1934e089")]
internal sealed class SomeInternalType { ... }
internal sealed class AnotherInternalType { ... }





#method
методы могут компилироваться в разные команды il
call
callvirt - для виртуального метода, работает медленнее
не любой виртуальный метод вызывается через callvirt
например если перегружается метод ToString и вызывает в себе base.ToString()
то такой метод вызывается как call тк при вызове base.ToString должен вызываться тот же метод в котором уже сейчас выполняется код
(вызывается как бы родительский метод, но из за виртуальности вызовется дочерний)

Компиляторы стремятся использовать команду call при вызове методов, определенных значимыми типами, поскольку они запечатаны. В этом случае полиморфизм
невозможен даже для виртуальных методов, и вызов выполняется быстрее. Кроме
того, сама природа экземпляра значимого типа гарантирует, что он никогда не будет
равен null, поэтому исключение NullReferenceException не возникнет. Наконец,
для виртуального вызова виртуального метода значимого типа CLR необходимо
получить ссылку на объект значимого типа, чтобы воспользоваться его таблицей
методов, а это требует упаковки значимого типа




#params #param 
void func(params int[] ints){}
func();
func(1);
func(1,2);
func(new int[]{1,2,3});

Вызов метода, принимающего переменное число аргументов, снижает производительность, если, конечно, не передавать в явном виде значение null. В любом случае
всем объектам массива нужно выделить место в куче и инициализировать элементы
массива, а по завершении работы занятая массивом память должна быть очищена
сборщиком мусора. Чтобы уменьшить негативное влияние этих операций на производительность, можно определить несколько перегруженных методов, в которых
не используется ключевое слово params. За примерами обратитесь к методу Concat
класса System.String, который перегружен следующим образом:
public sealed class String : Object, ... {
 public static string Concat(object arg0);
 public static string Concat(object arg0, object arg1);
 public static string Concat(object arg0, object arg1, object arg2);
 public static string Concat(params object[] args);




при определении сигнатуры методы
параметры должны быть как можно более "слабыми" (самый первый интерфейс), которого хватит для выполнения определенной логики
return тип должен быть самый сильный, тк если вызывающему коду понадобится его родитель он его просто приведет к нему и все




если метод в 1 строку можем сделать так, с 17 студии кажется
int Foo (int х) => х * 2;


При вызове метода извне модуля изменение значения параметров по умолчанию
является потенциально опасным. Вызывающая сторона использует значение
по умолчанию в процессе работы. Если изменить его и не перекомпилировать
код, содержащий вызов, в вызываемый метод будет передано прежнее значение

// Не делайте так:
 private static String MakePath(String filename = "Untitled"

// Используйте следующее решение:
 private static String MakePath(String filename = null) {
 filename ?? "Untitled";



перегрузка параметров
нельзя перегрузить метод что бы он отличался только ref или ou



#необязательные #параметры
void func(int gg,int asd=10){}
Foo<T>(T value = default(T))
необязательные параметры(asd) должны быть указаны в виде константного выражения или конструктора без параметров для типа значения( это эквивалентно применению операции default(...)).  не могут быть помечены посредством ref или out.

Все необязательные параметры должны располагаться после обязательных параметров. Исключением является массив
параметров (объявленный с помощью модификатора params), который по-прежнему следует помещать в конец списка параметров, но он может находиться после необязательных параметров.
Массив параметров нельзя объявлять как необязательный параметр — если в вызывающем коде
значения для него не указаны, будет применяться пустой массив. 


 Всегда можно использовать константы: числовые и строковые
литералы, null, члены const, члены перечислений и операцию default(Т). Должно быть доступным неявное преобразование типа
указанного значения в тип параметра, но оно не может быть преобразованием, определяемым
пользователем.






#позиционные



//порядок вызова
//сначала выполняется func1()
func(a,b){};
func(func1(),func2());
func(a:func1(),b:func2());
func(b:func1(),a:func2());



#именованные параметры
порядок вызова смотри для "позиционные
Foo (х:1, у:2);
bool success = int.TryParse("10", result: out number);


void func(int x){}

func(10);
x-параметр
10-аргумент






#Tuple #кортеж

Tuple<t1,t2,t3>
static Create
Tuple<string, string, string, string> t= Tuple.Create("", "", "", "");
t.Item1 t.Item2

кортеж

var tuple = (5, "tre");
или 	 (int, string) tuple = (5, "tre");
tuple.Item1 += 26;

var tuple = (count:5, sum:10);
tuple.count=5;

var (name, age) = ("Tom", 23);
 Console.WriteLine(name);

var tuple = GetValues();
private static (int, int) GetValues()
{
    var result = (1, 3);

private static (int sum, int count) GetNamedValues()
{
    var result = (sum:0, count: 0);


 var (name, age) = GetTuple(("Tom", 23), 12);
private static (string name, int age) GetTuple((string n, int a) tuple, int x)
{
    var result = (name: tuple.n, age: tuple.a + x);



Tuple.Create(Math.Min(a, b), Math.Max(a, b));
Чтобы создать тип Tuple с более, чем восьмью элементами, передайте другой
объект Tuple в параметре Rest
var t = Tuple.Create(0, 1, 2, 3, 4, 5, 6, Tuple.Create(7, 8));
Console.WriteLine("{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}",
 t.Item1, t.Item2, t.Item3, t.Item4, t.Item5, t.Item6, t.Item7,
 t.Rest.Item1.Item1, t.Rest.Item1.Item2);








есть утиная типизация

когда делаем так
List<int> val=new List<int>(){10,20};
будет вызван метод Add 2 раза, но
Тот факт, что тип должен реализовывать интерфейс IEnumerable, никогда не используется
компилятором.
• Метод Add() находится только по имени — в интерфейсе нет требований о его указании.




#foreach
foreach(T val in IEnumerable<T>){}
нужны IEnumerable и IEnumerator
сразу(даже перед 1 итерацией) вызывает сначала MoveNext() а потом Current
если есть dispose у Enumerator то вызывается



можно также без интерфейсов, просто докинуть #итератор  #yield #iterator
код останавливает выполнение метода, возвращает значение и при вызове метода еще раз(MoveNext) продолжает с того же места
Оператор yield return не разрешено использовать внутри блока try при наличии любых блоков catch
не допускается применять оператор yield return или yield break в блоке finally.
если используется в try то при преждевременной остановке итерационного цикла(foreach) при вызове Dispose выполнение итерации продолжится
и то что транслируется в try - (using) -- Скит стр 206

метод который принимает ref out не может содержать yield



public IEnumerator<T> GetEnumerator() {
foreach(T ch in chrs)
yield return ch;
}


#итератор  #yield #return
при создании итератора класс автоматически реализует IEnumerator(не нужно явно указывать)

yield break; // прерывание итератора #TODO






//такая конструкция необходима потому что метод  с итератором не будет вызван пока не будет вызван метод MoveNext, 
но в таком случае сразу будет обработка ошибки а потом уже ждет вызов метода MoveNext

public static IEnumerable<T> Where<T>(IEnumerable<T> source, Predicate<T> predicate)
{
//проверяем данные и передаем в след метод
return WhereImpl(source, predicate);
}
private static IEnumerable<T> WhereImpl<T>(IEnumerable<T> source, Predicate<T> predicate)
{
foreach (T item in source)
{
if (predicate(item))
{
yield return item;
}
}
}












именованный итератор

public IEnumerable имя_итератора(список_параметров) {
// ...
yield return obj;
}
public IEnumerable MyItr(int end) {
for(int i=0; i < end; i++)
yield return (char) (ch + i);
if (i==5) 
yield break;//заканчивает вызов, далее вызываться не будет(преждевременное завершение )
}

Итератор должен возвращать один из следующих четырех интерфейсов (иначе компилятор сгенерирует сообщение об ошибке):
System.Collections.IEnumerable
System.Collections.IEnumerator
System.Collections.Generic.IEnumerable<T>-наиболее часто
System.Collections.Generic.IEnumerator<T>





#Finalize и #Dispose #IDisposable #Деструктор
освобождения неуправляемых ресурсов

если наследуем от класса с IDispose то тоже надо реализовать
private bool IsDisposed = false;
 
    protected override void Dispose(bool disposing)
    {
        if (IsDisposed) return;
        if (disposing)
        {
            // Освобождение управляемых ресурсов
        }
        IsDisposed = true;
        // Обращение к методу Dispose базового класса
        base.Dispose(disposing);
    }





public class SomeClass: IDisposable
{
    private bool disposed = false;
 
    // реализация интерфейса IDisposable.
    public void Dispose()
    {
        Dispose(true);
        // подавляем финализацию
        GC.SuppressFinalize(this);
    }
 
    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            if (disposing)
            {
                // Освобождаем управляемые ресурсы
            }
            // освобождаем неуправляемые объекты
            disposed = true;
        }
    }
 
    // Деструктор
    ~SomeClass()
    {
        Dispose (false);
    }
}




#~
#finalize
#TODO
возможно при финализации все неуправляемые ресурсы сами уничтожатся\закроются
но про это надо почитать

Методы Finalize вызываются при завершении уборки мусора для объектов,
которые уборщик мусора определил для уничтожения. Это означает, что память
таких объектов не может быть освобождена немедленно, потому что метод Finalize
может выполнить код с обращением к полю. Так как финализируемый объект
должен пережить уборку мусора, он переводится в другое поколение, вследствие
чего такой объект живет намного дольше, чем следует. Ситуация не идеальна в отношении использования памяти, поэтому финализации следует по возможности
избегать. Проблема усугубляется тем, что при преобразовании поколения финализируемых объектов все объекты, на которые они ссылаются в своих полях, тоже
преобразуются, потому что они должны продолжать свое существование. Итак,
старайтесь по возможности обойтись без создания финализируемых объектов
с полями ссылочного типа.

Как вы думаете, что было бы, не будь кода, явно вызывающего метод Dispose?
Уборщик мусора однажды правильно определил бы, что эти объекты стали мусором, и финализировал их. Но он не может гарантировать определенной очередности вызова методов финализации. 


Иногда системный ресурс требует много памяти, а управляемый объект, являющийся его «оберткой», занимает очень мало памяти. 
С точки зрения CLR до уборки
мусора процесс может выделять сотни растровых изображений (которые займут
мало управляемой памяти). Однако если процесс манипулирует множеством изображений, расходование памяти процессом начнет расти с огромной скоростью.
Для исправления ситуации в классе GC предусмотрены два статических метода
следующего вида:
public static void AddMemoryPressure(Int64 bytesAllocated);
public static void RemoveMemoryPressure(Int64 bytesAllocated);

















c#

#Параллельное #программирование #TPL
#Task
System.Threading.Tasks


после того, как задача завершена, она не может быть перезапущена. => для повторного запуска нужно пересоздать

при возникновении исключения(можно узнать по свойствам, но выбросится на await)
Свойство Status задачи получает значение Faulted, когда асинхронная операция отказала
(и свойство IsFaulted возвращает true).
• Свойство Exception возвращает объект #AggregateException, содержащий все (потенциально множественные) исключения, которые привели к отказу задачи, или null, если
задача не отказывала.
• Метод Wait() сгенерирует исключение AggregateException, если задача находится в
состоянии отказа.
• Свойство Result класса Task<T> (который также ожидает завершения) аналогичным образом сгенерирует исключение AggregateException

для того что бы выбрасывать исключения сразу а не через await
static Task<int> ComputeLengthAsync(string text)//метод не объявляется асинхронным!
{
//если надо выбрасываем исключения до вызова
return ASYNCMETHOD();//можно обернуть в асинхронную лямбду и вызвать ее+вернуть ее результат
}






public delegate void Action()
public Task(Action действие)
public Task(Func<TResult> функция)
public Task(Func<Object, TResult> функция, Object состояние) //задача принимает аргумент состояние


public Task<TResult> StartNew(Func<TResult> функция)
public Task<TResult> StartNew(Func<Object,TResult> функция, Object состояние)
public Task StartNew(Action<Object> action, Object состояние, CancellationToken признак_отмены)


public int Id { get; }
public static Nullable<int> CurrentID { get; }


в методе который передается в task при условии передачи в метод токена отмены параметром
cancelTok.ThrowIfCancellationRequested();//установит IsCanceled и выбросит исключение AggregateException
IsCanceled


Dispose().//только для завершенной задачи, если задача не завершена то InvalidOperationException

исключения
ObjectDisposedException.  если задача освобождена посредством вызова метода Dispose()
AggregateException,  если задача сама генерирует исключение или же отменяется


//1 способ

Task task = new Task(() => Console.WriteLine("Hello Task!"));
task.Start();
//2 способ
//	
Task task = Task.Factory.StartNew((Action action);
//3 способ
Task task = Task.Run(() => Console.WriteLine("Hello Task!"));

//это все блокирует поток тк не используется await
//получить результат
Task<int> task1 = new Task<int>(()=>Factorial(5));
        task1.Start();
//эта строка будет ждать завершения выполнения задачи
var f=task1.Result

//остановит поток до выполнения задачи
 task.Wait();
//остановит поток до выполнения всех задач в массиве  tasks
Task.WaitAll(params Task[] tasks)
//остановит поток до выполнения хотя бы 1 задачи в массиве  tasks
Task.WaitAny(params Task[] tasks)

//вроде нормально будет работать как обычный await
 int[] ids = new[] { 1, 2, 3, 4, 5 };
    await Task.WhenAll(ids.Select(i => DoSomething(1, i, blogClient)));



//task2 начнет выполнение после завершения task1

public Task ContinueWith(Action<Task> действие_продолжения)
 Task task2 = task1.ContinueWith(Display);
void Display(Task t)
        {}
||
Task task3 = task1.ContinueWith((Task t) =>
    {
        Console.WriteLine("Id задачи: {0}", Task.CurrentId);
    });




//массивы
Task[] tasks1 = new Task[3]
foreach
 t.Start();
||
for (int i = 0; i < tasks2.Length; i++)
    tasks2[i] = Task.Factory.StartNew(() => Console.WriteLine($"Task {j++}"));

Класс Task имеет ряд свойств, с помощью которых мы можем получить информацию об объекте. Некоторые из них:
AsyncState: возвращает объект состояния задачи
CurrentId: возвращает идентификатор текущей задачи
Exception: возвращает объект исключения, возникшего при выполнении задачи
Status: возвращает статус задачи

#TaskCreationOptions #AttachedToParent
//вложенные задачи и из за параметра внешняя будет "ждать внутреннюю"
var outer = Task.Factory.StartNew(() =>      // внешняя задача
    {
var inner = Task.Factory.StartNew(() =>  // вложенная задача
        {}, TaskCreationOptions.AttachedToParent);
    });
outer.Wait(); // ожидаем выполнения внешней задачи(блокирует поток)--!! надо применять await




#delay #sleep

var taskDelay = Task.Delay(3000);//создаем delay(это не остановит таск, выполнение продолжится)
//выполнение
//останавливаем таск если время еще не прошло
await taskDelay;



ThreadPool.QueueUserWorkItem(ComputeBoundOp, 5); // Вызов QueueUserWorkItem
new Task(ComputeBoundOp, 5).Start(); // Аналог предыдущей строки
Task.Run(() => ComputeBoundOp(5)); // Еще один аналог


почему надо бзать task а не потоки:
-Задания требуют меньше памяти, чем потоки, кроме того, они намного быстрее
создаются и уничтожаются.
-Пул потоков автоматически распределяет задания среди доступных процессоров
-По мере того как каждое задание завершает свой этап, выполнявший его поток
возвращается в пул, где может заняться другой работой, если таковая имеется.
-Пул потоков видит все задания сразу и поэтому может лучше планировать их
выполнение, сокращая количество потоков в процессе, а значит, и количество
переключений контекста.



await Task.#Delay(2000);


#TODO
если асинхронный метод возвращает void а не task то его нормально не использовать await
и не получить исключения которые выброшены в методе


async анонимный метод
Task.Run(async () => {
 await XxxAsync(); // Инициирование асинхронной операции
});



#TODO
#ConfigureAwait
return await msg.Content.ReadAsStringAsync().ConfigureAwait(false); 

 вызов ConfigureAwait(false) должен быть
применен к каждому объекту Task, используемому с await. Это связано с тем, что
асинхронные операции могут завершаться синхронно, и когда это происходит, вызывающий поток просто продолжает выполняться без возвращения управления
стороне вызова; вы никогда не знаете, какой операции потребуется игнорировать
объект SynchronizationContext, поэтому необходимо приказать всем операциям
игнорировать его



раньше вместо task использовали 
Begin...
End...
сейчас это можно засунуть в таску
await Task.Factory.FromAsync(begin,end,null);

еще есть событийная модель
var wc = new System.Net.WebClient(); 
var tcs = new TaskCompletionSource<String>(); //штука благодаря которой асунем в таск
// При завершении загрузки строки объект WebClient инициирует
 // событие DownloadStringCompleted, завершающее TaskCompletionSource
 wc.DownloadStringCompleted += (s, e) => {
 if (e.Cancelled) tcs.SetCanceled();
 else if (e.Error != null) tcs.SetException(e.Error);
 else tcs.SetResult(e.Result);
 }; 
 // Начало асинхронной операции
 wc.DownloadStringAsync(uri);
 // Теперь мы можем взять объект Task из TaskCompletionSource
 // и обработать результат обычным способом.
 String result = await tcs.Task; 




#async
-Асинхронная функция не может иметь параметры out и ref
Оператор await не может использоваться в блоке catch, finally или unsafe
-Не допускается установление блокировки, поддерживающей владение потоком или рекурсию, до операции await, и ее снятие после оператора await. Это
ограничение объясняется тем, что один поток может выполнить код до await,
а другой поток может выполнить код после await. При использовании await
с командой C# lock компилятор выдает сообщение об ошибке. Если вместо
этого явно вызвать методы Enter и Exit класса Monitor, то код откомпилируется, но Monitor.Exit выдаст исключение SynchronizationLockException во
время выполнения
-В выражениях запросов оператор await может использоваться только в первом
выражении коллекции условия from или в выражении коллекции условия
join.


=====такое
При вызове потоком метода Wait система проверяет, началось ли выполнение задания
Task, которого ожидает поток. В случае положительного результата проверки поток,
вызывающий метод Wait, блокируется до завершения задания. Но если задание еще
не начало выполняться, система может (в зависимости от объекта TaskScheduler)
выполнить его при помощи потока, вызывающего метод Wait. В этом случае данный поток не блокируется. Он выполняет задание Task и немедленно возвращает
управление. Это снижает затраты ресурсов (вам не приходится создавать поток
взамен заблокированного), повышает производительность (на создание потока
и переключение контекста не тратится время). Однако и это может быть не очень
хорошо. Например, если перед вызовом метода Wait в рамках синхронизации потока
происходит его блокирование, а затем задание пытается получить доступ к тем же
запертым ресурсам, возникает взаимная блокировка (deadlock)
====

Если вы ни разу не вызывали методы Wait или Result и не обращались к свойству
Exception класса Task, код не «узнает» о появившихся исключениях. Иначе говоря,
вы не получите информации о том, что программа столкнулась с неожиданной
проблемой. Для распознавания скрытых исключений можно зарегистрировать метод обратного вызова со статическим событием UnobservedTaskException класса
TaskScheduler. При уничтожении задания со скрытым исключением в ходе уборки
мусора это событие активизируется потоком финализации уборщика мусора CLR.
После этого обработчику события передается объект UnobservedTaskExceptionEve
ntArgs, содержащий скрытое исключение AggregateException.



System.Web.Mvc.#AsyncController
почитать, от этого надо наследовать контроллер




передаем токен отмены
CancellationTokenSource cts = new CancellationTokenSource();
Task<Int32> t = new Task<Int32>(() => Sum(cts.Token, 10000), cts.Token);


Следует также упомянуть, что во внутренней реализации объект Task содержит
коллекцию ContinueWith. Это дает возможность несколько раз вызвать метод
ContinueWith при помощи единственного объекта Task. Когда это задание завершится, все задания из коллекции ContinueWith окажутся в очереди в пуле потоков.
Кроме того, при вызове метода #ContinueWith можно установить флаги перечисления #TaskContinuationOptions.
там можно настроить когда вызовется таска, например только при отмене и тд

Task<Int32> t = Task.Run(() => Sum(10000));
t.ContinueWith(task => Console.WriteLine("The sum is: " + task.Result),
 TaskContinuationOptions.OnlyOnRanToCompletion);
t.ContinueWith(task => Console.WriteLine("Sum threw: " + task.Exception),
 TaskContinuationOptions.OnlyOnFaulted);

 
таску можно присоеденить к родительской таске а #TaskCreationOptions.#AttachedToParent


узнать статус таски можно так task.Status
узнать исключения таски можно  task.#AggregateException

#todo
файбрика заданий  #TaskFactory


#TODO #TaskScheduler
 http://code.msdn.microsoft.com/ParExtSamples














#Параллельное #программирование #TPL
#Parallel
#thread
теория
Отличия в многозадачности на основе процессов и потоков могут быть сведены к
следующему: многозадачность на основе процессов организуется для параллельного
выполнения программ, а многозадачность на основе потоков — для параллельного выполнения отдельных частей одной программы.



public delegate void ThreadStart()
public delegate void ParameterizedThreadStart(object obj)

public Thread(ThreadStart запуск) //создание потока
newThrd.Start([object param]);//запуск потока, можно передать параметр, если параметр передан то конструктор(ниже)
public Thread(ParameterizedThreadStart запуск)//принимает только тип object=> функция тоже должна принимать object
var th11=new Thread(new ParameterizedThreadStart(method));
th11.Start((object)10);

Name - имя потока, можно задать
public bool IsAlive { get; }
public void Join() //ждет завершения потока, можно указать время
public bool IsBackground { get; set; } //сделать поток фоновым


установить приоритетность потока(чем выше тем чаще получает доступ к цп)
public ThreadPriority Priority{ get; set; }//ThreadPriority-enum


применять в особых случаях
public void Abort() //прервать выполнение потока
Thrd.Abort();
Thrd.Join(); //ожидать прерывания или выполнения
Thrd.Abort (object a);
в методе который в потоке
try {
//первая строка метода

//последняя строка метода
} catch(ThreadAbortException exc) {
Console.WriteLine("Поток прерван, код завершения " +
(int)exc.ExceptionState);//object a

//отменяем прерывание
Thread.ResetAbort();
}



состояния потока 
public ThreadState ThreadState{ get; }


получить текущий поток
public static Thread CurrentThread{ get; }






Если у вас есть выбор между Parallel.For и Parallel.ForEach, лучше используйте цикл For, так
как он работает быстрее.
Parallel.For(0, 1000, i => DoWork(i));
Parallel.ForEach(collection, item => DoWork(item));

// Потоки из пула выполняют методы одновременно
Parallel.Invoke(
 () => Method1(),
 () => Method2(),
 () => Method3());

Выполнение вызывающего потока не возобновляется, пока
не будет завершена вся работа. Если какая-либо операция станет источником необработанного исключения, вызванный вами метод Parallel выдаст исключение
AggregateException.




#ParallelEnumerable
есть методы
 Where, Select, SelectMany, GroupBy, Join, OrderBy, Skip, Take
для их использования надо сначала вызвать метод .AsParallel()


 существует возможность в ходе операций переключиться с параллельного режима на последовательный

метод  AsSequential класса ParallelEnumerable
Этот метод преобразует ParallelQuery<T> в интерфейс IEnumerable<T>, и все
операции начинают выполняться всего одним потоком.

Так как при параллельном LINQ-запросе элементы обрабатываются несколькими потоками одновременно, результаты возвращаются в произвольном порядке.
Для сохранения очередности обработки элементов применяется метод #AsOrdered
класса ParallelEnumerable.
 Вот операторы, предназначенные для выполнения неупорядоченных операций: Distinct, Except, Intersect, Union, Join,
GroupBy, GroupJoin и ToLookup. После любого из этих операторов можно вызвать
метод AsOrdered, чтобы упорядочить элементы

Следующие операторы выполняют упорядоченные операции: OrderBy,
OrderByDescending, ThenBy и ThenByDescending. Если вы хотите вернуться к неупорядоченным операциям, чтобы повысить производительность, после любого из
этих операторов также можно вызвать метод AsUnordered.



#directory 

= Directory.EnumerateFiles(path, searchPattern, searchOption);



#filestream
При создании объекта FileStream флаг FileOptions.Asynchronous позволяет указать, какие операции — синхронные или асинхронные — будут использоваться для
взаимодействия


#атомарность
CLR гарантирует атомарность чтения и записи следующих типов данных: Boolean,
Char, (S)Byte, (U)Int16, (U)Int32, (U)IntPtr, Single и ссылочных типов. Это означает, что все байты переменной читаются или записываются одновременно.









#thread
Каждый поток состоит из нескольких частей стр 726 clr via c#
-Объект ядра потока (thread kernel object)
-Блок окружения потока (Thread Environment Block, TEB).
-Стек пользовательского режима (user-mode stack). 
-Стек режима ядра (kernel-mode stack)
-Уведомления о создании и завершении потоков

В произвольный момент времени Windows передает процессору на исполнение
один поток. Этот поток исполняется в течение некоторого временного интервала,
иногда называемого тактом (quantum). После завершения этого интервала контекст Windows переключается на другой поток. При этом обязательно происходит
следующее:
1. Значения регистров процессора исполняющегося в данный момент потока сохраняются в структуре контекста, которая располагается в ядре потока.
2. Из набора имеющихся потоков выделяется тот, которому будет передано управление. Если выбранный поток принадлежит другому процессу, Windows переключает для процессора виртуальное адресное пространство. Только после этого
возможно выполнение какого-либо кода или доступ к каким-либо данным.
3. Значения из выбранной структуры контекста потока загружаются в регистры
процессора.

После переключения контекста процессор исполняет выбранный поток, пока
не истечет выделенное потоку время, после этого снова происходит переключение
контекста. Windows делает это примерно каждые 30 мс. Никакого выигрыша в производительности или потреблении памяти переключение контекстов не дает. Оно требуется только для того, чтобы операционная система была надежной и быстро
реагировала на действия конечных пользователей.

Не стоит забывать и о том, что компьютер с несколькими процессорами может
исполнять несколько потоков одновременно, что улучшает масштабируемость
системы (способность выполнения большей работы за меньшее время). Каждому
ядру процессора назначается свой поток, и это ядро организует собственное переключение контекстов. Операционная система следит за тем, чтобы один поток не
планировался одновременно на нескольких ядрах, так как это привело бы к хаосу. 


Если думать только о производительности, оптимальное число потоков на машине
должно быть равно числу установленных на ней процессоров, в таком случае не будет переключения контекста



причины не пользовать пулом потоков, а создавать его явно
-Поток требуется запустить с нестандартным приоритетом (все потоки пула
выполняются с обычным приоритетом). Хотя изменить приоритет можно, но
делать это не рекомендуется, кроме того, изменение приоритета не сохраняется
между операциями с пулом потоков
-Чтобы приложение не закрылось до завершения потоком задания, требуется,
чтобы поток исполнялся в фоновом режиме. Эта тема подробно рассмотрена
в разделе «Фоновые и активные потоки» далее в этой главе. Потоки из пула
всегда являются фоновыми, и существует риск, что они не успеют выполнить
задание из-за того, что CLR решит завершить процесс
-Задания, связанные с вычислениями, обычно выполняются крайне долго; для
подобных заданий я не стал бы отдавать решение о необходимости создания
нового потока на откуп логике пула потоков.
-Возможно возникнет необходимость преждевременно завершить исполняющийся поток методом Abort класса Thread


создание объекта c# потока -быстро, ту не создается сам поток в системе
поток создается при методе start



подождать поток .Join();


Windows называют многопоточной операционной системой с вытесняющей
многозадачностью, потому что каждый поток может быть остановлен в произвольный момент времени и вместо него выбран для исполнения другой.


Каждому потоку назначается уровень приоритета с нулевого (самого низкого)
до 31 (самого высокого). При выборе потока, который будет передан процессору,
сначала рассматриваются потоки с самым высоким приоритетом и ставятся в очередь в цикле. 
Потоки с высоким приоритетом всегда исполняются перед потоками с низким
приоритетом вне зависимости от того, какие задания выполняют последние. Если
в системе работает поток с приоритетом 5 и система определяет, что поток с более
высоким приоритетом готов к работе, исполнение немедленно приостанавливается (даже если поток находится в середине такта) и процессору передается
новый поток
В процессе загрузки система создает поток обнуления страниц (zero page thread),
которому назначается нулевой приоритет. Это единственный поток в системе с таким приоритетом. Его задача состоит в обнулении свободных страниц и исполняется
он только при отсутствии других потоков.


При разработке приложения следует решить, должно ли оно реагировать быстрее
или медленнее, чем другие запущенные на этой же машине приложения. В соответствии с этим решением выбирается класс приоритета для процесса. В Windows
поддерживаются шесть классов приоритетов: Idle (холостого хода), Below Normal
(ниже обычного), Normal (обычный), Above Normal (выше обычного), High (высокий) и Realtime (реального времени). По умолчанию выбирается приоритет Normal,
он же является самым распространенным.

 В Windows поддерживаются семь относительных приоритетов
потоков: Idle (холостого хода), Lowest (самый низкий), Below Normal (ниже обычного), Normal (обычный), Above Normal (выше обычного), Highest (самый высокий)
и Time-Critical (требующий немедленной обработки). Эти приоритеты соотносятся с классами приоритетов процесса. По умолчанию для потоков используется
обычный приоритет, соответственно, он применяется чаще всего.

. Определение уровня приоритета определяется на основе класса приоритета
процесса и относительного приоритета потока (742 clr vai c#)

В CLR все потоки делятся на активные (foreground) и фоновые (background). При
завершении активных потоков в процессе CLR принудительно завершает также
все запущенные на этот момент фоновые потоки. При этом завершение фоновых
потоков происходит немедленно и без появления исключений.
Следовательно, активные потоки имеет смысл использовать для исполнения
заданий, которые обязательно требуется завершить


Поток можно превращать из активного в фоновый и обратно. Основной поток
приложения и все потоки, в явном виде созданные путем конструирования объекта
Thread, по умолчанию являются активными. А вот потоки из пула по умолчанию
являются фоновыми. Также потоки, создаваемые машинным кодом и попадающие
в управляемую среду исполнения, помечаются как фоновые.

 // Превращение потока в фоновый
 t.IsBackground = true;



#pool #threadpool
можно задать максимальное количество потоков в пуле, но делать так не стоит
среда CLR способна управлять собственным пулом потоков, то есть набором готовых
потоков, доступных для использования приложениями. Для каждого экземпляра
CLR существует свой пул, используемый всеми доменами приложений, находящимися под управлением экземпляра CLR. Если в один процесс загружаются
несколько экземпляров CLR, для каждого из них формируется собственный пул

При инициализации CLR пул потоков пуст. В его внутренней реализации поддерживается очередь запросов на выполнение операций. Для выполнения приложением
асинхронной операции вызывается метод, размещающий соответствующий запрос
в очереди пула потоков. Код пула извлекает записи из очереди и распределяет их
среди потоков из пула. Если пул пуст, создается новый поток. Как уже отмечалось,
создание потока отрицательно сказывается на производительности. Однако по
завершении исполнения своего задания поток не уничтожается, а возвращается
в пул и ожидает следующего запроса. Поскольку поток не уничтожается, производительность не страдает.

Когда приложение отправляет пулу много запросов, он пытается обслужить их
все с помощью одного потока. Однако если приложение создает очередь запросов
быстрее, чем поток из пула их обслуживает, создаются дополнительные потоки.
Такой подход позволяет обойтись при обработке запросов небольшим количеством
потоков.
Когда приложение прекращает отправлять запросы в пул, появляются незанятые
потоки, впустую занимающие память. Поэтому через некоторое время бездействия
(различное для разных версий CLR) поток пробуждается и самоуничтожается, освобождая ресурсы. Это опять отрицательно сказывается на производительности, но в
данном случае это уже не столь важно, поскольку уничтожаемый поток все равно простаивал, а значит, приложение в данный момент не было особо загружено работой.

Для добавления в очередь пула потоков асинхронных вычислительных операций
обычно вызывают один из следующих методов класса ThreadPool:
static Boolean QueueUserWorkItem(WaitCallback callBack);
static Boolean QueueUserWorkItem(WaitCallback callBack, Object state);
Эти методы ставят «рабочий элемент» вместе с дополнительными данными
состояния в очередь пула потоков и сразу возвращают управление приложению.
Рабочим элементом называется указанный в параметре callback метод, который
будет вызван потоком из пула. Этому методу можно передать один параметр
через аргумент state (данные состояния). Без этого параметра версия метода
QueueUserWorkItem передает методу обратного вызова значение null. Все заканчивается тем, что один из потоков пула обработает рабочий элемент, приводя к вызову
указанного метода. Создаваемый метод обратного вызова должен соответствовать
делегату System.Threading.WaitCallback, который определяется так:
delegate void WaitCallback(Object state);

Если метод обратного вызова генерирует необработанное исключение, CLR завершает процесс (если это не противоречит политике хоста)

С каждым потоком связан определенный контекст исполнения. Он включает в себя параметры безопасности (сжатый стек, свойство Principal объекта
Thread и идентификационные данные Windows), параметры хоста (System.
Threading.HostExecutionContextManager) и контекстные данные логического
вызова (см. методы LogicalSetData и LogicalGetData класса System.Runtime.
Remoting.Messaging.CallContext)

По умолчанию CLR автоматически копирует контекст исполнения самого
первого потока во все вспомогательные потоки. Это гарантирует безопасность,
но в ущерб производительности, потому что в контексте исполнения содержится
много информации. Сбор всей информации и ее копирование во вспомогательные
потоки занимает немало времени. Вспомогательный поток может, в свою очередь, использовать вспомогательные потоки, при этом создаются и инициализируются
дополнительные структуры данных.
Класс ExecutionContext в пространстве имен System.Threading позволяет
управлять копированием контекста исполнения потока. Вот как он выглядит:
public sealed class ExecutionContext : IDisposable, ISerializable {
 [SecurityCritical] public static AsyncFlowControl SuppressFlow();
 public static void RestoreFlow();
 public static Boolean IsFlowSuppressed();
 // Не показаны редко применяемые методы
}



// Помещаем данные в контекст логического вызова потока метода Main
 CallContext.LogicalSetData("Name", "Jeffrey");
 // Заставляем поток из пула работать
 // Поток из пула имеет доступ к данным контекста логического вызова
 ThreadPool.QueueUserWorkItem(
 state => Console.WriteLine("Name={0}",
 CallContext.LogicalGetData("Name")));
 // Запрещаем копирование контекста исполнения потока метода Main
 ExecutionContext.SuppressFlow();



#cancel
Этот объект содержит все состояния, необходимые для управляемой отмены.
После создания объекта #CancellationTokenSource (ссылочный тип) получить один или несколько экземпляров #CancellationToken (значимый тип) можно из
свойства Token

Чтобы предотвратить отмену операции, ей можно передать экземпляр
CancellationToken, возвращенный статическим свойством None структуры
CancellationToken. Это очень удобное свойство возвращает специальный экземпляр
CancellationToken, не связанный с каким-либо объектом CancellationTokenSource (его
закрытое поле имеет значение null).


можно зарегистрировать один или несколько методов таким
образом, чтобы они вызывались при отмене объекта CancellationTokenSource. метод Register
varcts = new CancellationTokenSource();
cts.Token.Register(() => Console.WriteLine("Canceled 1"));
cts.Token.Register(() => Console.WriteLine("Canceled 2"));



// Создание нового объекта CancellationTokenSource,
// отменяемого при отмене cts1 или ct2
var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
 cts1.Token, cts2.Token);


отмена по таймеру
public sealed class CancellationTokenSource : IDisposable { // Ссылочный тип
 public CancellationTokenSource(Int32 millisecondsDelay);
 public CancellationTokenSource(TimeSpan delay);
 public void CancelAfter(Int32 millisecondsDelay);
 public void CancelAfter(TimeSpan delay);
 ...
}


для таски можно написать класс расширения что бы удобно отменять их
clr via c# стр 814















#Process
public static Process Start(string имя_файла)
//"просит" закрыться
public void Close()
public bool CloseMainWindow() //Если процесс является приложением Windows с графическим пользовательским интерфейсом, true-сообщение получено,false-приложение не имеет главного окна
//закрывает
неконтролируемому прерыванию процесса. Любые несохраненные данные, связанные с прерываемым процессом, будут, скорее всего, потеряны.
public void Kill()
//ждать закрытия
public void WaitForExit()
public bool WaitForExit(int миллисекунд)// false, если он все еще выполняется.





новое


//попытается распараллелить методы, вызывающий поток останавливается и ждет результаты
public static void Invoke(params Action[] actions)

#for
public delegate void Action<in T>(T obj)
public static ParallelLoopResult For (int fromInclusive, int toExclusive, Action<int> body)
первый параметр задает начальный индекс элемента в цикле, а второй параметр - (конечный индекс не включая , i<toExclusive). 
Третий параметр - делегат Action - указывает на метод, который будет выполняться один раз за итерацию
Parallel.For(1, 10, Factorial);
void Factorial(int x)
{}

break так же как в обычном for
public static ParallelLoopResult For(int fromInclusive, int toExclusive, Action<int, ParallelLoopState> body)
public delegate void Action<in T1, in T2>(T argl, T2 arg2)//T1-int T2-ParallelLoopState

#ParallelLoopState
public void Break()//все шаги до вызова выполнятся, несколько может выполниться и после вызова
Stop()//если не волнует выполнение шагов

#ParallelLoopResult-
public bool IsCompleted { get; }//определяет, завершилось ли полное выполнение параллельного цикла
public Nullable<long> LowestBreakIteration { get; }//если выполнение прервется, то будет содержать переменную-итертор на которой все прервалось(возвращает индекс, на котором произошло прерывание работы цикла)


есть также формы -
 указывать метод, вызываемый по завершении потока каждого цикла.
др.



#ForEach
public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, Action<TSource> body)
public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, Actior<TSource, ParallelLoopState> body)
ParallelLoopResult result = Parallel.ForEach<int>(new List<int>() { 1, 3, 5, 8 },
                Factorial);

остальное см For










 
//остановить задачу #cancel #CancellationTokenSource #CancellationToken
//вне задачи объявить
 CancellationTokenSource cancelTokenSource = new CancellationTokenSource();
    CancellationToken token = cancelTokenSource.Token;
//остановить 
cancelTokenSource.Cancel();
cancelTokenSource.CancelAfter(TimeSpan.FromSeconds(1));
await Task.Delay(TimeSpan.FromSeconds(1.5), source.Token);//#TODO #delay
//в task
if (token.IsCancellationRequested)
            {
                return;//отменить задачу
            }

//если операция внешняя передавать ссылку на токен
Task task1 = new Task(() => Factorial(5, token));
void Factorial(int x, CancellationToken token)
{



//прерывание операции в цикле
//также объявить токен и в любом потоке также отменить
//в другом потоке где нужны циклы
try
    {   
        Parallel.ForEach<int>(new List<int>() { 1,2,3,4,5,6,7,8}, 
                                new ParallelOptions { CancellationToken=token}, Factorial);
        // или так
        //Parallel.For(1, 8, new ParallelOptions { CancellationToken = token }, Factorial);
    }
    catch(OperationCanceledException ex)
    {
        Console.WriteLine("Операция прервана");
    }
    finally
    {
        cancelTokenSource.Dispose();
    }


Асинхронные делегаты
public delegate int DisplayHandler();
//выполняем в ассинхронном режиме
//Первый параметр представляет делегат System.AsyncCallback  AsyncCallback указывает на метод, который будет выполняться в результате завершения работы асинхронного делегата
//Второй параметр представляет произвольный объект, с помощью которого мы можем передать дополнительную информацию в метод завершения, указанный в предыдущем параметре. 
IAsyncResult resultObj = handler.BeginInvoke(null, null);
//ждет выполнения
int result = handler.EndInvoke(resultObj);


//с параметрами
// добавляем параметр в делегат и в сам метод
 public delegate int DisplayHandler(int k);
int Display(int k)
        {}
//метод который будет вызываться по завершению
static void AsyncCompleted(IAsyncResult resObj)
        {
            string mes = (string)resObj.AsyncState;//Асинхронные вызовы
}
DisplayHandler handler = new DisplayHandler(Display);
 //1- параметр в метод 2- метод после завершения 3-параметр для метода после завешения
            IAsyncResult resultObj = handler.BeginInvoke(10, new AsyncCallback(AsyncCompleted), "Асинхронные вызовы");

            int res = handler.EndInvoke(resultObj);






#async и #await

ассинхронные методы -суффикс Async

await. Их нельзя применять в блоках catch или finally, в неасинхронных
анонимных функциях, в теле оператора lock или в небезопасном коде

var w=async ()=>return 1;

async void DisplayResultAsync()
    {
//возращает int тк есть await если его нет то возвращает task
int result = await FactorialAsync(num);
}
static Task<int> FactorialAsync(int x)
    {
return Task.Run(() =>
        {});

//вызвать метод
DisplayResultAsync();
||
Task t = DisplayResultAsync();
    t.Wait();
||
//.GetAwaiter(), который остановит выполнение в вызывающем потоке, пока задача не завершится, и .GetResult(), который возвращает результат
DisplayResultAsync().GetAwaiter().GetResult();

//ждать выполнения всех задач
 Task<int> t1 = FactorialAsync(num1);
await Task.#WhenAll(new[] { t1, t2, t3 });
 var gg=t1.Result



#GetAwaiter #TaskAwaiter #GetResult
Task<TResult>.GetAwaiter() возвращает объект TaskAwaiter<TResult>, который имеет метод GetResult(), возвращающий TResult

#TODO
Task.Yield(), который возвращает структуру YieldAwaitable она имеет метод GetAwaiter(), возвращающий структуру Yield
Awaitable.YieldAwaiter, которая содержит метод GetResult(), возвращающий void
await Task.Yield();



#ef #core нужно использовать async только там где происходит реальная работа с данными(например FirstOrDefaultAsync или SaveChangesAsync), 
но НЕ надо использовать там где ее нет(например Add Remove)







#PLINQ #Parallel #LINQ
Основу PLINQ составляет класс #ParallelEnumerable



при возникновении ошибки в 1 потоке прерываются все

#AsParallel выполение запроса разбивая задачу на потоки
//будет обрабатывать коллекцию не по порядку если так будет быстрее и если не быстрее то обработает как обычно
var factorials = numbers.AsParallel().Select(x => Factorial(x));

#ForAll
.ForAll(n => Console.WriteLine(n));
ForAll выполняет действие в каждом потоке для той части которая находится в нем
без ForAll происходит склейка данных в 1 потоке и потом действие для всех элементов

#AsOrdered()
public static ParallelQuery<TSource> AsOrdered<TSource>(this ParallelQuery<TSource> source)
.AsParallel().AsOrdered()//именно так, вместе не разделяя другими linq
разделяем на потоки и потом выставляем в том порядке как было бы если бы не разделяли
#TODO

#AsUnordered()
разупорядочивание , если мы упорядочили но дальше какие то операции которые не требуют порядка, ускорит все


AsUnordered(). Делает упорядоченный запрос неупорядоченным; если упорядоченные результаты нужны только в первой части запроса, то этот метод позволит последующим этапам
запроса выполняться более эффективно.
#WithCancellation(). Указывает маркер отмены для использования с этим запросом. Маркеры отмены применяются в Parallel Extensions, позволяя отменять задачи в безопасной и
контролируемой манере.
#WithDegreeOfParallelism(). Позволяет указывать максимальное количество параллельных задач, используемых для выполнения запроса. Этот метод можно применять для ограничения количества используемых потоков во избежание перегрузки машины работой или
наоборот — увеличения числа потоков в случае, если запрос не задействует интенсивно... указать максимальное количество процессоров, выделяемых для обработки запроса
центральный процессор.
#WithExecutionMode(). Может применяться для принудительного выполнения запроса в
параллельном режиме, даже если Parallel LINQ считает, что запрос будет выполняться быстрее в однопоточном режиме.
когда PLINQ должен по умолчанию поддерживать последовательное выполнение, передать методу в качестве параметра признак ParallelExecutionMode.ForceParallelism.

#AsSequential()//запросить последовательное выполнение части параллельного запроса
#WithMergeOptions(). Позволяет подстраивать буферизацию результатов. Отключение буферизации сокращает промежуток времени перед возвращением первого результата, но также
уменьшает пропускную способность; полная буферизация обеспечивает наивысшую пропускную способность, но результаты не будут возвращаться до тех пор, пока запрос не выполнится полностью. Стандартная настройка является компромиссом между этими двумя случаями.




обработка ошибок 
catch (AggregateException ex)
{
    foreach (var e in ex.InnerExceptions)
    {
        Console.WriteLine(e.Message);
    }
}

отмена параллельной операции #cancel #CancellationTokenSource
CancellationTokenSource cts = new CancellationTokenSource();
 cts.Cancel();// установить токен для отмены
try{
numbers.AsParallel().WithCancellation(cts.Token)
}
catch(OperationCanceledException ex)
    {
        Console.WriteLine("Операция была прервана");
    }

foreach(var v in mass.AsParallel())//цикл прервется если в другом потоке Cancel();



#TODO  #IOrderedEnumerable<T> #ParallelQuery



#Range #ParallelEnumerable

ParallelEnumerable.Range() лучше чем -
Enumerable.Range().AsParallel();// но работают оба






#синхронизация #lock




есть 3 типа синхронизации
1 Примитивные конструкции пользовательского режима 
2 Примитивные конструкции режима ядра
3 комбинированные (гибридные)


То есть если поток пула пытается получить
доступ к запертому ресурсу и не получает его, скорее всего, пул создаст еще один
поток для сохранения загрузки процессора.  Но хуже всего то, что после разблокирования старый поток появляется
в пуле вместе с новым; то есть операционной системе приходится планировать
выполнение потоков, количество которых превышает количество процессоров,
а значит, увеличивается частота переключений контекста, что, опять же, отрицательно сказывается на производительности.


!!!
Старайтесь по возможности работать со значимыми типами, потому что они
всегда копируются, и каждый поток в итоге работает с собственной копией. Ну и,
наконец, нет ничего страшного в одновременном доступе разных потоков к общим
данным, если эти данные предназначены только для чтения.


тип 1 пользовательского режима 
По возможности нужно задействовать их
так как они значительно быстрее
вторых и используют для координации потоков специальные директивы процессора. То есть координация имеет место уже на аппаратном уровне (и именно это
обеспечивает быстродействие). Однако одновременно это означает, что блокировка
потоков на уровне примитивной конструкции пользовательского режима операционной системой Windows просто не распознается. А так как заблокированным
таким способом поток пула не считается таковым, пул не создает дополнительных
потоков для восполнения загрузки процессора. Кроме того, блокировка происходит
на очень короткое время

 поток, который
пытается, но не может получить некоторый ресурс, начинает циклически существовать в пользовательском режиме. Потенциально это является пустым расходованием
времени процессора, которое лучше было бы потратить с пользой — или просто
разрешить процессору простаивать для экономии энергии.


тип 2 еще делится на 3 типа
#Volatile-конструкции выполняют для переменной, содержащей данные простого #TODO
типа, атомарную операцию чтения или записи

Interlocked-конструкции выполняют для переменной, содержащей данные простого типа, атомарную операцию чтения и записи.
выполняются атомарно, ставится барьер

#SpinLock
надо убедиться что они никуда не передаются, тк они копируются
нельзя помечать readonly


тип 2 режима ядра

К примитивным конструкциям синхронизации потоков в режиме ядра относятся события (events) и семафоры (semaphores). На их основе строятся 
более сложные конструкции аналогичного назначения, например мьютексы
(mutex)
классы AutoResetEvent, ManualResetEvent, Semaphore
и Mutex являются производными от класса WaitHandle, то есть наследуют методы
этого класса и их поведение.


Конструкции режима ядра часто используются для создания приложений, которые в любой момент времени могут существовать только в одном экземпляре. 


 Они
предоставляются самой операционной системой Windows и требуют от потоков
приложения вызова функций, реализованных в ядре. Переход потока между пользовательским режимом и режимом ядра требует значительных затрат ресурсов,
поэтому конструкций режима ядра крайне желательно избегать

Если один поток использует конструкцию режима ядра для
получения доступа к ресурсу, с которым уже работает другой поток, Windows блокирует его, чтобы не тратить понапрасну время процессора. А затем, когда ресурс
становится доступным, блокировка снимается, и поток получает доступ к ресурсу.

Если поток, использующий в данный момент конструкцию, не освободит ее,
ожидающий конструкции поток может оказаться заблокированным навсегда. В этом
случае в пользовательском режиме поток бесконечно исполняется процессором;
этот вариант блокировки называется активной (живой) блокировкой (livelock)

Многие из конструкций синхронизации потоков в CLR являются всего лишь объектно-ориентированными оболочками классов, построенных на базе конструкций
синхронизации потоков Win32. В конце концов, CLR-потоки являются потоками
операционной системы Windows, которая планирует и контролирует их синхронизацию


Для синхронизации потоков в Windows существует несколько конструкций режима
ядра. Они работают намного медленнее конструкций пользовательского режима,
так как требуют координации со стороны операционной системы. Кроме того,
каждый вызов метода для объекта ядра заставляет вызывающий поток перейти из
управляемого в машинный код, затем в код режима ядра, после чего возвращается
назад. Такие переходы требуют много процессорного времени и их частое выполнение значительно снижает производительность приложения.
Впрочем, у конструкций режима ядра есть и свои преимущества перед конструкциями пользовательского режима:

-Если конструкция режима ядра выявляет конкуренцию за ресурс, Windows
блокирует проигравший поток, останавливая зацикливание, которое ведет к напрасному расходованию ресурсов процессора
-Конструкции режима ядра могут осуществлять взаимную синхронизацию неуправляемых и управляемых потоков
-Конструкции режима ядра умеют синхронизировать потоки различных процессов, запущенных на одной машине.
-Конструкции режима ядра можно наделить атрибутами безопасности, ограничивая несанкционированный доступ к ним
-Поток можно заблокировать, пока не станут доступны все конструкции режима
ядра или пока не станет доступна хотя бы одна такая конструкция
-Поток можно заблокировать конструкцией режима ядра, указав время ожидания;
если за указанное время поток не получит доступа к нужному ему ресурсу, он
будет разблокирован и сможет выполнять другие задания.





Подытожим, каким образом ведут себя  примитива режима ядра
-При наличии нескольких потоков в режиме ожидания событие с автосбросом
освобождает только один из них
-Событие с ручным сбросом снимает блокировку со всех ожидающих его потоков.
-При наличии нескольких потоков, ожидающих семафора, его появление снимает
блокировку с потоков releaseCount (здесь releaseCount — это аргумент, переданный методу Release класса Semaphore).



тип 3 гибридные конструкции
В идеальном мире у нас были бы конструкции, сочетающие лучшие особенности
обоих типов: быстро работающие и не блокирующиеся (как конструкции пользовательского режима) в условиях отсутствия конкуренции. А если конструкции начинали бы соперничать друг другом, их блокировало бы ядро операционной системы

При отсутствии конкуренции потоков гибридные конструкции
дают даже более высокую производительность, чем простейшие конструкции
пользовательского режима. В них также применяются простейшие конструкции
режима ядра, что позволяет избежать зацикливания (пустой траты процессорного времени) при попытке нескольких потоков одновременно получить доступ
к процессору. Так как в большинстве приложений потоки редко конкурируют за
доступ к конструкции, повышение производительности способствует ускорению
работы приложения.





у каждого объекта есть блок синхронизации(или такова изначальная задумка) #TODO
Очевидно, что привязка блока синхронизации к каждому объекту в куче является достаточно расточительной, особенно если учесть тот факт, что большинство объектов никогда не пользуются этим блоком. Чтобы снизить потребление
памяти, разработчики CLR применили более эффективный вариант реализации
описанной функциональности. Во время инициализации CLR выделяется массив
блоков синхронизации. Как уже не раз упоминалось в этой книге, при создании
объекта в куче с ним связываются два дополнительных служебных поля. Первое
поле — указатель на объект-тип — содержит адрес этого объекта в памяти. Второе поле содержит индекс блока синхронизации (sync block index), то есть индекс
в массиве таких блоков.





В FCL существует четыре безопасных в отношении потоков класса коллекций, принадлежащих пространству имен System.Collections.#Concurrent: #ConcurrentQueue,
#ConcurrentStack, #ConcurrentDictionary и #ConcurrentBag
Эти классы коллекций являются неблокирующими. При попытке извлечь несуществующий элемент поток немедленно возвращает управление, а не блокируется,
ожидая появления элемента. Именно поэтому такие методы, как TryDequeue, TryPop,
TryTake и TryGetValue, при получении элемента возвращают значение true, а при
его невозможности — false.

Обратите внимание, что все рассматриваемые классы обладают методом
GetEnumerator, обычно используемым в инструкции C# foreach, но допустимым
и в языке LINQ. Для классов ConcurrentStack, ConcurrentQueue и ConcurrentBag
метод GetEnumerator создает снимок содержимого коллекции и возвращает зафиксированные элементы; при этом реальное содержимое коллекции уже может
измениться. Метод GetEnumerator класса ConcurrentDictionary не фиксирует 
содержимое коллекции, а значит, в процессе просмотра словаря его вид может
поменяться; об этом следует помнить. Свойство Count возвращает количество
элементов в коллекции на момент запроса. Если другие потоки в это время добавляют элементы в коллекцию или извлекают их оттуда, возвращенное значение
может оказаться неверным







#Interlocked
тоже самое что и lock но быстрее и проще, для блокировки простых типов, аналог атомарных операций
CompareExchange()	Безопасно проверяет два значения на эквивалентность. Если они эквивалентны, изменяет одно из значений на третье
public static int Decrement(ref int location)	Безопасно уменьшает значение на 1
Exchange()	Безопасно меняет два значения местами
public static int Increment(ref int location)	Безопасно увеличивает значение на 1
//+возвращает это же число
int newVal = Interlocked.Increment(ref intVal);
Interlocked.Exchange(ref mylnt, 83);





#ManualResetEventSlim #SemaphoreSlim
Они функционируют точно так же,
как их аналоги режима ядра, отличаясь только зацикливанием в пользовательском 
режиме, а также тем, что они не создают конструкций режима ядра до возникновения конкуренции. Их методы Wait позволяют передать информацию о времени
ожидания и объект CancellationToken



#ReaderWriterLockSlim

#OneManyLock - не официальная, вроде должна быть норм
#CountdownEvent

#Barrier
выставляются что бы 1 участок был пройден разными потоками одновременно


#SemaphoreSlim
есть метод WaitAsync






#Monitor
обеспечивающий взаимоисключающее блокирование с зацикливанием, владением потоком и рекурсией.
всегда надо кидать в него private поле или локальное, никогда не кидать this, type, string, не ссылочный тип(тк будет упаковка и ничего не заблокируется вообще)

Monitor.Enter(obj);
Monitor.Exit(rnd);
у monitor есть метод TryEnter-- он заставляет ждать определенное время а не бесконечность

//эти методы могут вызываться только из заблокированного фрагмента кода(блок lock например)
//временно блокирует поток но  освобождает заблокированный объект пока не продолжит выполнение
поток продолжит выполнение когда другой поток войдет в аналогичное состояние блокировки,  вызывает метод Pulse() или PulseAll()
obj-объект разблокировку которого ожидаем
//останавливает поток и заставляет ждать пока для obj не вызовется Pulse из другого потока
public static bool Wait(object obj) 
public static bool Wait(object obj, int миллисекунд_простоя)
//разрешает заблокировать уже заблокированный obj тому кто следующий в очереди
public static void Pulse(object obj)  возобновляется выполнение первого потока ожидающего своей очереди на получение блокировки
public static void PulseAll(object obj) сигнализирует о снятии блокировки всем ожидающим потокам




#lock преобразуется в monitor
private object obj = new object();
lock (obj)
{
   // синхронизированная область для obj
}
//преобразуется в
private void SomeMethod() {
 Boolean lockTaken = false;
 try {
 //
 Monitor.Enter(this, ref lockTaken);
 // Этот код имеет монопольный доступ к данным...
 }
 finally {
 if (lockTaken) Monitor.Exit(this);
 }



if (Monitor.TryEnter(lockObject, 300)) {  
    try {  
        // Place code protected by the Monitor here.  
    }  
    finally {  
        Monitor.Exit(lockObject);  
    }  
}  
else {  
    // Code to execute if the attempt times out.  
}



#spinlock #SpinWait, #SemaphoreSlim и #CountdownEvent, #TODO




#Mutex #мьютекс


Мьютексы снабжены дополнительной логикой, что делает их более сложными
по сравнению с другими конструкциями. Во-первых, объекты Mutex сохраняют
информацию о том, какие потоки ими владеют. Для этого они запрашивают идентификатор потока (Int32). Если поток вызывает метод ReleaseMutex, объект Mutex
сначала убеждается, что это именно владеющий им поток. Если это не так, состояние
объекта Mutex не меняется, а метод ReleaseMutex генерирует исключение System.
ApplicationException. Если владеющий объектом Mutex поток по какой-то причине завершается, пробуждается другой поток, ожидающий мьютекса, и генерирует
исключение System.Threading.AbandonedMutexException.

мьютекс поддерживает рекурсию тк хранит в себе поток который его заблокировал

 private readonly Mutex m_lock = new Mutex();
 public void Method1() {
 m_lock.WaitOne();
 Method2(); // Метод Method2, рекурсивно получающий право на блокировку
 m_lock.ReleaseMutex();
 }
 public void Method2() {
 m_lock.WaitOne();
 m_lock.ReleaseMutex();
 }


public Mutex()
public Mutex(bool initiallyOwned)//если true то им завладевает вызывающий поток

public bool WaitOne(); // блокирует выполнение вызывающего потока до тех пор, пока не станет доступным указанный мьютекс
public void ReleaseMutex() //освобождает

создание именованного(виден не только в текущем процессе)
public Mutex(bool initiallyOwned, string имя)// если true, то владение мьютексом запрашивается
public Mutex(bool initiallyOwned, string имя, out bool createdNew) // createdNew будет иметь логическое значение true, если владение мьютексомбыло запрошено и получено, и логическое значение false, если запрос на владениебыл отклонен


в потоке, получившем мьютекс, допускается вызывать несколько WaitOne() перед вызовом метода
ReleaseMutex(), все эти вызовы будут произведены успешно. => дополнительные вызовы метода WaitOne() не будут блокировать
поток, который уже владеет мьютексом. Но количество вызовов метода WaitOne()
должно быть равно количеству вызовов метода ReleaseMutex() перед освобождением мьютекса.











#семафор  #Semaphore

разрешает доступ к участку не 1 потоку а количеству которое указали в конструкторе
при блокировке -- при икременте ++, если 0 то ждет пока станет >0

public Semaphore(int initialCount, int maximumCount)
initialCount - количество первоначально доступных разрешений
maximumCount — максимальное значение данного счетчика, т.е. максимальное количество разрешений, которые может дать семафор.

см мьютекс
WaitOne()
//return  подсчитанное количество разрешений, существовавших до высвобождения
public int Release()
public int Release(int releaseCount)


именованный семафор
public Semaphore(int initialCount, int maximumCount, string имя)
public Semaphore(int initialCount, int maximumCount, string имя,
out bool createdNew)










#event
1 поток ждет пока вызовется событие в другом потоке
public #ManualResetEvent(bool initialState)//если true, то о событии первоначально уведомляется
WaitOne()//ждем если объект "не активен"
Set()//в другом потоке вызываем событие, "активирует" объект
 Reset()//после вызова события объект события делаем "не активным", для разблокировки надо снова вызывать Set()



public #AutoResetEvent(bool initialState)
все как у ManualResetEvent но метод WaitOne() после того как дождался очереди вызывает Reset()







#Barrier Вынуждает потоки ожидать появления всех остальных потоков в указанной точке, называемой барьерной
#CountdownEvent Выдает сигнал, когда обратный отсчет завершается
#ManualResetEventSlim Это упрощенный вариант класса ManualResetEvent
#SemaphoreSlim Это упрощенный вариант класса Semaphore






attr #TODO
блокировка всего метода экземпляра(this). Если же метод относится к типу static, то блокируется его тип
[MethodImplAttribute(MethodImplOptions.Synchronized)]
применять очень аккуратно перечитать как и тд





#Synchronization]
#[Synchronization]
тоже синхронизация но такое





#ReaderWriterLock
блокировка только на запись













#Lazy

Lazy<Library> library = new Lazy<Library>();
library.Value;//создаст объект только тут!

#LazyInitializer.#EnsureInitialized - можно использовать вместо lazy

TODO 794 страница - надо записать







#рефлексия #reflection

#Nameof - строковое представление метода
WriteLine(nameof(person.Address.ZipCode)); // prints "ZipCode"

#typeof #GetType
получить тип
Type myType = typeof(className);
Type myType = object.GetType();
//1- полное название с namespace 2-генерить ли исключение если не найдено 3-учитывать ли регистр у 1 параметра
Type myType = Type.GetType("TestConsole.User", false, true);

Туре а1 = typeof (А<>)
Console.Write (a1.GetGenericArguments().Count())




myType.IsAbstract();
myType.IsClass();


Type: #MemberInfo
DeclaringType //тип класса или интерфейса в котором объявляется отражаемый член
MemberType //возвращает перечисление .тип члена. является ли член полем\методом\свойством\событием\конструктором
MetadataToken //
Name //имя файла
ReflectionType //тип отражаемого объекта

абстрактные методы
GetCustomAttributes // получить список спец атрибутов
IsDefined // проверить есть ли такой атрибут

ConstructorInfo[] GetConstructors() // получить список конструкторов
GetEvents()
GetFields()
GetMembers() //список членов
GetMethods()
GetProperties //список свойств

свойства только для чтения
Attribures //получить атрибуты
BaseType //получить непосредственный базовый тип 
FullName
IsAbstract
IsArray
IsClass
IsEnum
IsGenericType //если обобщенный
Namespace


var mth=GetMethods([BindingFlags fl1|BindingFlags f2|...]);//fl-перечисление которое сообщает какие именно методы нужны

BindingFlags.  //если указан 1 значение перечисление и метод не возвращается, указать еще через | но те которые не противоречат
DeclaredOnly: получает только методы непосредственно данного класса, унаследованные методы не извлекаются
Instance: получает только методы экземпляра
NonPublic: извлекает не публичные методы
Public: получает только публичные методы
Static: получает только статические методы


foreach(var i in mth){
//вызов метода
i.Invoke(reflect_obj,args)//reflect_obj - объект для которого будет вызываться метод
i.Invoke(null,args)//reflect_obj - static метод
i.Invoke(null,null)//reflect_obj - static метод, не передаем параметры
i.ReturnType.Name
i.Name
var prms=i.GetParameters();
foreach(var p in prms){
p.ParameterType.Name
p.Name
}
}

var cons=GetConstructors();
foreach(var i in cons){
(object)i.Invoke(args);
}


var instance = FormatterServices.GetUninitializedObject(Type a);//создать объект сам достанет конструктор и вызовет, даже если у него есть параметры





ОБОБЩЕНИЯ
typeof(List<>)//вернет List'1[Т] , где 1 -количество параметров
typeof(Dictionary<,>)//Dictionary'2[ТКеу,TValue]
typeof(List<X>)//List'1[System.Int32]
typeof(Dictionary<string,X>

//такое, все вернет true
string listTypeName = "System.Collections.Generic.List'1";
Type defByName = Type.GetType(listTypeName);
Type closedByName = Type.GetType(listTypeName + "[System.String]");
Type closedByMethod = defByName.MakeGenericType(typeof(string));
Type closedByTypeof = typeof(List<string>);
Console.WriteLine(closedByMethod == closedByName);
Console.WriteLine(closedByName == closedByTypeof);
Type defByTypeof = typeof(List<>);
Type defByMethod = closedByName.GetGenericTypeDefinition();
Console.WriteLine(defByMethod == defByName);
Console.WriteLine(defByName == defByTypeof);


обобщенные методы
public static void PrintTypeParameter<T>()
{
Console.WriteLine(typeof(T));
}
...
Type type = typeof(Snippet);
MethodInfo definition = type.GetMethod("PrintTypeParameter");
MethodInfo constructed = definition.MakeGenericMethod(typeof(string));
constructed.Invoke(null, null);









#Assembly
если есть exe\dll то все тоже самое можно делать с помощью этого

var a=Assembly.LoadFrom(string path)
a.GetTypes();
//дальше просто с помощью рефлексии можно делать что угодно






#TypeInfo

Type typeReference = ...; // Например: o.GetType() или typeof(Object)
TypeInfo typeDefinition = typeReference.GetTypeInfo();
И хотя эта возможность менее полезна, объект TypeInfo можно преобразовать
в объект Type вызовом метода AsType класса TypeInfo.
TypeInfo typeDefinition = ...;
Type typeReference = typeDefinition.AsType();



Среда CLR не требует, чтобы у значимого типа был конструктор. И это создает проблемы, так как все перечисленные механизмы создают объект путем вызова его конструктора. Однако версии метода CreateInstance типа Activator позволяют создавать
экземпляры значимых типов без вызова их конструкторов. Чтобы создать экземпляр
значимого типа, не вызывая его конструктор, нужно вызвать версию CreateInstance,
принимающую единственный параметр Type, или версию, принимающую параметры
Type и Boolean.

Эти механизмы позволяют создавать объекты любых типов, кроме массивов
(то есть типов, производных от System.Array) и делегатов (потомков типа System.
MulticastDelegate)

Чтобы создать массив, надо вызвать статический метод CreateInstance объекта Array
Для создания делегата следует вызвать статический метод CreateDelegate объекта Delegate

generic
Для создания экземпляра обобщенного типа сначала нужно получить ссылку на
открытый тип, а затем вызвать открытый экземплярный метод MakeGenericType
объекта Type, передав массив типов, который нужно использовать в качестве параметров типа. Затем надо получить возвращенный объект Type и передать его в один
из описанных ранее методов
 // Получаем ссылку на объект Type обобщенного типа
 Type openType = typeof(Dictionary<,>);
 // Закрываем обобщенный тип, используя TKey=String, TValue=Int32
 Type closedType = openType.MakeGenericType(
 new Type[] { typeof(String), typeof(Int32) });
 // Создаем экземпляр закрытого типа
 Object o = Activator.CreateInstance(closedType);


type & #MemberInfo сохраняются в определенной коллекции. Позже приложение ищет нужный объект в
коллекции и вызывает его
объекты Type и объекты, производные от MemberInfo, занимают много места в памяти
Внутренние механизмы CLR поддерживают более компактную форму хранения
этой информации. CLR создает такие объекты в приложениях лишь для того, чтобы
упростить работу программиста. Самой среде CLR для работы эти большие объекты  не нужны

можно сократить потребление памяти, если
использовать не объекты, а описатели времени выполнения. В FCL определены
три типа таких описателей (все в пространстве имен System): #RuntimeTypeHandle,
#RuntimeFieldHandle и #RuntimeMethodHandle. 
Все они — значимые типы с единственным полем IntPtr; за счет чего расходуют очень мало ресурсов (то есть памяти).
Поле IntPtr представляет собой дескриптор, ссылающийся на тип, поле или метод
в куче загрузчика домена приложений. Так что теперь нам достаточно научиться
просто и эффективно преобразовывать «тяжелые» объекты Type и MemberInfo
в «легкие» дескрипторы времени выполнения, и наоборот. Это не сложно, если
задействовать перечисленные далее методы и свойства.
-Чтобы преобразовать объект Type в RuntimeTypeHandle, вызовите статический
метод GetTypeHandle объекта Type, передав ему ссылку на объект Type
-Чтобы преобразовать RuntimeTypeHandle в объект Type, вызовите статический
метод GetTypeFromHandle объекта Type, передав ему RuntimeTypeHandle
-Чтобы преобразовать объект FieldInfo в RuntimeFieldHandle, запросите экземплярное неизменяемое свойство FieldHandle объекта FieldInfo
-Чтобы преобразовать RuntimeTypeHandle в объект FieldInfo, вызовите статический метод GetTypeFromHandle объекта FieldInfo
-Чтобы преобразовать объект MethodInfo в RuntimeMethodHandle, запросите
экземплярное неизменяемое свойство MethodHandle объекта MethodInfo
-Чтобы преобразовать RuntimeTypeHandle в объект MethodInfo, вызовите статический метод GetMethodFromHandle объекта MethodInfo.


List<RuntimeMethodHandle> methodHandles =
 methodInfos.ConvertAll<RuntimeMethodHandle>(mb => mb.MethodHandle);
methodInfos = methodHandles.ConvertAll<MethodBase>(
 rmh=> MethodBase.GetMethodFromHandle(rmh));













#LINQ
для параллельного выполнения см PLINQ
применяется для IEnumerable<T>, #IQueryable<T>  (реализованы как методы расширения в System.Linq.Enumerable)

формирование запроса
var t=from n in nums where n>0 select n;
var t=nums.where(x1=>x1>0);
выполнение запроса
t.Count();
t.ToList();
//изменить nums
t.ToList();//другой результат если применяем к IQueryable


//результат-каждый элемент mass1 с каждым элементом mass2
from x1 in mass1
from x2 in mass2
select new{x1,x2};



если команда применяется к data типу, то она не вернет null (int[]).FirstOrDefault(x1=>)==null//не правильно тк null не вернется
что бы не 0 возвращалось 
int? nullableId = GetNonNullableInts().Cast<int?>().FirstOrDefault();


//#TODO хз можно ли так
var people = db.People.Where("it.Name LIKE @searchTerm", new ObjectParameter("searchTerm", searchTerm));
//не получилось вызвать like
from c in dc.Organization where #SqlMethods.Like(c.Hierarchy, "%/12/%") select *;



#Select: определяет проекцию выбранных значений, если написать Select(x1=>x1); то это будет удалено компилятором но только если запрос не состоит только из него
#Where: определяет фильтр выборки, если использовать несколько то результатом будет последовательность элементов в который ВСЕ удовлетворяют ВСЕМ предикатам



#OrderBy: упорядочивает элементы по возрастанию
#OrderByDescending: упорядочивает элементы по убыванию
#ThenBy: задает дополнительные критерии для упорядочивания элементов возрастанию
метод OrderBy() принимает на себя ответственность за первичный контроль над упорядочением, тогда как метод ThenBy() служит средством для выполнения одного или более последующих упорядочений. В LINQ to Objects метод
ThenBy() определен только как расширяющий для интерфейса IOrderedEnumerable<T>, который представляет собой тип, возвращаемый методом OrderBy() (и самим методом ThenBy(),
чтобы позволить дальнейшее выстраивание в цепочку).




#ThenByDescending: задает дополнительные критерии для упорядочивания элементов по убыванию
#Join: соединяет две коллекции по определенному признаку
#GroupBy: группирует элементы по ключу
#ToLookup: группирует элементы по ключу, при этом все элементы добавляются в словарь
#GroupJoin: выполняет одновременно соединение коллекций и группировку элементов по ключу
#Reverse: располагает элементы в обратном порядке
#All: определяет, все ли элементы коллекции удовлятворяют определенному условию
#Any: определяет, удовлетворяет хотя бы один элемент коллекции определенному условию
#Contains: определяет, содержит ли коллекция определенный элемент
#Distinct: удаляет дублирующиеся элементы из коллекции
#Except: возвращает разность двух коллекций, то есть те элементы, которые содержатся только в одной коллекции
#Union: объединяет две однородные коллекции
#Intersect: возвращает пересечение двух коллекций, то есть те элементы, которые встречаются в обоих коллекциях
#Count: подсчитывает количество элементов коллекции, которые удовлетворяют определенному условию
#Sum: подсчитывает сумму числовых значений в коллекции
#Average: подсчитывает cреднее значение числовых значений в коллекции
#Min: находит минимальное значение
#Max: находит максимальное значение
#Take: выбирает определенное количество элементов
#Skip: пропускает определенное количество элементов
#TakeWhile: возвращает цепочку элементов последовательности, до тех пор, пока условие истинно
#SkipWhile: пропускает элементы в последовательности, пока они удовлетворяют заданному условию, и затем возвращает оставшиеся элементы
#Concat: объединяет две коллекции
#Zip: объединяет две коллекции в соответствии с определенным условием
Избыточные элементы в любой из входных последовательностей игнорируются. Операция Zip не поддерживается в запросах к базам данных.
int[] numbers = { 3, 5, 7 }; string[] words = { "three", "five", "seven", "ignored" }; 
nurnbers.Zip (words, (n, w) => n + "=" + w); 
приводит к получению последовательности со следующими элементами: 
З=three 
S=five 
7=seven


#First: выбирает первый элемент коллекции
#FirstOrDefault: выбирает первый элемент коллекции или возвращает значение по умолчанию
#Single: выбирает единственный элемент коллекции, если коллекция содердит больше или меньше одного элемента, то генерируется исключение-- генерируют исключение при наличии более одного совпадения
#SingleOrDefault: выбирает первый элемент коллекции или возвращает значение по умолчанию--генерируют исключение при наличии более одного совпадения
#ElementAt: выбирает элемент последовательности по определенному индексу
#ElementAtOrDefault: выбирает элемент коллекции по определенному индексу или возвращает значение по умолчанию, если индекс вне допустимого диапазона
#Last: выбирает последний элемент коллекции
#LastOrDefault: выбирает последний элемент коллекции или возвращает значение по умолчанию
#FindAll - вернет все элементы которые удовлетворяют условию(делегату pridicate который передаем)





#into

group val by val.column into val_ where val_.count()>2 select val_;  
select с. ToUpper () into upper //и дальше с upper что хотим делаем
from name in names 
group name.ToUpper() bу name.Length into grouping 
where grouping.Count() == 2 
select new { Assignee = grouping.Key, Count = grouping.Count() };




#let

from str in strs
let val=str.ToCharArray()

var query = from user in SampleData.AllUsers
let length = user.Name.Length
orderby length
select new { Name = user.Name, Length = length };

//такая конструкция транслируется в select
SampleData.AllUsers
.Select(user => new { user, length = user.Name.Length })
.OrderBy(z => z.length)
.Select(z => new { Name = z.user.Name, Length = z.length })




#linq #join
может не сохранять порядок в коллекциях(зависит от провайдера)
тк коллекция указанная справа буферизируется, а для левой организуется поток => справа желательно должна быть наименьшая коллекция

var phones = db.Phones.Join(db.Companies, // второй набор
        p => p.CompanyId, // свойство-селектор объекта из первого набора
        c => c.Id, // свойство-селектор объекта из второго набора
        (p, c) => new // результат
        {
            Name=p.Name, 
            Company = c.Name, 
            Price=p.Price
        });

from val_a in mass_a
join val_b in mass_b
on val_a = val_b;// = == equals



#left #join

var qry = Foo.GroupJoin(
          Bar, 
          foo => foo.Foo_Id,
          bar => bar.Foo_Id,
          (x,y) => new { Foo = x, Bars = y })
    .SelectMany(
          x => x.Bars.DefaultIfEmpty(),
          (x,y) => new { Foo=x.Foo, Bar=y});





#GroupBy #Count #OrderBy
data.GroupBy(info => info.metric)
                        .Select(group => new { 
                             Metric = group.Key, 
                             Count = group.Count() 
                        })
                        .OrderBy(x => x.Metric)











#деревья   #Expressions
используются для обращения к бд
см delegate

для деревьев есть встроенный визуализатор в студии


Expressions<Func<int,int,bool>> IsDel=(n,d)=>n==d;
Func<int,int,bool> t=IsDel.Compile();
t(10,20);



получение числа 5 с помощью построения дерева

Expression firstArg = Expression.Constant(2);
Expression secondArg = Expression.Constant(3);
Expression add = Expression.Add(firstArg, secondArg);
Func<int> compiled = Expression.Lambda<Func<int>>(add).Compile();
Console.WriteLine(compiled());








#TODO #linq #where #PredicateBuilder #Predicate #or

var query = collection.Where( c => c.A == 1 || c.B == 2 );
//ниже эквивалент
есть 2 версии обе с nuget
//using Mono.Linq.Expressions;  - не разобрался как работать
using Binbin.Linq;   - ставить не последние версии тк они не ставятся на .net framework 4.5-6, использование как ниже

var predicate = PredicateBuilder.False<Foo>();//False- в данном случае уже идет как первое условие=> если для такого предиката добавлять только через AND то он не вернет ничего=>если нужно OR то юзать false если AND то юзать true
 predicate = predicate.Or( f => f.A == 1 );
 if (allowB)
 {
    predicate = predicate.Or( f => f.B == 1 );
 }

 var query = collection.Where( predicate );










#xml #linq
#XAttribute

var users = new XElement("users",
SampleData.AllUsers.Select(user => new XElement("user",
new XAttribute("name", user.Name),
new XAttribute("type", user.UserType)))
);
Console.WriteLine(users);
// Вывод
<users>
<user name="Tim Trotter" type="Tester" />
</users>



#XElement #XmlSampleData
XElement root = XmlSampleData.GetElement();
var query = root.Element("users").Elements().Select(user => new   // первую часть можно переписать так root.Descendants("user")
{
Name = (string) user.Attribute("name"),
UserType = (string) user.Attribute("type")
});



from project in root.Element("projects").Elements()
from subscription in project.Elements("subscription")
select subscription


root.Element("projects").Elements().Elements("subscription")

Ниже перечислены осевые методы, используемые непосредственно для запрашивания одиночного узла, каждый из которых возвращает подходящую реализацию IEnumerable<T>:
• Ancestors
• AncestorsAndSelf
• Annotations
• Attributes
• Descendants
• DescendantsAndSelf
• DescendantNodes
• DescendantNodesAndSelf
• Elements
• ElementsAfterSelf
• ElementsBeforeSelf
• Nodes











#linq #rx
#Range #IObservable
#Observable.Range() создание наблюдаемого диапазона
. Каждый раз, когда какой-то наблюдатель подписывается на
диапазон, этому наблюдателю будут выдаваться числа при вызове им метода OnNext(), за которым следует OnCompleted().

“холодный” наблюдаемый объект: он остается бездействующим до тех пор, пока какой-либо наблюдатель не подпишется на него, после чего будет выдавать значения этому отдельному наблюдателю. Если вдобавок
подпишется еще один наблюдатель, он будет видеть другую копию диапазона. Это совсем не похоже на обычное событие вроде щелчка на кнопке, когда множество наблюдателей может быть
подписано на одну и ту же действительную последовательность значений, и значения могут выдаваться независимо от того, существуют какие-то наблюдатели или нет. (В конце концов, щелкать
на кнопке можно даже при отсутствии присоединенных к ней обработчиков событий.) Последовательности подобного рода носят название “горячих” наблюдаемых объектов


не существует методов
Reverse() и OrderBy()

var observable = Observable.Range(0, 10);
observable.Subscribe(x => Console.WriteLine("Received {0}", x),
e => Console.WriteLine("Error: {0}", e),
() => Console.WriteLine("Finished"));


var numbers = Observable.Range(0, 10);
var query = from number in numbers
where number % 2 == 0
select number * number;
query.Subscribe(Console.WriteLine);

















#namespace
//можно объявить несколько с одинаковым именем(сложатся в 1), 
namespace name{}
//можно вложить namespace в namespace
namespace name{
namespace name1{}}
//2 способ объявить вложенность
namespace name.name1{}



#using #примитивы 
using name_namespace;
using псевдоним=имя;
using new_name=name_namespace.classname;
using static System.Console;//будут доступны все статическое класса


using(var tmp=){
//раскладывается как блок try с .Dispose() в finally части
}//вызовется метод disposing, если его нет- ошибка


#::
если есть одноименный класс(например) в нескольких пространствах имен и мы подключаем оба то можно устранить неопределенность
name_namespace1::class_name val=new name_namespace1::class_name ();
//из глобального пространства имен
#global
для global нельзя определить псевдоним
global::class_name val=new global::class_name ();


если определено пространство имен Win и класс Win
и необходимо сослаться на пространство имен то Win::val






#препроцессор #предпроцессор

#define
#define name_ind//объявить
#undef name_ind//удалить

#region//просто для удобства
#endregion

#pragma

#error name error//прервать компиляцию и показать ошибку


#if name_ind
..
#else
..
#elif
..
#endif//относится только к if



#line
#warning name error//показать предупреждение при компиляции






#public
публичный
-Private (закрытый) (clr)
#private 
Доступен только методам в определяющем типе и вложенных в него типах
частный
при наследовании, наследуется но к нему есть доступ только через методы которые тоже были унаследованы(this.val не получится) и у которых был доступ к этому полю, если мы их не переопредляем
-Family (родовой) (clr)
#protected 
Доступен только методам в определяющем типе
(и вложенных в него типах) или в одном из его производных типов независимо от сборки
тоже самое что private но при наследовании мы можем использовать(this.val)+ получить доступ из наследника к полю объекта родителя
-Assembly (сборочный)(clr)
#internal 
Доступен только методам в определяющей сборке
доступно только в пределах сборки
Assembly or Family(сборочный илиродовой)(clr)
protected internal
Доступен только методам вложенного типа, производного типа (независимо от сборки) и любым методам определяющей сборки Public (открытый) public Доступен всем методам во всех сборках
совмещает функционал двух модификаторов. Классы и члены класса с таким модификатором доступны из текущей сборки и из производных классов.

private protected: такой член класса доступен из любого места в текущем классе или в производных классах, которые определены в той же сборке.


Если в производном типе переопределяется член базового типа, компилятор C#
требует, чтобы у членов базового и производного типов были одинаковые модификаторы доступа. То есть если член базового класса является защищенным, то и член
производного класса должен быть защищенным. Однако это ограничение языка C#,
а не CLR. При наследовании от базового класса CLR позволяет снижать, но не повышать ограничения доступа к члену. Например, защищенный метод базового класса
можно переопределить в производном классе в открытый, но не в закрытый. Дело
в том, что пользователь производного класса всегда может получить доступ к методу
базового класса путем приведения к базовому типу. Если бы среда CLR разрешала
устанавливать более жесткие ограничения на доступ к методу в производном типе,
то эти ограничения бы элементарно обходились




#immutable 
Это значит, что данные, хранящиеся в переменной, не могут быть изменены. При этом  значение переменной может быть изменено - путём отказа от использования старых данных, которые могут быть изменены.
 Оригинальные данные остаются в памяти, а новые значения создаются вновь, в новой области памяти. Пример тип String.




#partial
можно разбить что либо на несколько кусков
оба должны быть с 1 модификатором доступа
если спользуются обобщения то ограничения для параметров должны быть во всех версиях
но можно в 1 версии указать интерфейс а в 2 класс-родителя




partial class a{
math1}
partial class a{
math2}


если применили к методу
то можно не реализовывать(при вызове такого метода(не реализованного) не произойдет вообще ничего, он будет проигнорирован)
partial void meth();
partial void meth(){}

ограничения-
не могут быть virtual, не может быть модификатора доступа
всегда возвращают void
не может быть параметров ref out
обе части должны иметь одинаковые сигнатуры
если тело метода не было определено то он просто будет игнорироваться
Хотя частичные методы всегда считаются закрытыми, компилятор C# запрещает писать ключевое слово private перед объявлением частичного метод

internal sealed partial class Base {
 partial void OnNameChanging(String value) {
 }
}







#is 
вернет bool если можно\нельзя привести тип
(bool)(val is classname)


проверяем тип по is и если он норм то создается переменная
if(x is int i)


#as
//приведет тип если можно и если нет то вернет null
(val is classname)











#вспомогательный класс
// c# 1
Все члены являются статическими (кроме закрытого конструктора).
• Класс унаследован напрямую от object(неявно), явных родителей нет
• Обычно состояние не поддерживается, если только не задействовано кеширование или шаблон с единственным экземпляром.
• Видимые конструкторы отсутствуют.
• Класс является запечатанным, если разработчик не забыл сделать это.

//c# 2++
объявлен как static
• Он не может быть объявлен как абстрактный (abstract) или запечатанный (sealed), хотя неявно является тем и другим.
• Невозможно указывать любые интерфейсы для реализации.
• Нельзя указывать базовый тип.
• Невозможно включать любые нестатические члены, в том числе конструкторы.
• Нельзя определять любые операции.
• Невозможно включать любые члены protected или protected internal.













#деконструкторы #Deconstruct
class Person
{
public void Deconstruct(out string name, out int age)
    {
        name = this.Name;
}}
(string name, int age) = person;


#Индексаторы #[]
могут быть перегружены
class Library
{
    Book[] books;
 public Book this[int i, int j]{}
 public Book this[int index]
    {
        get
        {
            return books[index];
        }
        set
        {
            books[index] = value;
        }
    }


//компилятор назовет такой метод Item, если нужно переименовать то
 [IndexerName("Bit")]//переименовываем, необязательно
 public Boolean this[Int32 bitPos] { 
get { }
set { 
if (value) { 
}
}






#обработка #ошибки
#try #catch #finaly #throw #exception


try{}
catch{

throw new Exception();//выбросить новое исключение
}
catch(Exception e){
throw e;//пробросить исключение дальше, но  свойство StackTrace исключения больше не будет отражать исходную ошибку
throw;//пробросить исключение дальше
}
catch(Exception e)if(e.Source==""){
}



#Exception


свойства Exception
Message - характер ошибки
StackTrace - строка с вызовами стека из за которых случилась ошибка
TargetSite - объект-метод сгенерировавший исключение
InnerException - внутренее исключение
методы
ToString

конструкторы
public Exception()
public Exception(string сообщение)
public Exception(string сообщение,Exception внутреннее исключение)
protected Exception(System.Runtime.Serialization.SerializationInfo информация,System.Runtime.Serialization.StremingContext контекст)


создание своих исключений
class name:Exception{
//нужно просто реализовать все конструкторы
public name():base(){}
//....
}


#cath #try #finally
должны ловить исключения от частного к общему(сначала идет последний ребенок, потом его родитель, потом Exception)




При отладке блока catch в Microsoft Visual Studio для просмотра текущего исключения следует добавить в окно контрольных значений специальную переменную
$exception

Можно создать событие FirstChanceException класса AppDomain и получать информацию об исключениях еще до того, как CLR начнет искать их обработчики

#finally
Прерывание потока или выгрузка домена приложений является источником исключения
ThreadAbortException, обеспечивающего выполнение блока finally. Если же поток прерывается функцией TerminateThread или методом FailFast класса System.Environment, блок
finally не выполняется. Разумеется, Windows производит очистку всех ресурсов, которые
использовались прерванным процессом



Начиная с версии 2.0, в CLR появился класс RuntimeWrappedException, определенный в пространстве имен System.Runtime.CompilerServices. Являясь
производным от класса Exception, он представляет собой CLS-совместимый тип
исключений. Этот класс обладает закрытым полем типа Object, к которому можно
обратиться через предназначенное только для чтения свойство WrappedException
того же класса. В CLR 2.0 при генерации CLS-несовместимого исключения автоматически создается экземпляр класса RuntimeWrappedException, закрытому полю
которого присваивается ссылка на вброшенный объект. Таким способом несовместимые с CLS исключения превращаются в CLS-совместимые. В итоге любой код,
умеющий перехватывать исключения типа Exception, будет перехватывать и все
остальные исключения, что устраняет угрозу безопасности

 catch (Exception e) {

//вот так стек исключения будет указывать на эту строку
 throw e; // CLR считает, что исключение возникло тут. FxCop сообщает об ошибке
 //а вот так все норм
throw; // CLR не меняет информацию о начальной точке исключения.
 }


Если вы считаете, что состояние повреждено настолько, что остается только завершить весь процесс, используйте статический метод FailFast класса
Environment:
public static void #FailFast(String message);
public static void FailFast(String message, Exception exception);


#handle #TODO вроде это проглотит исключения
catch (AggregateException x) {
 // Считаем обработанными все объекты OperationCanceledException
 // Все остальные исключения попадают в новый объект AggregateException,
 // состоящий только из необработанных исключений
 x.Handle(e => e is OperationCanceledException);
 // Строка выполняется, если все исключения уже обработаны
 Console.WriteLine("Sum was canceled");
}










#Сериализация #serialize #serealize
[Serializable]
class Person
{
[NonSerialized]
    public string accNumber;
//точно также можно делать и с массивом и тд
 // создаем объект #BinaryFormatter
            BinaryFormatter formatter = new BinaryFormatter();
            // получаем поток, куда будем записывать сериализованный объект
            using (FileStream fs = new FileStream("people.dat", FileMode.OpenOrCreate))
            {
                formatter.Serialize(fs, person);
            }
 
            // десериализация из файла people.dat
            using (FileStream fs = new FileStream("people.dat", FileMode.OpenOrCreate))
            {
                Person newPerson = (Person)formatter.Deserialize(fs);
            }

#SOAP. #SoapFormatter
https://metanit.com/sharp/tutorial/6.3.php

#XML. #XmlSerializer
https://metanit.com/sharp/tutorial/6.4.php

#xml
Начиная с версии 3.5, в .NET Framework класс #SoapFormatter считается устаревшим
и не рекомендуется к использованию. Однако его имеет смысл применять при отладке
кода сериализации, так как он создает доступный для чтения текст в формате XML.
Если в выходном коде вы хотите воспользоваться механизмами XML-сериализации
и XML-десериализации, обратитесь к классам #XmlSerializer и #DataContractSerializer



[#Serializable]
internal class Circle {
 private Double m_radius;
 [#NonSerialized]
 private Double m_area;

[#OnDeserialized] - после
 private void OnDeserialized(StreamingContext context) {

 [#OnDeserializing] - перед
 [#OnSerializing] - перед
 [#OnSerialized] - после
все они обязательно принимают StreamingContext и возвращают void

В C# внутри типов, помеченных атрибутом [Serializable], не стоит определять автоматически реализуемые свойства. Дело в том, что имена полей, генерируемые компилятором, могут
меняться после каждой следующей компиляции, что сделает невозможной десериализацию
экземпляров типа.


еще сериализация есть через #сурогаты #surrogate





#JSON. #DataContractJsonSerializer

using Newtonsoft.Json;
data = JsonConvert.DeserializeObject<AllData>(upload_text);
//mass ---- var g= JsonConvert.DeserializeObject<test_t[]>(json);
str=JsonConvert.SerializeObject(section);
// через потоки

DataContractJsonSerializer jsonFormatter = new DataContractJsonSerializer(typeof(Person[]));
 
            using (FileStream fs = new FileStream("people.json", FileMode.OpenOrCreate))
            {
                jsonFormatter.WriteObject(fs, people);
            }
 
            using (FileStream fs = new FileStream("people.json", FileMode.OpenOrCreate))
            {
                Person[] newpeople = (Person[])jsonFormatter.ReadObject(fs);

            }


если не известен класс но знаем поля #JObject
using Newtonsoft.Json;  //JSON.NET
using Newtonsoft.Json.Linq;
var o = JObject.Parse(json);
var accessToken = (string)o["access_token"]; // "13a85707de16fbb1c290250872f30e0b"
var errorCode = (int)o["error"]["code"];     // 0
var duration = TimeSpan.FromSeconds((double)o["duration"]);


разрешить ответ на get запрос #json
return Json(data, JsonRequestBehavior.AllowGet);




#расширение #расширения #extension #extends

Любой совместимый метод экземпляра всегда будет иметь преимущество над расширяющим методом - даже когда параметры расширяющего метода дают более точное соответствие по типам. 
если 2 метода с одинаковой сигнатурой то вызывать как обычный static метод
 если один расширяющий метод имеет более специфичные аргументы, то ему будет отдаваться предпочтение
//создать static class 
//подключить это namespase к месту где будет использовать этот метод

при методе расширения можно вызвать расширяющий метод на ссылке которая == null!!! тк она передает параметром
если это ломает логику то нужно генерить NullReferenceException


public static class StringExtension
{
//this перед тем параметром к которому это будет применяться
    public static int WordCount(this string str, char c)
    {}
((string)str).WordCount((char)c);















#delegate #делегаты
-объект инкапсулирующий методы

1. Событие нельзя запустить вне класса, в котором оно было объявлено=> больше защищенность 
2. События могут быть помещены в интерфейс.(делегаты только как свойства могут быть помещены, вроде)
3. И событие и делегат можно объявить полем класса, но в отличие от делегата, событие не может быть локальной переменной метода 

Делегаты являются неизменяемыми, так что при использовании операции+= или -= фактически создается новый экземпляр делегата, который присваивается существующей переменной.
если делегат содержит только 1 метод то это обычный делегат, если методов больше то это уже multicast делегат 
Если делегат имеет возвращаемый тип  вернется значение из последнего вызванного метода. возвращаемые значения Предшествующих методов  отбрасываются.
Все типы делегатов : System.MulticastDelegate: System.Delegate. Операции+, -, += и -=, транслируются в статические методы #Combine и Remove класса System.Delegate.


Метод #GetInvocationList работает с объектами классов, производных от
MulticastDelegate. Он возвращает массив ссылок, каждая из которых указывает
на какой-то делегат в цепочке. По сути, этот метод создает массив и инициализирует его элементы ссылками на соответствующие делегаты; в конце возвращается
ссылка на этот массив. Если поле _invocationList содержит null, возвращаемый
массив будет содержать всего один элемент, ссылающийся на единственного делегата в цепочке — экземпляр самого делегата

public abstract class MulticastDelegate : Delegate {
 // Создает массив, каждый элемент которого ссылается
 // на делегата в цепочке
 public sealed override Delegate[] GetInvocationList();
}




delegate возвращаемый_тип name_del(type param1,type param2)

можно закинуть любой метод(статика \функцию\метод экземпляра и что угодно)
могут быть обобщенными

name_del name_del_obj=new name_del([meth]);//объявление
name_del name_del_obj=meth;//объявление, сокращение для new a(meth)

name_del_obj=meth;//убрать все методы и добавить новый
name_del_obj+=meth;//добавить новый метод, добавлять также можно и делегат, сахар для метода Combine
name_del_obj-=meth;//удалить новый метод, удалять также можно и делегат, сахар для метода Remove

name_del_obj();//сокращение для name_del_obj.Invoke();

если параметр передавать через ref то он будет передаваться в каждый метод и измененный после него идти в след метод

его можно объявить в классе(не создать объект а именно объявить)
delegate void Dl(); 
delegate void D2(); 
Dl dl = Methodl; 
D2 d2 = dl; / / Ошибка на этапе компиляции 
Тем не менее, следующее разрешено: 
D2 d2 = new D2 (dl); 
Экземпляры делегатов считаются равными, если они имеют один и тот же целевой метод (методы). Для групповых делегатов важен порядок следования целевых методов.



#combine
при null трактуется как пустой делегат
вернет новый делегат-результат, старые не могут изменяться
Delegate.Combine(del1,del2);//лучше использовать +=
Delegate.Remove(delSource,delValue);//лучше использовать -=


 #standart #стандартные
//стандартные делегаты не надо объявлять они уже есть

#Action
public delegate void Action<T1,T2,....T16>(T obj1,T obj2... T obj16)
Action<int, int> op=(a,b)=>{return;};

#Predicate
Predicate<int> isPositive =  (int x)=>{ return x > 0; };

#Func
//последний параметр всегда выходной
Func<T> isPositive
Func<T1, T2,... T16,TResult>
Func<int> isPositive=()=>{return 1;}
 Func<int, int> retFunc =( x)=>{return x;}




#вариантность
поддерживается только с ссылочными типами!

#ковариантность #контрвариантность #контравариантность для делегатов
delegate X name_del(Y param)

Y:X

X meth1(X o);
Y meth2(Y o);

name_del delobj;

#ковариантность
возвращаемый тип может быть наследником
delobj=meth2;


#контрвариантность #контравариантность
тип параметра может быть базовым
delobj=meth1;
//чет вроде не правильно delobj(X);
delobj(Y);//Y:X
тк мы потом будем передавать в метод который будет в делегате происзодное от базового(X) и он приведется к базовому(к X)


#Инвариантность
 позволяет использовать только заданный тип

с ref\out применять нельзя
delegate void SomeDelegate<in T>(ref T t);


#вариантность для обобщенных делегатов
#ковариантность
out-- выходное значение
delegate T name_del<out T>()
можно присвоить метод где параметр будет T или ребенком T
T не может использоваться в парметрах методов


#контрвариантность
in-- входные параметры
delegate bool name_del<in T>(T obj)
можно присвоить метод где параметр будет T или родителем T
и объект T не может возвращаться





#Converter<,>
#TODO - скит 434







#анонимные #anonim #anonymous

//только для чтения
var f=new{x1,x2,x3.Id};//x1 x2 Id
var f=new{val1=x1,val2=x2};


коллекция анонимных типов(можно через dynamic)
// create the first list by using a specific "template" type.
var list = new [] { new { Name="", Phones=new[] { "" } } }.ToList();
// clear the list.  The first element was just an example.
list.Clear();
// start adding "actual" values.
list.Add(new { Name = "Krishna", Phones = new[] { "555-555-5555", "666-666-6666" } });










#анонимные #функции  #anonim #anonymous #function  #=> #лямбда

если пишется в типе значения то нельзя использовать this
доступ к базовому члену внутри анонимного метода можно получить через base

name_del delobj=delegate{/*код функции*/};
delobj=delegate(type val){/*код функции*/};
особенность такой штуки в том что можно присвоить объекту делегата который 
принимает параметры такой анонимный метод без параметров(можно использовать когда параметры не нужны или например нужна просто заглушка)


через лямбды
скобки нужны если несколько параметров, параметров нет, или если явно указываем тип параметра
если есть =>{} то невозможно создать expression и называется лямбда оператор если нет то лямбда выражение

delobj=(type val)=>{/*код функции*/};
delobj=(val)=>{/*код функции*/};
delobj=val=>{/*код функции*/};
delobj=()=>{/*код функции*/};
{
delobj=(type val)=>/*код функции в 1 строку без return*/;
delobj=val=>val+2;
}
del myDelegate = x => x * x;  

// #древо выражений #деревья #дерево
 #Expression<del> myET = x => x * x; 

в /*код функции*/
можно использовать return
{#замыкание #захват
можно захватывать внешние переменные по ссылке, которые не будут уничтожены пока не уничтожатся все методы которые захватывают+ не будет других ссылок на нее
захватывают значения по ссылки, если захватить итерационную переменную в foreach то с версии 5 все будет хорошо, в ранних версиях все делегаты будут ссылаться на 1 и туже переменную
если переменная создается в цикле и захватывается - то это как бы 1 переменная но захватываются РАЗНЫЕ экземпляры


пример
method(){
int t=10;
delobj=delegate{t++;}
}
delobj();//увеличит на 1 и станет 11
delobj();//увеличит на 1 и станет 12
}




#event  #TODO
см delegate

могут быть объявлены в интерфейсах, 
могут быть абстрактными(только если без аксессоров),
могут быть virtual и sealed
event делегат_события имя_события;
delegate void Hand();
event Hand EventName;


События могут быть виртуальными, переопределенными, абстрактными или запечатанными. Они также могут быть статическими.

С# обеспечивает безопасность в отношении потоков во время обновления делегата, если это переопределить то будет не потокобезопасно
event Hand EventName{
add{
priceChanqed += value; 
}
remove{
priceChanqed -= value; 
}
}



EventName evt+=method;
if(evt!=null)
evt();



рекомендованная структура событий(уже есть предопределенные делегаты) #EventHandler #EventsArgs
class MyEventsArgs:EventsArgs{}
EventsArgs.Empty

delegate void Delname(object source,MyEventsArgs arg)

public event EventHandler<MyEventArgs> someEvent;//без обобщения если EventsArgs не переопределяем






#перегрузка

при перегрузке методов
в il можно определить 2 одинаковых метода которые будут различаться только return типом
такая возможность блокируется языками программирования

#operator #перегрузка #операторов
при перегрузке не должны изменяться те объекты, которые передаются в оператор через параметры
class Counter
{
public static возвращаемый_тип operator оператор(параметры)
{  }
public static Counter operator +(Counter c1, Counter c2)

зависимые друг от друга(противоположные) надо перегружать оба сразу
public static bool operator (>||<)(Counter c1, Counter c2) 
public static Counter operator ++(Counter c1)
{
    return new Counter { Value = c1.Value + 10 };
}
для if()
public static bool operator true(Counter c1)
  public static bool operator false(Counter c1)  

логические
public static bool operator (|,!,&)(Counter c1, Counter c2) 

укороченные логические
нужно перегрузить true false
нужно перегрузить(возможно) !
нужно перегрузить |, & - возвращаемый тип -объект для которого if(объект) -true
public static Counter operator (|)(Counter c1, Counter c2) 





#приведение #типов #перегрузка  #приведение
#explicit-явное (type)obj  #implicit-не явное
public static implicit|explicit operator Тип_в_который_надо_преобразовать(исходный_тип param){
return new Тип_в_который_надо_преобразовать(param);
}
для коллекция см cast


 // Неявно создает Rational из Int32 и возвращает полученный объект
 public static implicit operator Rational(Int32 num) {
 return new Rational(num); }
 // Неявно создает Rational из Single и возвращает полученный объект
 public static implicit operator Rational(Single num) {
 return new Rational(num); }
 // Явно возвращает объект типа Int32, полученный из Rational
 public static explicit operator Int32(Rational r) {
 return r.ToInt32(); }
 // Явно возвращает объект типа Single, полученный из Rational
 public static explicit operator Single(Rational r) {
 return r.ToSingle();
 }









#интерфесы #interface 
все внутри без уровня доступа
при реализации, методы от интефейса не должны быть override

Компилятор C# требует, чтобы метод, реализующий интерфейс, отмечался
модификатором public. CLR требует, чтобы интерфейсные методы были виртуальными. Если метод явно не определен в коде как виртуальный, компилятор сделает
его таковым и, вдобавок, запечатанным. Это не позволяет производному классу
переопределять интерфейсные методы. Если явно задать метод как виртуальный,
компилятор сделает его таковым и оставит незапечатанным, что предоставит производному классу возможность переопределять интерфейсные методы.
Производный класс не в состоянии переопределять интерфейсные   методы,
объявленные запечатанными, но может повторно унаследовать тот же интерфейс
и предоставить собственную реализацию его методов.

Если в C# перед именем метода указано имя интерфейса, в котором определен
этот метод (в нашем примере — IDisposable.Dispose), то вы создаете явную реализацию интерфейсного метода (Explicit Interface Method Implementation, #EIMI).
Заметьте: при явной реализации интерфейсного метода в C# нельзя указывать
уровень доступа (открытый или закрытый). Однако когда компилятор создает
метаданные для метода, он назначает ему закрытый уровень доступа (private),
что запрещает любому коду использовать экземпляр класса простым вызовом
интерфейсного метода. Единственный способ вызвать интерфейсный метод — обратиться через переменную этого интерфейсного типа.
Обратите внимание на то, что EIMI-метод не может быть виртуальным, а значит,
его нельзя переопределить. Это происходит потому, что EIMI-метод в действительности не является частью объектной модели типа; это всего лишь средство связывания интерфейса (набора вариантов поведения, или методов) с типом



interface IName{
//свойство не будет самореализуемым(надо будет в классе хотя бы скопировать то что объявлено тут), get\set тоже без уровня доступа
int nm{
get;
set;
}

return_type this[type val]{
get;set;
}

void methodname(){}
}

явная реализация метода
class g: IName{
void IName.methodname1(){}//без уровня доступа
public void methodname(){}

}
g g_=new g();
IName g1=new g();
g_.methodname1();//нельзя, надо сначала упаковать
g1.methodname1();


class g: IName{
void virtual methodname1(){}//разрешаем переопределение для наследников
void virtual IName.methodname1(){}//так нельзя
}


public interface IUndoable { void Undo();
public class TextBox : IUndoabe
{
void IUndoabe.Undo()=> Console. WriteLine ( "TextBox. Undo") ; 
}
public class RichTextBox TextBox, IUndoabe
{
public new void Undo()=> Console.WriteLine ("RichTextBox.Undo"); //при вызове из класса вызовется этот метод, при вызове из интерфейса тоже
}




#ковариантность #контрвариантность #вариантность #инвариантность
можно применить(указать ключевые слова in\out) только интерфейсам или делегатам(нельзя к классам и тд даже если они как бы подходят) - это ограничение CLR

любое преобразование которое ЭТО использует - это ссылочное преобразование, те после преобразования возвращается таже самая ссылка, преобрзование не создает новый объект
из за того что преобразование ссылочное, так делать нельзя
• IEnumerable<int> в IEnumerable<object> — упаковывающее преобразование:
• IEnumerable<short> в IEnumerable<int> — преобразование типа значения;
• IEnumerable<string> в IEnumerable<XName> — преобразование, определяемое пользователем.



#ковариантность
out-- выходное значение
interface IMyInt<out T>{
//можно T применять только для возвращаемого типа, нельзя использовать для ограничения(where X:T)
//может ПРИСВОИТЬ ссылку на любой класс производный от T или сам T
T GetObj();
}
//при реализации интерфейса ключевое слово не указывается(ни в class ни в методах)
class Myclass<T>:IMyInt<T>{}
но указывается при наследовании только в ребенке интерфейса
interface Myclass<out T>:IMyInt<T>{}

class a{}
class b:a{}
IMyInt<a> alp=new Myclass<a>();//доступно в любом случае
alp=new Myclass<b>();//доступно из за ковариантности
ВЫВОД- позволяет засунуть в объект родителя объект ребенка но только эта иерархия не на сам класс а на обобщенный тип, и этот обобщенный тип применяется только к return type методов


#контрвариантность
in-- входные параметры
interface IMyInt<in T>{

void GetObj(T obj);
}
//при реализации интерфейса ключевое слово не указывается(ни в class ни в методах)
class Myclass<T>:IMyInt<T>{}
но указывается при наследовании только в ребенке интерфейса
interface Myclass<in T>:IMyInt<T>{}

class a{}
class b:a{}
IMyInt<a> alp=new Myclass<a>();//доступно в любом случае
IMyInt<b> bet=new Myclass<b>();//доступно в любом случае
bet=new Myclass<a>();//доступно из за контрвариантности
bet=alp;//доступно из за контрвариантности
ВЫВОД- позволяет засунуть в объект ребенка объект родителя но только эта иерархия не на сам класс а на обобщенный тип, и этот обобщенный тип применяется только к параметрам методов
в метод можем передать родителя T












#IEquatable IEquatable<T> - Equals
для сравнения(определения равенства)



#IComparable - CompareTo
IComparable<T>
для сравнения(для определения порядка следования)


#Sort()
//не обобщенная версия надо приводить к типам
public interface IComparable
{
    int CompareTo(object o);
}
//обобщенная, приводить к типу не надо
IComparable<Person>
 public int CompareTo(Person p)
    {}

Меньше нуля. Значит, текущий объект должен находиться перед объектом, который передается в качестве параметра
Равен нулю. Значит, оба объекта равны
Больше нуля. Значит, текущий объект должен находиться после объекта, передаваемого в качестве параметра

PeopleComparer--- класс которые реализует интерфейс #IComparer<Person>
Array.Sort(new[]Person, new PeopleComparer());




#сравнение #равенство #IComparer
IComparer<Person>
interface IComparer
{
    int Compare(object o1, object o2);
}

если первый объект больше второго, то возвращается число больше 0, если меньше - то число меньше нуля; если оба объекта равны, возвращается ноль.




//правильная реализация отдельного класса для сравнения #Comparer


public static class PartialComparer
{
public static int? Compare<T>(T first, T second)
{
return Compare(Comparer<T>.Default, first, second);
}
public static int? Compare<T>(IComparer<T> comparer,
T first, T second)
{
int ret = comparer.Compare(first, second);
return ret == 0 ? new int?() : ret;//почему тут при ==0 возвращается null не понимаю
}
public static int? ReferenceCompare<T>(T first, T second)
where T : class
{
return first == second ? 0
: first == null ? -1
: second == null ? 1
: new int?();
}
}










#TODO
#IEqualityComparer 
что то типа IComparer











#ICloneable #clone()
//сам интерфейс
public interface ICloneable
{
    object Clone();
}
//реализация через #MemberwiseClone--поверхностное копирование(если есть ссылки внутри то останутся ссылками на те же объекты)
public object Clone()
    {
        return this.MemberwiseClone();
    }



#IConvertible
преобразования типов



#IFormatProvider #IFormattable #TODO





#IObservable<T> #IObserver<T>
паттерн #наблюдатель
IObserver<T> - тот кто подписывается
Subscribe - подписать
OnNext отправить данные наблюдателю
OnError отправить сообщение об ошибке
OnCompleted - указывает на то что наблюдаемый объект прекратил отправку сообщений








#abstract


#constructor

Для абстрактных классов компилятор создает конструктор по умолчанию с модификатором protected, в противном случае область действия будет открытой
(public). Если в базовом классе нет конструктора без параметров, производный
класс должен явно вызвать конструктор базового класса, иначе компилятор вернет
ошибку. Для статических классов (запечатанных и абстрактных) компилятор не
создает конструктор по умолчанию


В интерфейсе все методы (свойства и т.д.) абстрактны и не имеют реализации. В абстрактном классе некоторые методы могут быть реализованы. 
В интерфейсе члены не могут иметь модификатора видимости (все они являются public по умолчанию), а в абстрактном классе члены могут иметь модификатор видимости.


Абстрактный класс — класс, который имеет хотя б 1 абстрактный метод; его обозначают abstract.
Интерфейс — такой же абстрактный класс,только в нем нет свойств и не определены тела у методов.

Таким образом, функционально любой интерфейс является абстрактным классом, но абстрактный класс не является интерфейсом.

в абстр классе пишем override для абс метода, для интерфейса нет
Основные отличия интерфейса и абстрактного класса
•	абстрактный класс может содержать свойства
•???	интерфейс не содержит свойств(полей)
•	абстрактный класс может содержать тела методов
•	интерфейс не содержит тел методов, только их объявление
•	абстрактный класс наследуется (etxends)
•	интерфейс реализуется (implements)
•	наследник имеет только одного родителя (абстрактный класс)
•	наследник может реализовывать методы нескольких интерфейсов
•	наследник не обязан содержать реализацию методов абстрактного класса-родителя(в таком случае сам должен быть абстрактным)
•	наследник обязан содержать реализацию всех методов реализуемого интерфейса




















#ref 
таким модификатором нельзя пометить необязательные параметры
с помощью таких ключевых слов нельзя передавать свойства
ref local

int x = 5;
ref int xRef = ref x;

будет ссылаться на элемент массива
ref int numberRef = ref Find(4, numbers);
static ref int Find(int[] numbers)
{
return ref numbers[0];//будет ссылаться на элемент
}


#out
обязательно должна быть установлена, в целом применяется как ref
в новой версии можно объявить так(при вызове метода)
meth(out var x,(int)10);






#in
работает как ref, но гарантирует, что эту ссылку не поменяют. Ещё одно отличие — можно задавать значение по умолчанию
public void Test(in string s = "")
Test();
string test = "42";
Test(in test);
Test(in "42");//так нельзя







#обобщения  #обобщение #<> #generic
могут быть обобщенные классы, интерфейсы, структуры,методы,делегаты
хранятся в обобщенной форме , а по мере необходимости создаются конкретные экземпляры классов cl<int> cl<string> - разные классы




 рекомендациях Microsoft для проектировщиков указано, что переменные параметров должны называться T или, в крайнем случае, начинаться с T (как, например, TKey или TValue). T означает тип (type), а I означает интерфейс (например,
IComparable).


List<DateTime> dt = new List<DateTime>();
internal sealed class DateTimeList : List<DateTime>
//так делать нельзя если это делается только для упрощения читабельности потому что это считается новым типом
Boolean sameType = (typeof(List<DateTime>) == typeof(DateTimeList));//false
Это также значит, что методу,
в прототипе которого определено, что он принимает значение типа DateTimeList,
нельзя передать List<DateTime>. Тем не менее методу, который должен принимать
List<DateTime>, можно передать DateTimeList, потому что тип DateTimeList является производным от List<DateTime>


для каждого обобщенного класса list<int> list<string> должен сгенерировать отдельный класс
это приводит к разрастанию кода, поэтому начали оптимизировать
если
List<DateTime> используется в двух совершенно разных сборках (загруженных
в один домен приложений), CLR компилирует методы для List<DateTime> всего один раз

Кроме того, CLR считает все аргументы ссылочного типа тождественными, что
опять же обеспечивает совместное использование кода. Например, код, скомпилированный в CLR для методов List<String>, может применяться для методов
List<Stream>, потому что String и Stream — ссылочные типы. По сути, для всех
ссылочных типов используется одинаковый код
для значимых типов создается новый тип на каждое обобщение







ограничения:
свойства, операторы, индексаторы и события не могут быть обобщенными, но могут использовать в обобщенном классе с параметрами обобщенного типа этого класса
к обобщенному методу нельзя применять модификатор extern
типы указателей нельзя использовать в аргументах типа


//метод в обычном классе
public static string Info<T>(T obj)    where T : User
        {
            return obj.ToString();
        }


class BaseTypeOfDynamic : dynamic
• class DynamicTypeConstraint<T> where T : dynamic
• class DynamicTypeConstraint<T> where T : List<dynamic>
• class DynamicInterface : IEnumerable<dynamic>
Но следующие объявления будут допустимыми:
• class GenericDynamicBaseClass : List<dynamic>
• IEnumerable<dynamic> variable;



если в обобщенном классе есть поле static то оно свое для каждого типа класса(cl<int> cl<string>-разные, cl<string> cl<string> -одно поле)

параметр обобщенного типа можно сравнивать(== и =!) только с null, но если есть ограничения(например class) то можно и друг с другом


при перегрузке типов
Обобщенные типы могут быть перегружены на основе количества параметров типов, так что
допустимо определять МуТуре, МуТуре<Т>, MyType<T,U>, МуТуре<Т, U, V> и так далее, причем в рамках одного и того же пространства имен. При перегрузке имена параметров типов во
внимание не принимаются — важно только их количество. Эти типы не связаны друг с другом
за исключением имени — например, стандартное преобразование одного типа в другой не существует. 


class Transaction<T> where T: Account
{
    public T FromAccount { get; set; }
}
class Transaction<T> 
{
    public T FromAccount { get; set; }
}
Transaction<Account> transaction1 = new Transaction<Account>
        {
}

//ограничение- должен быть тип значения
//ограничение должно быть 1 по порядку
class Account<T> where T : struct
{}
//ограничение- должен быть ссылочный тип
//ограничение должно быть 1 по порядку
class Transaction<T> where T : class
{}

//есть конструктор без параметров
//должно идти последним по порядку, использовать можно только конструктор без параметров, нельзя использовать с ограничением типа значения
//нельзя указать конструктор с параметрами
class Transaction<T> where T : new()
{}

class Transaction<U, V>
        where U : Account<int>
        where V : struct
{}
class Transaction<U, V>
        where U : V{}
public static void Transact<T>(T acc1, T acc2, int sum) where T : Account<int>{}

public void nameMeth<T>(int g,T t) where T:class{}
//оба вызова норм, тип он сам подставит
nameMeth<string>(10,"");
nameMeth(10,"");

если одновременное ограничение типа на класс и на интерфейс то сначала указывается класс


delegate void name<T>();
name<int> nameObj=;



при обобщенном интерфейсе
ограничения интерфейса нужно продублировать ограничениями в класс который его реализует


при перегрузке не должно быть так, тк n<int,int>- все сломает
class n<T,V>{
void nnn(V a);
void nnn(T a);
}



where T:VAL__
VAL__ - не может быть типом значения, запечатанным классом(sealed)(string), или : Object, Enum,ValueType,Delegate


Display("Jeff"); // Вызывает Display(String)
Display(123); // Вызывает Display<T>(T)
Display<String>("Aidan"); // Вызывает Display<T>(T)
В первом случае компилятор может вызвать либо метод Display, принимающий
String, либо обобщенный метод Display (заменяя T типом String). Но компилятор
C# всегда выбирает явное, а не обобщенное соответствие







#default

obj=default(тип);
при обобщении
obj=default(T);










#exception #exeption #try #catch #finally
после try обязательно catch или finally или оба
более "узкие\специфичные" обработчики должны идти сначала
перехватить можно не все исключение вроде, #TODO какие если true
try{
throw new Exception("Длина строки больше 6 символов");
}
catch(... ex){
ex.Message
}
catch(Exeption ex) when (y==0){
ex.Message
}
catch{
throw;//пробрасываем исключение дальше
}
finally{
//выполняется всегда
}


-----------------------------



-----------------------------





























#resize #image #img
//меняем размер картинки

 private static Image ResizeImage(int newSize, Image originalImage)
        {
            if (originalImage.Width <= newSize)
                newSize = originalImage.Width;

            var newHeight = originalImage.Height * newSize / originalImage.Width;

            if (newHeight > newSize)
            {
                // Resize with height instead
                newSize = originalImage.Width * newSize / originalImage.Height;
                newHeight = newSize;
            }

            return originalImage.GetThumbnailImage(newSize, newHeight, null, IntPtr.Zero);
        }








#io  #file #load #byte

#потоки 

#stream
методы
close
flush - заставляет вывести все, если не юзнуть то данные выводятся блоками
readByte
Read
seek  - установить положение в потоке
writebyte
write

свойства
canread
canseek
canwrite
length - длина потока
position текущее положение доступно и для чтения и для записи
readtimeout
writetimeout

#BufferedStream:stream - заключает в оболочку байтовый поток и добавляет буферизацию

#StreamReader #StreamWriter #TODO


#UnmanagedMemoryStream:stream - байтовый поток который использует неупраляемую память для хранения

!!!символьные потоки
#TextReader #TextWriter
методы TextReader
...
close
int peek - получает следующий символ из потока но не удаляет его, возвращает -1 если нет доступных символов
#OpenText(filename); создает объект TextReader

методы TextWriter
close
flush


using (StreamReader reader = File.OpenText(filename))
            {
                result = new char[reader.BaseStream.Length];
                await reader.ReadAsync(result, 0, (int)reader.BaseStream.Length);
            }


вывод текст
в streamWriter: TextWriter заключается filestream(или другой наследник stream)
public streamWriter(Stream)
public streamWriter(string путь)
public streamWriter(string путь,bool append)//если true то в конец



#BinaryReader #BinaryWriter
для работы с байтами, лучше использовать как оболочку для другого байтового потока

void write
--
bool readboolean()
...



#MemoryStream:stream - байтовый поток который использует память для хранения
конструкторы 
MemoryStream(byte[] buf)
можно засунуть в оболочку и использовать как обычный поток

#StringReader:textReader StringWriter:textWriter - тоже что и MemoryStream но для хранения в строке
конструкторы
StringReader(string buf)
StringWriter()//не указываем строку в которой будет хранить но можно ее получить методом ToString()



!!!!
#FileStream:stream - байтовый поток для ввода вывода
конструкторы
FileStream(string путь, FileMode режим)
FileStream(string путь, FileMode режим, FileAccess доступ) - ограничивает доступ, только для чтения и тд
new FileStream(FilePathOld, FileMode.Open, FileAccess.Read, FileShare.Read)//если нужно читать в нескольких потоках


#File
некоторые методы находятся в FileInfo, если что можно поискать там
copy(string исход,string новый)//если не существует
copy(string исход,string новый,bool overwrite)//перезапишит

exist (string путь)
GetLastAccessTime (string путь)


#GetFiles #DirectoryInfo
new DirectoryInfo(@"C:\").GetFiles();//получить файлы





#io  #file #load #byte #console

Console.In-экземпляр TextReader  Console.Out -TextWriter Console.Error -TextWriter

методы
static void #SetIn(TextReader поток)
static void #SetOut(TextWriter поток)
static void #SetError(TextWriter поток)
//в TextReader можно обернуть вообще другой поток



#readKey
static consoleKeyInfo ReadKey()
static consoleKeyInfo ReadKey(bool intercept) - если true то не отобразится на консоли

#consoleKeyInfo
структура
char KeyChar  введенный символ
ConsoleKey Key значение из перечисления ConsoleKey
ConsoleModifiers Modifiers  значение из перечисления ConsoleModifiers , модификаторы которые бали нажаты ctrl и тд








//открыть файл и вернуть байты
 public static byte[] FileToByteArray(string fileName)
        {
            byte[] buff = null;
            FileStream fs = new FileStream(fileName,
                                           FileMode.Open,
                                           FileAccess.Read);
            BinaryReader br = new BinaryReader(fs);
            long numBytes = new FileInfo(fileName).Length;
            buff = br.ReadBytes((int)numBytes);
            return buff;
        }



#Console

Beep: подача звукового сигнала
Clear: очистка консоли
WriteLine: вывод строки текста, включая символ возврата каретки (то есть с переводом на новую строку)
Write: вывод строки текста, но без символа возврата каретки
ReadLine: считывание строки текста со входного потока
Read: считывание введенного символа в виде числового кода данного символа. С помощью преобразования к типу char мы можем получить введенный символ
ReadKey: считывание нажатой клавиши клавиатуры (ConsoleKeyInfo key= Console.ReadKey();)
Кроме того, класс Console обладает свойствами, которые позволяют управлять консолью. Некоторые из них:
BackgroundColor: цвет фона консоли
ForegroundColor: цвет шрифта консоли
BufferHeight: высота буфера консоли
BufferWidth: ширина буфера консоли
Title: заголовок консоли
WindowHeight и WindowWidth: высота и ширина консоли соответственно














#относительный #relative путь к файлу на сервере #HostingEnvironment
File.ReadAllText(HostingEnvironment.MapPath($"~/tsqlscripts/{i}.txt"))





























#* #unsafe #указатель

тип * название;
указатель может указывать на что угодно
int * p,q ;//создание 2х указателей
&val;//получить адрес
*ref;//получить значение по указателю

unsafe- пометить блок кода как не безопасный(можно применять указатели)
unsafe static void Main(){}

#fixed
fixed(int*=&val){
//val не будет удалена сборщиком мусора КАК МИНИМУМ пока не выполнится блок кода
}

fixed тип имя_буфера[размер]
создание массива фиксированного значения, можно указать только в структуре


арифметика с указателями
++ -- + - 
int* p;
p++;//увеличит на 4 тк int-4байта

если переменные связанны(допустим указатели на разные участки массива) то их можно сравнивать(и получить результат который что то будет значить)
== < >

int[] mass;
//одно и тоже
int*p=mass;
int*q=mass[0];

p[1], p[10] //работает тк указывает на массив


указатель на указатель
int** p;//**p получить значение

массивы
int*[]mass=new int*[3];
mass[0]=;//установить значение
*mass[0];//получить значение




#sizeof
sizeof(type)//узнать размер типа данных

#stackalloc
только при объявлении локальных переменных
память выделяется из кучи
выделенная память таким обрзом не очищается сборщиком мусора
тип *p=stackalloc тип[размер]








#inthernet #HttpWebRequest #parse #uri #url #интернет #парсинг #www  #internet #web
#HttpWebRequest req = (HttpWebRequest) #WebRequest.Create("http://www.McGraw-Hill.com");
#HttpWebResponse resp = (HttpWebResponse) req. #GetResponse();
Stream istrm = resp. #GetResponseStream();
//получаем html страницы
resp.Close();
//---короче
// Сначала создать объект запроса типа WebRequest по указанному URI.
#WebRequest req = WebRequest.Create("http://www.McGraw-Hill.com");
// Затем отправить сформированный запрос и получить на него ответ.
WebResponse resp = req.GetResponse();

#WebClient лучше использовать вместо Request Response если нужно просто получить инфу по ссылке и все
public byte[] DownloadData(string address) //получить результат по ссылке
public string DownloadString(string address) //результат по ссылке
public Stream OpenRead(Uri address) //поток четения
public Stream OpenWrite(Uri address) 
DownloadFile(uri, fname); //по ссылке записать все в файл, можно в ссылке указать как код на страницу так и код на файл


Uri sample = new Uri("http://HerbSchildt.com/somefile.txt?SomeQuery");
Uri-
public string Host { get; } Получает имя сервера
public string LocalPath { get; } Получает локальный путь к файлу
public string. PathAndQuery { get; }
public int Port { get; }
Получает абсолютный путь и строку запроса
Получает номер порта для указанного протокола. Так, для протокола HTTP номер порта
равен 80
public string Query { get; } Получает строку запроса
public string Scheme { get; } Получает протокол





#HttpClient обновленный тип для #WebClient #TODO не понятно откуда взялась: text
using (HttpClient client = new HttpClient())
{
await client.GetStringAsync("http://csharpindepth.com");
string str = text.Length.ToString();
}












#graph #graphic
http://htmlbook.ru/blog/grafiki-i-diagrammy

https://google-developers.appspot.com/chart/interactive/docs/gallery
 































js-html
JqGrid пакет для добавления таблицы со стриницами поиском  редактированием тд
https://metanit.com/sharp/mvc5/17.3.php








Диалоговые окна и CRUD-интерфейс
реазилация partial action для окна(редактирование элемента например)
https://metanit.com/sharp/mvc5/17.2.php


jQuery UI и Autocomplete
для подгрузки блжайших совпадений при поиске
https://metanit.com/sharp/mvc5/17.1.php


































#attr #atribute #атрибуты

название  с суффиксом Attribute

[AttributeUsage(AttributeTargets.All)]//то к чему может применяться
public class NameAttribute: Attribute{



public NameAttribute(){}
}
//если в классе есть нестатическое поле или свойство доступное для записи то его можно использовать как именованный параметр не указывая в конструкторе
[NameAttribute(позиционные параметры,именованные параметры)]
public class test{}

//получить атрибуты
((Type)obj).GetCustomAttributes
Attribute.GetCustomAttribute(MemberInfo a,Type b);//a-объект, b-тип атрибута



у атрибутов может быть префикс
[assembly: SomeAttr] // Применяется к сборке
[module: SomeAttr] // Применяется к модулю
[type: SomeAttr] // Применяется к типу - компилятор может определить сам
[field: SomeAttr] // Применяется к полю - компилятор может определить сам
[return: SomeAttr] // Применяется к возвращаемому значению
 [method: SomeAttr] // Применяется к методу- компилятор может определить сам
 [param: SomeAttr] // Применяется к параметру- компилятор может определить сам
 [property: SomeAttr] // Применяется к свойству- компилятор может определить сам
[method: SomeAttr] // Применяется к механизму доступа get- компилятор может определить сам
 [event: SomeAttr] // Применяется к событиям- компилятор может определить сам
 [field: SomeAttr] // Применяется к полям, созданным компилятором
 [method: SomeAttr] // Применяется к созданным
 // компилятором методам add и remov


можно применить атрибут к атрибуту, тк атрибут просто класс


так нельзя
[Flags][Flags]
internal enum Color {

но
Однако есть и атрибуты, многократное применение которых оправдано — в FCL
это класс атрибутов ConditionalAttribute. Для этого параметру AllowMultiple
должно быть присвоено значение true. В противном случае многократное применение атрибута невозможно.
Свойство Inherited класса AttributeUsageAttribute указывает, будет ли
атрибут, применяемый к базовому классу, применяться также к производным
классам и переопределенным методам



#условный атрибут #Conditional
//#define TEST
#define VERIFY
using System;
using System.Diagnostics;
[Conditional("TEST")][Conditional("VERIFY")]
public sealed class CondAttribute : Attribute {
}
[Cond]
public sealed class Program {
 public static void Main() {
 Console.WriteLine("CondAttribute is {0}applied to Program type.",
 Attribute.IsDefined(typeof(Program),
 typeof(CondAttribute)) ? "" : "not ");

Обнаружив, что был применен экземпляр CondAttribute, компилятор помещает
в метаданные информацию об атрибуте, только если при компиляции кода был
определен идентификатор TEST или VERIFY. При этом метаданные определения
и реализации класса атрибута все равно останутся в сборке.



#reflection #attr
определить есть ли у типа атрибут
 if (this.GetType().IsDefined(typeof(FlagsAttribute), false)) {
#IsDefined
#GetCustomAttributes
#GetCustomAttribute





#Conditional
class n{
[Conditional("trial")]
void nnn(){}
}
nObj.nnn();//вызовется только если #define trial


#Obsolete
пометить элемент программы как устаревший
[Obsolete("сообщение",bool a)]//если a-true то сообщение об ошибке если нет то предупреждение
class n{}




















//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


















///////////////////////////////////////OLD--------------------------------------

























#soa
сервис ориентированная архитектура
каждый сервис- отдельный автономный модуль
-тут есть принципы #TODO















#c#

как определить что символы выглядят одинаково

char first = 'A';//angl
        char second = 'А';//rus
string firstNormalized = first.ToString().Normalize(NormalizationForm.FormKD);
        string secondNormalized = second.ToString().Normalize(NormalizationForm.FormKD);
Console.WriteLine(first.Equals(second));                     // False
        Console.WriteLine(firstNormalized.Equals(secondNormalized)); // True













































































#TODO растащить по файлам
//------------------------------------------------------------------------полезные куски кода-------------------------------

#check_id #id #GetUserId #UserId

public static string GetUserId()
        {
            return System.Web.HttpContext.Current.User.Identity.GetUserId();
        }

        public static ApplicationUser GetUser(string id)
        {
            //string check_id = ApplicationUser.GetUserId();
            ApplicationUser res = null;
            //if (string.IsNullOrWhiteSpace(id))
            //    return res;
            using (ApplicationDbContext db = new ApplicationDbContext())
            {
                res = ApplicationUser.GetUser(id,db);
            }
                
            return res;
        }
public static ApplicationUser GetUser(string id, ApplicationDbContext db)
        {
            //string check_id = ApplicationUser.GetUserId();
            ApplicationUser res = null;
            if (string.IsNullOrWhiteSpace(id))
                return res;
            res = db.Users.FirstOrDefault(x1 => x1.Id == id);

            return res;
        }






#main #header #main_header #mainheader  #preloader #up

<div id="Main_preloader_id" class="Main_preloader div_display_none"></div>
<div class="Main_header_big"> </div>
<div id="Main_header_check_small_or_big_header">
</div>
<div class="Main_header_small" id="Main_header_small_id">
</div>


layout
@Html.Action("Main_header", "Home")
        <div id="layout_active_panel_id" class="layout_active_panel"></div>
        <div onclick="up()" class="Main_header_back_to_top" id="Main_header_back_to_top_id"></div>





css
div.Main_header_big {
    position: relative;
    background-color: white;
    height: 500px;
    width: 96%;
    left: 2%;
    background-image: url(/Content/images/main_header_back_big.jpg);
    background-size: 100% 100%;
     box-shadow: 0 0 10px rgba(0,0,0,0.5);
}
div.Main_header_small {
    position: fixed;
    height: 50px;
    width: 100%;
    display: none;
    top: 0px;
    /*background-color: #cdfae0;*/
    background-image: url(/Content/images/main_header_back_big.jpg);
    min-width:960px;
    z-index: 5;
}


div.Main_preloader{
    position:fixed;
    width:100px;
    height:100px;
    left:48%;
    top:50px;
    background-image: url(/Content/images/preloader_cat.gif);
    background-size: 100% 100%;
    z-index:5;
}



/*JS*/

function up() {
    var top = Math.max(document.body.scrollTop, document.documentElement.scrollTop);
    if (top > 0) {
        window.scrollBy(0, -100);
        time_for_page_up = setTimeout('up()', 20);
    } else clearTimeout(time_for_page_up);
    return false;
}

function isVisible(tag) {
    var t = $(tag);
    var w = $(window);
    var top_window = w.scrollTop();
    var bot_window=top_window+document.documentElement.clientHeight;
    var top_tag = t.offset().top;
    var bot_tag = top_tag + t.height();
    //alert(bot_tag);
    //alert(top_window);
    return ((bot_tag >= top_window && bot_tag <= bot_window) || (top_tag >= top_window && top_tag <= bot_window) || (bot_tag >= bot_window && top_tag <= top_window));
}
$(function () {
    $(window).scroll(function () {
        Change_main_header();
        
    });
});


function Change_main_header() {
    var b = $("#Main_header_check_small_or_big_header");
    if (!b.prop("shown") && !isVisible(b)) {
        b.prop("shown", true);
        var o = document.getElementById("Main_header_small_id")
        var o1 = document.getElementById("Main_header_back_to_top_id")
        o1.style.display = 'block';

        o.style.display = 'block';

    }
    else {
        if (b.prop("shown") && isVisible(b)) {
            b.prop("shown", false);
            var o = document.getElementById("Main_header_small_id")
            var o1 = document.getElementById("Main_header_back_to_top_id")
            o1.style.display = 'none';
            o.style.display = 'none';
        }
    }

}












#плитка



<div class="padding_10_top create_something_one_block div_inline_block">
    <div class="create_something_one_block_inside">
        <a class="link_standart_for_div" href="@Url.Action("ListUserAct","ListPhysics", new { })">


            @*@Html.ActionLink("Личная страница", "PersonalRecord", "SocialNetwork", new { }, new { })*@
            Работа с списками и пользователями

            <div class="create_something_one_block_move">
                Страница для добавления\удаления отношения список-пользователь, физ эффект-пользователь

            </div>

        </a>
    </div>
</div>


.padding_10_top{
    padding-top:10px;
}
div.create_something_one_block{
    width:200px;
}
div.div_inline_block {
    display: inline-block;
    vertical-align: top;
}
div.create_something_one_block_inside{
    height:200px;
    -webkit-box-shadow: 0 0 10px rgba(0,0,0,0.5);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
    border-radius:20px;
    text-align:center;
cursor:pointer;
overflow:hidden;
position:relative;
}

.link_standart_for_div {
    display: block; /* Ссылка как блочный элемент */
    text-align: center; /* Выравнивание по центру */
    height: 100%; /* Высота на весь слой */
    color: black; /* Цвет ссылки */
    
}
div.create_something_one_block_inside:hover div.create_something_one_block_move{
    top:0;
}
div.create_something_one_block_move{
    /*border:solid 2px black;*/
position:absolute;
background-color:rgb(128, 128, 128);
opacity:1;
width:200px;
height:200px;
top:200px;
-webkit-transition:1s;
-o-transition:1s;
transition:1s;
color:white;

}










---------------------------------------------------------------этот блок где просто накидана найс инфа, без нормального поиска он почти бесполезен------------------------------------------------------------------------
#sql #error
при коннекте слева в дб  выдае ошибку
This database file is not compatible with the current instance of SQL Server.

To resolve this issue, you must upgrade the database file by creating a new data connection, or you must modify the existing connection to this database file.

For more information, see http://go.microsoft.com/fwlink/?LinkId=235986


решение 
go to VisualStadio 2012 In Server Explorer Windows open Data Connections Right click on ASPNETDB.MDF click on Modify Connection... a new windows open for you ... you just click OK if other windows open for you click Yes FINISH ( be Happy ) :D


#error
При установлении соединения с SQL Server произошла ошибка, связанная с сетью или с определенным экземпляром. Сервер не найден или недоступен. Убедитесь, что имя экземпляра указано правильно и что на SQL Server разрешены удаленные соединения. (provider: SQL Network Interfaces, error: 26 - Ошибка при обнаружении указанного сервера или экземпляра)
нужно включить именно тот к которому идет коннект
решение по тегам #SQL #server  ->запустить службу
+ включить сам сервер в папке сервера, инфа по темже тегам








при #seed добавление ролей add to role UserId not found
Это может включать в себя следующее:
Политика паролей не соблюдается (это наиболее распространенная причина)
Обязательные поля передаются как пустые строки / null
Дубликат имени пользователя или электронной почты
если нет то попробовать отладить метод create






































--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

















































