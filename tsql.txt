






#tsql





#TODO
сейчас недостаточно хештегов
group by по нескольким столбцам

#ROLLUP     #todo
Оператор ROLLUP добавляет суммирующую строку в результирующий набор:(в конец результата добавит строку с суммой по столбцам результата)

GROUP BY Manufacturer WITH ROLLUP



#CUBE     #todo
CUBE похож на ROLLUP за тем исключением, что CUBE добавляет суммирующие строки для каждой комбинации групп.


#GROUPING SETS #todo

#OVER    #todo




#todo 
а если убрать count???  https://metanit.com/sql/sqlserver/7.4.php

SELECT FirstName, COUNT(Orders.Id)
FROM Customers JOIN Orders 
ON Orders.CustomerId = Customers.Id
GROUP BY Customers.Id, Customers.FirstName;




#create #table
#создание обычной #таблицы  #таблица

CREATE TABLE Accounts (FirstName NVARCHAR NOT NULL, Age INT NOT NULL)


#создание #временной таблицы ## 

существуют на протяжении сессии базы данных
хранятся в таблице tempdb
CREATE TABLE #Accounts ( CreatedAt DATE, Balance MONEY)
--работа как с обычной
INSERT INTO #Accounts VALUES(@date, @sum)



можно удалить через DROP TABLE


#создание #глобальной #временной таблицы  ###




#WITH #Производные таблицы
хранятся в оперативной памяти и существуют только во время первого выполнения запроса, который представляет эту таблицу.
WITH OrdersInfo AS
(
    SELECT ProductId, ...
)
SELECT * FROM OrdersInfo -- здесь нормально
SELECT * FROM OrdersInfo -- здесь ошибка





#create #view
Представления могут иметь не более 1024 столбцов и могут обращать не более чем к 256 таблицам.
CREATE VIEW название_представления [(столбец_1, столбец_2, ....)]
AS выражение_SELECT

CREATE VIEW OrdersProductsCustomers AS SELECT Orders.CreatedAt AS OrderDate, ...
CREATE VIEW OrdersProductsCustomers2 (OrderDate, Customer,Product) AS SELECT ...

SELECT * FROM OrdersProductsCustomers

Команда SELECT, используемая в представлении, не может включать выражения INTO или ORDER BY (за исключением тех случаев, когда также применяется выражение TOP или OFFSET). Если же необходима сортировка данных в представлении, то выражение ORDER BY применяется в команде SELECT, которая извлекает данные из представления.

#ALTER VIEW
изменение представления
ALTER VIEW название_представления [(столбец_1, столбец_2, ....)] AS выражение_SELECT
#DROP
удаление представления
при удалении таблиц нужно удалить и представления для удаляемых таблиц
DROP VIEW OrdersProductsCustomers





можно создать локальную таблицу с помощью declare






представления могут быть #обновляемыми  #updatable
В таких представлениях мы можем изменить или удалить строки или добавить в них новые строки
команда SELECT в updatable представлении не может содержать:
TOP
DISTINCT
UNION
JOIN
агрегатные функции типа COUNT или MAX
GROUP BY и HAVING
подзапросы
производные столбцы или столбцы, которые вычисляются на основании нескольких значений
обращения одновременно к нескольким таблицам
добавляем данные(при добавлении фактически будет добавлен объект в таблицу на которую ссылается представление)
INSERT INTO ProductView (Product, Manufacturer, Price) VALUES('Nokia 8', 'HDC Global', 18000)








#PRIMARY #KEY


CREATE TABLE Customers
(
    Id INT PRIMARY KEY,
    Age INT,
    FirstName NVARCHAR(20)

--или
PRIMARY KEY(Id)--сюда можно несколько столбцов через запятую, все будут primary key

)






#IDENTITY
только для числовых типов данных
при добавлении новой записи будет присваиваться ++значение от предыдущей записи
только 1 столбец может иметь такой атрибут
CREATE TABLE Customers
(
    Id INT PRIMARY KEY IDENTITY
-- Id INT IDENTITY ((int)a, (int)b) -- a- начальное значение, b-на сколько будет увеличиваться
)



#unique
не получится добавить запись если уже есть запись с таким столбцом
CREATE TABLE Customers
(
    Id INT PRIMARY KEY IDENTITY,
    Age INT unique

--или
unique(Age,...)
)




#NULL и #NOT NULL

CREATE TABLE Customers
(
    Id INT PRIMARY KEY IDENTITY,
    FirstName NVARCHAR(20) NOT NULL,
)



#DEFAULT

CREATE TABLE Customers
(
    Id INT PRIMARY KEY IDENTITY,
    Age INT DEFAULT 18
)



#check
устанавливаем ограничение
CREATE TABLE Customers
(
    Id INT PRIMARY KEY IDENTITY,
    Age INT DEFAULT 18 CHECK(Age >0 AND Age < 100),
    Email VARCHAR(30) UNIQUE CHECK(Email !='')
--аналог для таблицы
CHECK((Age >0 AND Age<100) AND (Email !='') AND (Phone !=''))

);



#CONSTRAINT  #ограничение #ограничения

"PK_" - для PRIMARY KEY

"FK_" - для FOREIGN KEY

"CK_" - для CHECK

"UQ_" - для UNIQUE

"DF_" - для DEFAULT

CREATE TABLE Customers
(
    Id INT CONSTRAINT PK_Customer_Id PRIMARY KEY IDENTITY,
    Age INT
        CONSTRAINT DF_Customer_Age DEFAULT 18 
)
для таблицы

CREATE TABLE Customers
(
    Id INT IDENTITY,
    Age INT CONSTRAINT DF_Customer_Age DEFAULT 18, 
    FirstName NVARCHAR(20) NOT NULL,
    LastName NVARCHAR(20) NOT NULL,
    Email VARCHAR(30),
    Phone VARCHAR(20),
    CONSTRAINT PK_Customer_Id PRIMARY KEY (Id), 
    CONSTRAINT CK_Customer_Age CHECK(Age >0 AND Age < 100),
    CONSTRAINT UQ_Customer_Email UNIQUE (Email),
)



 #FOREIGN #KEY #внешний #ключ


[FOREIGN KEY] REFERENCES главная_таблица (столбец_главной_таблицы)
    [ON DELETE {CASCADE|NO ACTION}]
    [ON UPDATE {CASCADE|NO ACTION}]
--
FOREIGN KEY (стобец1, столбец2, ... столбецN) 
    REFERENCES главная_таблица (столбец_главной_таблицы1, столбец_главной_таблицы2, ... столбец_главной_таблицыN)
    [ON DELETE {CASCADE|NO ACTION}]
    [ON UPDATE {CASCADE|NO ACTION}]


CREATE TABLE Customers
(
    Id INT PRIMARY KEY IDENTITY
)

--зависимая таблица, с внешним ключем
CREATE TABLE Orders
(
    Id INT PRIMARY KEY IDENTITY,
    CustomerId INT REFERENCES Customers (Id)
--или
[CONSTRAINT FK_Orders_To_Customers] FOREIGN KEY (CustomerId)  REFERENCES Customers (Id)
)





#ON DELETE и #ON UPDATE
cascade
no action
set null
set default -- установит null если значение по умолчанию не определено

FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE CASCADE





#ALTER TABLE


ALTER TABLE название_таблицы [WITH CHECK | WITH NOCHECK]
{ ADD название_столбца тип_данных_столбца [атрибуты_столбца] | 
  DROP COLUMN название_столбца |
  ALTER COLUMN название_столбца тип_данных_столбца [NULL|NOT NULL] |
  ADD [CONSTRAINT] определение_ограничения |
  DROP [CONSTRAINT] имя_ограничения}


--добавляем столбец
ALTER TABLE Customers ADD Address NVARCHAR(50) NULL;
ALTER TABLE Customers ADD Address NVARCHAR(50) NOT NULL DEFAULT 'Неизвестно';

--добавление ключей
ALTER TABLE Orders ADD FOREIGN KEY(CustomerId) REFERENCES Customers(Id);
ALTER TABLE Orders ADD PRIMARY KEY (Id);

--ограничения
ALTER TABLE Customers ADD CONSTRAINT CK_Age_Greater_Than_Zero CHECK (Age > 0);

--удаление огранчиения 
ALTER TABLE Orders DROP FK_Orders_To_Customers;

WITH NOCHECK
при добавлении ограничения если в таблице есть данные которые не подходят
установить ограничение не получится
но если юзать эту штуку то получится
ALTER TABLE Customers WITH NOCHECK ADD CHECK (Age > 21);






#batch #пакет
выполнение нескольких команд в 1 скрипте

команда1
GO
команда2


#insert

INSERT [INTO] имя_таблицы [(список_столбцов)] VALUES (значение1, значение2, ... значениеN)

--строки по порядку таблицы, все столбцы кроме id

INSERT Products VALUES ('iPhone 7', 'Apple', DEFAULT, 52000)
--указываем столбцы и порядок
INSERT INTO Products (ProductName, Price, Manufacturer) VALUES ('iPhone 6S', 41000, 'Apple')

#global
@@IDENTITY - глобальная переменная, после вставки записи в таблице в ней находится id новой записи

#inserted
возможно доступна только в триггерах(пока хз)
при добавлении или изменении данные(все столбцы вставленных данных) сохраняются в промежуточную таблицу inserted. Она создается автоматически. 
SELECT Id FROM inserted

#DELETED #TODO
возможно доступна только в триггерах(пока хз)
"хранит те же строки, но до обновления(inserted)"



#SELECT  #выборка

SELECT список_столбцов_через_запятую FROM имя_таблицы

возвращаем не просто поля
без #as столбец может быть без названия из за операций
SELECT
ProductName + ' (' + Manufacturer + ')' AS ModelName, 
Price,  
Price * ProductCount AS TotalSum
FROM Products










#SELECT #INTO #SELECTINTO
 в базе данных будет создана еще одна таблица ProductSummary
ProductSummary не должна существовать в базе данных.  потом ее можно использовать как обычную таблицу
можно выгружать в временную таблицу через #
SELECT *
INTO ProductSummary
FROM Products



#DISTINCT
убирает #дубликаты #повтор
SELECT DISTINCT Manufacturer FROM Products



#ORDER BY  #ORDERBY #sort #сортировка
если есть DESC то по убыванию(по возрастанию -ASC, используется по умолчанию)
если сортировка по нескольким столбцам то сначала сортируется по 1 ,если есть несколько равных, они сортируются по 2 и тд
SELECT  Price AS TotalSum
FROM Products
ORDER BY TotalSum[доп столбцы(или сложные выражения( столбец1*столбец2)) через запятую, для каждого можно указать тип DESC\asc] [DESC]




#TOP #диапазон #take #count
если указано ключевае слово PERCENT то выбор будет в % (75%) если нет то количество
SELECT TOP 75 [PERCENT] ProductName FROM Products




#OFFSET и #FETCH #смещение #skip #take #count
применимо только после ORDER BY

ORDER BY выражение 
    OFFSET смещение_относительно_начала {ROW|ROWS}
    [FETCH {FIRST|NEXT} количество_извлекаемых_строк {ROW|ROWS} ONLY]

SELECT * FROM Products
ORDER BY Id 
    OFFSET 2 ROWS
    FETCH NEXT 3 ROWS ONLY;





#WHERE 

=: сравнение на равенство (регист значения не имеет)
<> | !=: сравнение на неравенство
<: меньше чем
>: больше чем
!<: не меньше чем
!>: не больше чем
<=: меньше чем или равно
>=: больше чем или равно
AND OR NOT(<>) Если эти операторы встречаются в одном выражении, то сначала выполняется NOT, потом AND и в конце OR., переопределяется скобками

WHERE ProductCount IS [NOT] NULL


#in #where


SELECT * FROM Products WHERE Manufacturer IN ('Samsung', 'Xiaomi', 'Huawei')

#notin
SELECT * FROM Products WHERE Manufacturer NOT IN ('Samsung', 'Xiaomi', 'Huawei')


#BETWEEN

WHERE выражение [NOT] BETWEEN начальное_значение AND конечное_значение


#LIKE

WHERE выражение [NOT] LIKE шаблон_строки

%: соответствует любой подстроке, которая может иметь любое количество символов, при этом подстрока может и не содержать ни одного символа

_: соответствует любому одиночному символу

[ ]: соответствует одному символу, который указан в квадратных скобках
WHERE ProductName LIKE 'text [45789]' подтянет любой из списка  в скобках

[ - ]: соответствует одному символу из определенного диапазона
WHERE ProductName LIKE 'text [5-7]' подтянет любой из диапазона(включая) в скобках
[ ^ ]: соответствует одному символу, который не указан после символа ^
WHERE ProductName LIKE 'text [^7]' подтянет любой из textN где N!=7

несколько в 1
WHERE ProductName LIKE 'text [^1-6]%'
выберет text7 text77 но не выберет text1



#UPDATE #обновление

UPDATE имя_таблицы
SET столбец1 = значение1, столбец2 = значение2, ... столбецN = значениеN
[FROM выборка AS псевдоним_выборки]
[WHERE условие_обновления]

UPDATE Products
SET Manufacturer = 'Apple Inc.'
FROM
(SELECT TOP 2 * FROM Products WHERE Manufacturer='Apple') AS Selected
WHERE Products.Id = Selected.Id




#DELETE #удаление


DELETE [FROM] имя_таблицы
WHERE условие_удаления

DELETE Products WHERE Id=9


DELETE Products FROM
(SELECT TOP 2 * FROM Products
WHERE Manufacturer='Apple]') AS Selected
WHERE Products.Id = Selected.Id

полное удаление
DELETE Products







Все агрегатные функции за исключением COUNT(*)(только с *) игнорируют значения NULL.
если нужно выбрать еще и столбец то нужно использовать GROUP BY с этим столбцом
#agregate
#AVG: находит среднее значение(число)
#SUM: находит сумму значений(число)
#MIN: находит наименьшее значение(число\строка\дата)
#MAX: находит наибольшее значение(число\строка\дата)
#COUNT: находит количество строк в запросе(число\строка\дата)
SELECT 
[agregate1]([DISTINCT\ALL] Price*Count) [as] ,
[[agregate2]([DISTINCT\ALL] Price*Count) [as] ]

FROM Products [WHERE ]



#GROUP BY #GROUPBY 
join можно использовать с group by
Если столбец, по которому производится группировка, содержит значение NULL, то строки со значением NULL составят отдельную группу.

SELECT столбцы
FROM таблица
[WHERE условие_фильтрации_строк]
[GROUP BY столбцы_для_группировки]
[HAVING условие_фильтрации_групп]
[ORDER BY столбцы_для_сортировки]

для каждого существующего Manufacturer выберет количество
SELECT Manufacturer, COUNT(*) AS ModelsCount
FROM Products
GROUP BY Manufacturer



#HAVING

если есть агрегатные функции или group by можем ограничить выборку
в отличии от where применяется не к строке а ко всей выборке

SELECT Manufacturer, COUNT(*) AS Models, SUM(ProductCount) AS Units
FROM Products
WHERE Price * ProductCount > 80000
GROUP BY Manufacturer
HAVING SUM(ProductCount) > 2
ORDER BY Units DESC






#подзапросы
можно использовать в select/insert/UPDATE(после set\where)\delete

#некоррелирующие
выполняются 1 раз
SELECT *
FROM Products
WHERE Price > (SELECT AVG(Price) FROM Products)

#Коррелирующие 
выполняются для каждой строки
SELECT   (SELECT ProductName FROM Products 
        WHERE Products.Id = Orders.ProductId) AS Product
FROM Orders


#ALL 
будет сравнивать со всеми записями которые вернет подзапрос и если везде условие true то where-true
SELECT * FROM Products WHERE Price < ALL(SELECT Price FROM Products WHERE Manufacturer='Apple')

#SOME #ANY
SOME тоже что и ANY
будет сравнивать со всеми записями которые вернет подзапрос и хоть где то условие true то where-true










#EXISTS 
не возвращает строк, проверяет существование и поэтому выполняется быстро

SELECT *
FROM Customers
WHERE [NOT] EXISTS (SELECT * FROM Orders 
                  WHERE Orders.CustomerId = Customers.Id)





#join без joina

соеденит 2 таблицы каждая строка с каждой

SELECT * FROM Orders, Customers

эквивалент #inner #join
SELECT * FROM Orders, Customers WHERE Orders.CustomerId = Customers.Id

SELECT C.FirstName, P.ProductName, O.*    --выбираем все с *
FROM Orders AS O, Customers AS C, Products AS P
WHERE O.CustomerId = C.Id AND O.ProductId=P.Id



join можно использовать с group by

#INNER #JOIN

SELECT столбцы
FROM таблица1
    [INNER] JOIN таблица2  --inner не обязательно и не на что не влияет
    ON условие1
    [[INNER] JOIN таблица3
    ON условие2]



#OUTER #JOIN
[OUTER]-- не обязательно и не влияет
SELECT столбцы
FROM таблица1
    {LEFT|RIGHT|FULL} [OUTER] JOIN таблица2 ON условие1
    [{LEFT|RIGHT|FULL} [OUTER] JOIN таблица3 ON условие2]

если что то не нашлось то столбцы в выборке будут null

#LEFT #JOIN
все из левой

#RIGHT #JOIN
все из правой


#FULL #JOIN
все 


#Cross #Join
каждая с каждой
	
SELECT * FROM Orders CROSS JOIN Customers







#UNION
если строки дублируются(полностью) то без ALL будет оставаться только 1 экземпляр
SELECT_выражение - обычный селект с for\where и тд
можно объединять таблицу с самой сабой но например по разным условиям 
и возвращать немного разные данные(но одинаковые типы и столбцы( имена можно задать через AS)


SELECT_выражение1
UNION [ALL] SELECT_выражение2
[UNION [ALL] SELECT_выражениеN]

SELECT FirstName, LastName 
FROM Customers
UNION SELECT FirstName, LastName FROM Employees
столбцы и тип должны сопадать для обех таблиц
будет 1 результирующая таблица в которую будут включены столбцы из 2х таблиц







#EXCEPT
 разность двух выборок, то есть те строки которые есть в первой выборке, но которых нет во второй

SELECT_выражение1
EXCEPT SELECT_выражение2


SELECT FirstName, LastName
FROM Customers
EXCEPT SELECT FirstName, LastName 
FROM Employees



#INTERSECT

общие строки для двух выборок, то есть данный оператор выполняет операцию пересечения множеств

SELECT_выражение1
INTERSECT SELECT_выражение2




#string #строки

#LEN: возвращает количество символов в строке. В качестве параметра в функцию передается строка, для которой надо найти длину:
SELECT LEN('Apple')  -- 5

#LTRIM: удаляет начальные пробелы из строки. В качестве параметра принимает строку:
SELECT LTRIM('  Apple')

#RTRIM: удаляет конечные пробелы из строки. В качестве параметра принимает строку:
SELECT RTRIM(' Apple    ')

#CHARINDEX: возвращает индекс, по которому находится первое вхождение подстроки в строке. В качестве первого параметра передается подстрока, а в качестве второго - строка, в которой надо вести поиск:
SELECT CHARINDEX('pl', 'Apple') -- 3

#PATINDEX: возвращает индекс, по которому находится первое вхождение определенного шаблона в строке:
SELECT PATINDEX('%p_e%', 'Apple')   -- 3

#LEFT: вырезает с начала строки определенное количество символов. Первый параметр функции - строка, а второй - количество символов, которые надо вырезать сначала строки:
SELECT LEFT('Apple', 3) -- App

#RIGHT: вырезает с конца строки определенное количество символов. Первый параметр функции - строка, а второй - количество символов, которые надо вырезать сначала строки:
SELECT RIGHT('Apple', 3)    -- ple

#SUBSTRING: вырезает из строки подстроку определенной длиной, начиная с определенного индекса. Певый параметр функции - строка, второй - начальный индекс для вырезки, и третий параметр - количество вырезаемых символов:
SELECT SUBSTRING('Galaxy S8 Plus', 8, 2)    -- S8

#REPLACE: заменяет одну подстроку другой в рамках строки. Первый параметр функции - строка, второй - подстрока, которую надо заменить, а третий - подстрока, на которую надо заменить:
SELECT REPLACE('Galaxy S8 Plus', 'S8 Plus', 'Note 8')   -- Galaxy Note 8

#REVERSE: переворачивает строку наоборот:
SELECT REVERSE('123456789') -- 987654321

#CONCAT: объединяет две строки в одну. В качестве параметра принимает от 2-х и более строк, которые надо соединить:
SELECT CONCAT('Tom', ' ', 'Smith')  -- Tom Smith

#LOWER: переводит строку в нижний регистр:
SELECT LOWER('Apple')   -- apple

#UPPER: переводит строку в верхний регистр
SELECT UPPER('Apple')   -- APPLE

#SPACE: возвращает строку, которая содержит определенное количество пробелов


SELECT UPPER(LEFT(Manufacturer,2)) AS Abbreviation,
       CONCAT(ProductName, ' - ',  Manufacturer) AS FullProdName
FROM Products
ORDER BY Abbreviation





#num #number #число

#ROUND 

SELECT ROUND(1342.345, 2)   -- 1342.350
SELECT ROUND(1342.345, -2)  -- 1300.000

#ABS
SELECT ABS(-123)    -- 123

#CEILING
возвращает наименьшее целое число, которое больше или равно текущему значению.
SELECT CEILING(-123.45)     -- -123
SELECT CEILING(123.45)      -- 124


#FLOOR: возвращает наибольшее целое число, которое меньше или равно текущему значению.

SELECT FLOOR(-123.45)       -- -124
SELECT FLOOR(123.45)        -- 123


#SQUARE: возводит число в квадрат.
SELECT SQUARE(5)        -- 25


#SQRT: получает квадратный корень числа.
SELECT SQRT(225)        -- 15


#RAND: генерирует случайное число с плавающей точкой в диапазоне от 0 до 1.
SELECT RAND()       -- 0.707365088352935


#COS: возвращает косинус угла, выраженного в радианах
SELECT COS(1.0472)  -- 0.5 - 60 градусов

#SIN: возвращает синус угла, выраженного в радианах
SELECT SIN(1.5708)  -- 1 - 90 градусов

#TAN: возвращает тангенс угла, выраженного в радианах
SELECT TAN(0.7854)  -- 1 - 45 градусов





#date #time





#GETDATE: возвращает текущую локальную дату и время на основе системных часов в виде объекта datetime
SELECT GETDATE()    -- 2017-07-28 21:34:55.830

#GETUTCDATE: возвращает текущую локальную дату и время по гринвичу (UTC/GMT) в виде объекта datetime
SELECT GETUTCDATE()     -- 2017-07-28 18:34:55.830


#SYSDATETIME: возвращает текущую локальную дату и время на основе системных часов, но отличие от GETDATE состоит в том, что дата и время возвращаются в виде объекта datetime2
SELECT SYSDATETIME()        -- 2017-07-28 21:02:22.7446744

#SYSUTCDATETIME: возвращает текущую локальную дату и время по гринвичу (UTC/GMT) в виде объекта datetime2
SELECT SYSUTCDATETIME()     -- 2017-07-28 18:20:27.5202777

SYSDATETIMEOFFSET: возвращает объект datetimeoffset(7), который содержит дату и время относительно GMT
SELECT SYSDATETIMEOFFSET()      -- 2017-07-28 21:02:22.7446744 +03:00

#DAY: возвращает день даты, который передается в качестве параметра
SELECT DAY(GETDATE())       -- 28

#MONTH: возвращает месяц даты
SELECT MONTH(GETDATE())     -- 7

#YEAR: возвращает год из даты
SELECT YEAR(GETDATE())      -- 2017

#DATENAME: возвращает часть даты в виде строки. Параметр выбора части даты передается в качестве первого параметра, а сама дата передается в качестве второго параметра:
SELECT DATENAME(month, GETDATE())       -- July
Для определения части даты можно использовать следующие параметры (в скобках указаны их сокращенные версии):
year (yy, yyyy): год
quarter (qq, q): квартал
month (mm, m): месяц
dayofyear (dy, y): день года
day (dd, d): день месяца
week (wk, ww): неделя
weekday (dw): день недели
hour (hh): час
minute (mi, n): минута
second (ss, s): секунда
millisecond (ms): миллисекунда
microsecond (mcs): микросекунда
nanosecond (ns): наносекунда
tzoffset (tz): смешение в минутах относительно гринвича (для объекта datetimeoffset)


#DATEPART: возвращает часть даты в виде числа. Параметр выбора части даты передается в качестве первого параметра (используются те же параметры, что и для DATENAME), а сама дата передается в качестве второго параметра:
SELECT DATEPART(month, GETDATE())       -- 7

#DATEADD: возвращает дату, которая является результатом сложения числа к определенному компоненту даты. Первый параметр представляет компонент даты, описанный выше для функции DATENAME. Второй параметр - добавляемое количество. Третий параметр - сама дата, к которой надо сделать прибавление:

SELECT DATEADD(month, 2, '2017-7-28')       -- 2017-09-28 00:00:00.000
SELECT DATEADD(day, 5, '2017-7-28')     -- 2017-08-02 00:00:00.000
SELECT DATEADD(day, -5, '2017-7-28')        -- 2017-07-23 00:00:00.000
Если добавляемое количество представляет отрицательное число, то фактически происходит уменьшение даты.


#DATEDIFF: возвращает разницу между двумя датами. Первый параметр - компонент даты, который указывает, в каких единицах стоит измерять разницу. Второй и третий параметры - сравниваемые даты:

SELECT DATEDIFF(year, '2017-7-28', '2018-9-28')     -- разница 1 год
SELECT DATEDIFF(month, '2017-7-28', '2018-9-28')    -- разница 14 месяцев
SELECT DATEDIFF(day, '2017-7-28', '2018-9-28')      -- разница 427 дней
SELECT * FROM Orders
WHERE DATEDIFF(day, CreatedAt, GETDATE()) = 16        -- заказы сделанные 16 дней назад


#TODATETIMEOFFSET: возвращает значение datetimeoffset, которое является результатом сложения временного смещения с другим объектом datetimeoffset
SELECT TODATETIMEOFFSET('2017-7-28 01:10:22', '+03:00')


#SWITCHOFFSET: возвращает значение datetimeoffset, которое является результатом сложения временного смещения с объектом datetime2
SELECT SWITCHOFFSET(SYSDATETIMEOFFSET(), '+02:30')


#EOMONTH: возвращает дату последнего дня для месяца, который используется в переданной в качестве параметра дате.
SELECT EOMONTH('2017-02-05')    -- 2017-02-28
SELECT EOMONTH('2017-02-05', 3) -- 2017-05-31

В качестве необязательного второго параметра можно передавать количество месяцев, которые необходимо прибавить к дате. Тогда последний день месяца будет вычисляться для новой даты.

#DATEFROMPARTS: по году, месяцу и дню создает дату
SELECT DATEFROMPARTS(2017, 7, 28)       -- 2017-07-28

#ISDATE: проверяет, является ли выражение датой. Если является, то возвращает 1, иначе возвращает 0.
SELECT ISDATE('2017-07-28')     -- 1
SELECT ISDATE('2017-28-07')     -- 0
SELECT ISDATE('28-07-2017')     -- 0
SELECT ISDATE('SQL')            -- 0



#CONVERT 
тоже что и cast но с дополнительным форматированием
	
CONVERT(тип_данных, выражение [, стиль]) --необязательный числовой параметр для форматирования
CONVERT(nvarchar, CreatedAt, 3)


#CAST

преобразует выражение одного типа к другому
CAST(выражение AS тип_данных)
SELECT Id, CAST(CreatedAtDate AS nvarchar)


#TRY_CONVERT
CAST и CONVERT выбрасывают исключения если тип привести нельзя, эта штука возвращает null
SELECT TRY_CONVERT(int, 'sql')      -- NULL


#STR(float [, length [,decimal]]): преобразует число в строку. Второй параметр указывает на длину строки, а третий - сколько знаков в дробной части числа надо оставлять

#CHAR(int): преобразует числовой код ASCII в символ. Нередко используется для тех ситуаций, когда необходим символ, который нельзя ввести с клавиатуры

#ASCII(char): преобразует символ в числовой код ASCII

#NCHAR(int): преобразует числовой код UNICODE в символ

#UNICODE(char): преобразует символ в числовой код UNICODE



#CASE #else #WHEN #THEN #switch
CASE выражение
    WHEN значение_1 THEN результат_1
END


SELECT ProductName, Manufacturer,
    CASE ProductCount
        WHEN 1 THEN 'Товар заканчивается'
        WHEN 2 THEN 'Мало товара'
 ELSE 'Много товара'
    END AS EvaluateCount
FROM Products

другая форма
CASE
    WHEN выражение_1 THEN результат_1

CASE
        WHEN Price > 50000 THEN 'Категория A'



#if #else
IF условие
    {инструкция|BEGIN...END}
[ELSE
    {инструкция|BEGIN...END}]

IF DATEDIFF(day, @lastDate, GETDATE()) > 10
--если тут должно быть несколько строк, то открываем блок ключевым словом - BEGIN
    PRINT 'За последние десять дней не было заказов'
--если тут должно быть несколько строк, то закрываем блок ключевым словом -  END;
ELSE
    PRINT 'За последние десять дней были заказы'







#IIF

если ProductCount>3 то str1 иначе str2
IIF(ProductCount>3, 'str1', 'str2')



#while  #циклы


WHILE условие
    {инструкция|BEGIN...END}

WHILE @number > 0
    BEGIN
        SET @factorial = @factorial * @number
        SET @number = @number - 1
    END;



#BREAK  #CONTINUE
работают так же как и везде
BREAK;
CONTINUE;




#NEWID
Для генерации объекта UNIQUEIDENTIFIER, то есть некоторого уникального значения(рандом а не инкримент), используется функция NEWID()
CREATE TABLE Clients
(
    Id UNIQUEIDENTIFIER PRIMARY KEY DEFAULT NEWID(),
)
при insert into также пропускаем Id


#ISNULL
ISNULL(выражение, значение)
--если Phone==null то вернет 2 параметр
SELECT ISNULL(Phone, 'не определено') AS Phone,



#COALESCE
вернет первое которое не null
COALESCE(выражение_1, выражение_2, выражение_N)



#переменная #DECLARE #SET

DECLARE @название_переменной тип_данных
DECLARE @name NVARCHAR(20), @age INT
SET @name='Tom';


можно инициализировать результатом запроса
SELECT @переменная_1 = спецификация_столбца_1,
SELECT @minPrice=MIN(Price), @maxPrice = MAX(Price) FROM Products



таблица
DECLARE @табличная_переменная TABLE
(столбец_1 тип_данных [атрибуты_столбца], 
 столбец_2 тип_данных [атрибуты_столбца] ....)
 [атрибуты_таблицы]

DECLARE @ABrends TABLE (ProductId INT,  ProductName NVARCHAR(20))
--далее можно работать как с обычной таблицей
Они живут в пределах одного пакета, после завершения работы которого они удаляются. То есть они носят временный характер, и физически их данные нигде не хранятся на жестком диске.





#PRINT  #вывод
вывод сообщения пользователю
PRINT 'Name: ' + @name;
тоже отобразит но в виде таблицы
SELECT @name, @age;







#TRY #CATCH #BEGIN

BEGIN TRY
    инструкции
END TRY
BEGIN CATCH
    инструкции
END CATCH

В блоке CATCH для обаботки ошибки мы можем использовать ряд функций:
#ERROR_NUMBER(): возвращает номер ошибки
#ERROR_MESSAGE(): возвращает сообщение об ошибке
#ERROR_SEVERITY(): возвращает степень серьезности ошибки. Степень серьезности представляет числовое значение. И если оно равно 10 и меньше, то такая ошибка рассматривается как предупреждение и не обрабатывается конструкцией TRY...CATCH. Если же это значение равно 20 и выше, то такая ошибка приводит к закрытию подключения к базе данных, если она не обрабатывается конструкцией TRY...CATCH.
#ERROR_STATE(): возвращает состояние ошибки







#Хранимые #процедуры #PROCEDURE  #PROC
 выполняются быстрее, чем обычные SQL-инструкции. Все потому что код процедур компилируется один раз при первом ее запуске, а затем сохраняется в скомпилированной форме.
CREATE PROCEDURE или CREATE PROC.
create должна вызываться в отдельном пакете(между GO)

CREATE PROCEDURE ProductSummary AS
--для отделения можно указать - BEGIN
SELECT ProductName AS Product, Manufacturer, Price
FROM Products
--если указали BEGIN указываем -END;

Для выполнения хранимой процедуры вызывается команда EXEC или EXECUTE:
EXEC ProductSummary
удаление
DROP PROCEDURE ProductSummary


--процедура будет заносить данные в таблицу
CREATE PROCEDURE AddProduct
    @name NVARCHAR(20),
    @manufacturer NVARCHAR(20),
    @count INT,-- @count INT=1, -- необязательный параметр, помещать после обязательных
    @price MONEY
AS
INSERT INTO Products(ProductName, Manufacturer, ProductCount, Price) 
VALUES(@name, @manufacturer, @count, @price)
--выполняем процедуру для занесения данных,значения передаются параметрам процедуры по позиции.
EXEC AddProduct @prodName, @company, @prodCount, @price
EXEC AddProduct 'Galaxy C7', 'Samsung', 5, 22000
--можно по имени
EXEC AddProduct @name = @prodName,....


#OUTPUT
для выходных параметров
CREATE PROCEDURE GetPriceStats
    @minPrice MONEY OUTPUT,
    @maxPrice MONEY OUTPUT
AS
SELECT @minPrice = MIN(Price),  @maxPrice = MAX(Price)
FROM Products
--вызов с возвратом
EXEC GetPriceStats @minPrice OUTPUT, @maxPrice OUTPUT



#RETURN
CREATE PROCEDURE GetAvgPrice AS
DECLARE @avgPrice MONEY
SELECT @avgPrice = AVG(Price)
FROM Products
RETURN @avgPrice;







#trigger #Триггеры
аналог события

CREATE TRIGGER имя_триггера
ON {имя_таблицы | имя_представления}
{AFTER | INSTEAD OF} [INSERT | UPDATE | DELETE]
AS выражения_sql

 тип триггера
AFTER: выполняется после выполнения действия. Определяется только для таблиц., для этого типа можно вешать сразу на несколько операций(через запятую insert,update)
INSTEAD OF: выполняется вместо действия (то есть по сути действие - добавление, изменение или удаление - вообще не выполняется). Определяется для таблиц и представлений


CREATE TRIGGER Products_INSERT_UPDATE
ON Products
AFTER INSERT, UPDATE
AS
UPDATE Products
SET Price = Price + Price * 0.38
WHERE Id = (SELECT Id FROM inserted)--#inserted



DROP TRIGGER Products_INSERT_UPDATE
#DISABLE TRIGGER Products_INSERT_UPDATE ON Products--отключаем триггер
ENABLE TRIGGER Products_INSERT_UPDATE ON Products--включаем триггер



#comand


sp_help table_name
получить полную информацию по таблице, индексы столбцы ограничения и тд/не для временных таблиц




















