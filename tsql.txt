






#tsql





#TODO
сейчас недостаточно хештегов
group by по нескольким столбцам

#ROLLUP     #todo
Оператор ROLLUP добавляет суммирующую строку в результирующий набор:(в конец результата добавит строку с суммой по столбцам результата)

GROUP BY Manufacturer WITH ROLLUP



#CUBE     #todo
CUBE похож на ROLLUP за тем исключением, что CUBE добавляет суммирующие строки для каждой комбинации групп.


#GROUPING SETS #todo

#OVER    #todo




#todo 
а если убрать count???  https://metanit.com/sql/sqlserver/7.4.php

SELECT FirstName, COUNT(Orders.Id)
FROM Customers JOIN Orders 
ON Orders.CustomerId = Customers.Id
GROUP BY Customers.Id, Customers.FirstName;











#PRIMARY #KEY


CREATE TABLE Customers
(
    Id INT PRIMARY KEY,
    Age INT,
    FirstName NVARCHAR(20)

--или
PRIMARY KEY(Id)--сюда можно несколько столбцов через запятую, все будут primary key

)






#IDENTITY
только для числовых типов данных
при добавлении новой записи будет присваиваться ++значение от предыдущей записи
только 1 столбец может иметь такой атрибут
CREATE TABLE Customers
(
    Id INT PRIMARY KEY IDENTITY
-- Id INT IDENTITY ((int)a, (int)b) -- a- начальное значение, b-на сколько будет увеличиваться
)



#unique
не получится добавить запись если уже есть запись с таким столбцом
CREATE TABLE Customers
(
    Id INT PRIMARY KEY IDENTITY,
    Age INT unique

--или
unique(Age,...)
)




#NULL и #NOT NULL

CREATE TABLE Customers
(
    Id INT PRIMARY KEY IDENTITY,
    FirstName NVARCHAR(20) NOT NULL,
)



#DEFAULT

CREATE TABLE Customers
(
    Id INT PRIMARY KEY IDENTITY,
    Age INT DEFAULT 18
)



#check
устанавливаем ограничение
CREATE TABLE Customers
(
    Id INT PRIMARY KEY IDENTITY,
    Age INT DEFAULT 18 CHECK(Age >0 AND Age < 100),
    Email VARCHAR(30) UNIQUE CHECK(Email !='')
--аналог для таблицы
CHECK((Age >0 AND Age<100) AND (Email !='') AND (Phone !=''))

);



#CONSTRAINT  #ограничение #ограничения

"PK_" - для PRIMARY KEY

"FK_" - для FOREIGN KEY

"CK_" - для CHECK

"UQ_" - для UNIQUE

"DF_" - для DEFAULT

CREATE TABLE Customers
(
    Id INT CONSTRAINT PK_Customer_Id PRIMARY KEY IDENTITY,
    Age INT
        CONSTRAINT DF_Customer_Age DEFAULT 18 
)
для таблицы

CREATE TABLE Customers
(
    Id INT IDENTITY,
    Age INT CONSTRAINT DF_Customer_Age DEFAULT 18, 
    FirstName NVARCHAR(20) NOT NULL,
    LastName NVARCHAR(20) NOT NULL,
    Email VARCHAR(30),
    Phone VARCHAR(20),
    CONSTRAINT PK_Customer_Id PRIMARY KEY (Id), 
    CONSTRAINT CK_Customer_Age CHECK(Age >0 AND Age < 100),
    CONSTRAINT UQ_Customer_Email UNIQUE (Email),
)



 #FOREIGN #KEY #внешний #ключ


[FOREIGN KEY] REFERENCES главная_таблица (столбец_главной_таблицы)
    [ON DELETE {CASCADE|NO ACTION}]
    [ON UPDATE {CASCADE|NO ACTION}]
--
FOREIGN KEY (стобец1, столбец2, ... столбецN) 
    REFERENCES главная_таблица (столбец_главной_таблицы1, столбец_главной_таблицы2, ... столбец_главной_таблицыN)
    [ON DELETE {CASCADE|NO ACTION}]
    [ON UPDATE {CASCADE|NO ACTION}]


CREATE TABLE Customers
(
    Id INT PRIMARY KEY IDENTITY
)

--зависимая таблица, с внешним ключем
CREATE TABLE Orders
(
    Id INT PRIMARY KEY IDENTITY,
    CustomerId INT REFERENCES Customers (Id)
--или
[CONSTRAINT FK_Orders_To_Customers] FOREIGN KEY (CustomerId)  REFERENCES Customers (Id)
)





#ON DELETE и #ON UPDATE
cascade
no action
set null
set default -- установит null если значение по умолчанию не определено

FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE CASCADE





#ALTER TABLE


ALTER TABLE название_таблицы [WITH CHECK | WITH NOCHECK]
{ ADD название_столбца тип_данных_столбца [атрибуты_столбца] | 
  DROP COLUMN название_столбца |
  ALTER COLUMN название_столбца тип_данных_столбца [NULL|NOT NULL] |
  ADD [CONSTRAINT] определение_ограничения |
  DROP [CONSTRAINT] имя_ограничения}


--добавляем столбец
ALTER TABLE Customers ADD Address NVARCHAR(50) NULL;
ALTER TABLE Customers ADD Address NVARCHAR(50) NOT NULL DEFAULT 'Неизвестно';

--добавление ключей
ALTER TABLE Orders ADD FOREIGN KEY(CustomerId) REFERENCES Customers(Id);
ALTER TABLE Orders ADD PRIMARY KEY (Id);

--ограничения
ALTER TABLE Customers ADD CONSTRAINT CK_Age_Greater_Than_Zero CHECK (Age > 0);

--удаление огранчиения 
ALTER TABLE Orders DROP FK_Orders_To_Customers;

WITH NOCHECK
при добавлении ограничения если в таблице есть данные которые не подходят
установить ограничение не получится
но если юзать эту штуку то получится
ALTER TABLE Customers WITH NOCHECK ADD CHECK (Age > 21);






#batch #пакет
выполнение нескольких команд в 1 скрипте

команда1
GO
команда2


#insert

INSERT [INTO] имя_таблицы [(список_столбцов)] VALUES (значение1, значение2, ... значениеN)

--строки по порядку таблицы, все столбцы кроме id

INSERT Products VALUES ('iPhone 7', 'Apple', DEFAULT, 52000)
--указываем столбцы и порядок
INSERT INTO Products (ProductName, Price, Manufacturer) VALUES ('iPhone 6S', 41000, 'Apple')





#SELECT  #выборка

SELECT список_столбцов_через_запятую FROM имя_таблицы

возвращаем не просто поля
без #as столбец может быть без названия из за операций
SELECT
ProductName + ' (' + Manufacturer + ')' AS ModelName, 
Price,  
Price * ProductCount AS TotalSum
FROM Products










#SELECT #INTO #SELECTINTO
 в базе данных будет создана еще одна таблица ProductSummary
ProductSummary не должна существовать в базе данных.  потом ее можно использовать как обычную таблицу
SELECT *
INTO ProductSummary
FROM Products



#DISTINCT
убирает #дубликаты
SELECT DISTINCT Manufacturer FROM Products



#ORDER BY  #ORDERBY #sort #сортировка
если есть DESC то по убыванию(по возрастанию -ASC, используется по умолчанию)
если сортировка по нескольким столбцам то сначала сортируется по 1 ,если есть несколько равных, они сортируются по 2 и тд
SELECT  Price AS TotalSum
FROM Products
ORDER BY TotalSum[доп столбцы(или сложные выражения( столбец1*столбец2)) через запятую, для каждого можно указать тип DESC\asc] [DESC]




#TOP #диапазон #take #count
если указано ключевае слово PERCENT то выбор будет в % (75%) если нет то количество
SELECT TOP 75 [PERCENT] ProductName FROM Products




#OFFSET и #FETCH #смещение #skip #take #count
применимо только после ORDER BY

ORDER BY выражение 
    OFFSET смещение_относительно_начала {ROW|ROWS}
    [FETCH {FIRST|NEXT} количество_извлекаемых_строк {ROW|ROWS} ONLY]

SELECT * FROM Products
ORDER BY Id 
    OFFSET 2 ROWS
    FETCH NEXT 3 ROWS ONLY;





#WHERE 

=: сравнение на равенство (регист значения не имеет)
<> | !=: сравнение на неравенство
<: меньше чем
>: больше чем
!<: не меньше чем
!>: не больше чем
<=: меньше чем или равно
>=: больше чем или равно
AND OR NOT(<>) Если эти операторы встречаются в одном выражении, то сначала выполняется NOT, потом AND и в конце OR., переопределяется скобками

WHERE ProductCount IS [NOT] NULL


#in #where


SELECT * FROM Products WHERE Manufacturer IN ('Samsung', 'Xiaomi', 'Huawei')

#notin
SELECT * FROM Products WHERE Manufacturer NOT IN ('Samsung', 'Xiaomi', 'Huawei')


#BETWEEN

WHERE выражение [NOT] BETWEEN начальное_значение AND конечное_значение


#LIKE

WHERE выражение [NOT] LIKE шаблон_строки

%: соответствует любой подстроке, которая может иметь любое количество символов, при этом подстрока может и не содержать ни одного символа

_: соответствует любому одиночному символу

[ ]: соответствует одному символу, который указан в квадратных скобках
WHERE ProductName LIKE 'text [45789]' подтянет любой из списка  в скобках

[ - ]: соответствует одному символу из определенного диапазона
WHERE ProductName LIKE 'text [5-7]' подтянет любой из диапазона(включая) в скобках
[ ^ ]: соответствует одному символу, который не указан после символа ^
WHERE ProductName LIKE 'text [^7]' подтянет любой из textN где N!=7

несколько в 1
WHERE ProductName LIKE 'text [^1-6]%'
выберет text7 text77 но не выберет text1



#UPDATE #обновление

UPDATE имя_таблицы
SET столбец1 = значение1, столбец2 = значение2, ... столбецN = значениеN
[FROM выборка AS псевдоним_выборки]
[WHERE условие_обновления]

UPDATE Products
SET Manufacturer = 'Apple Inc.'
FROM
(SELECT TOP 2 * FROM Products WHERE Manufacturer='Apple') AS Selected
WHERE Products.Id = Selected.Id




#DELETE #удаление


DELETE [FROM] имя_таблицы
WHERE условие_удаления

DELETE Products WHERE Id=9


DELETE Products FROM
(SELECT TOP 2 * FROM Products
WHERE Manufacturer='Apple]') AS Selected
WHERE Products.Id = Selected.Id

полное удаление
DELETE Products







Все агрегатные функции за исключением COUNT(*)(только с *) игнорируют значения NULL.
если нужно выбрать еще и столбец то нужно использовать GROUP BY с этим столбцом
#agregate
#AVG: находит среднее значение(число)
#SUM: находит сумму значений(число)
#MIN: находит наименьшее значение(число\строка\дата)
#MAX: находит наибольшее значение(число\строка\дата)
#COUNT: находит количество строк в запросе(число\строка\дата)
SELECT 
[agregate1]([DISTINCT\ALL] Price*Count) [as] ,
[[agregate2]([DISTINCT\ALL] Price*Count) [as] ]

FROM Products [WHERE ]



#GROUP BY #GROUPBY 
join можно использовать с group by
Если столбец, по которому производится группировка, содержит значение NULL, то строки со значением NULL составят отдельную группу.

SELECT столбцы
FROM таблица
[WHERE условие_фильтрации_строк]
[GROUP BY столбцы_для_группировки]
[HAVING условие_фильтрации_групп]
[ORDER BY столбцы_для_сортировки]

для каждого существующего Manufacturer выберет количество
SELECT Manufacturer, COUNT(*) AS ModelsCount
FROM Products
GROUP BY Manufacturer



#HAVING

если есть агрегатные функции или group by можем ограничить выборку
в отличии от where применяется не к строке а ко всей выборке

SELECT Manufacturer, COUNT(*) AS Models, SUM(ProductCount) AS Units
FROM Products
WHERE Price * ProductCount > 80000
GROUP BY Manufacturer
HAVING SUM(ProductCount) > 2
ORDER BY Units DESC






#подзапросы
можно использовать в select/insert/UPDATE(после set\where)\delete

#некоррелирующие
выполняются 1 раз
SELECT *
FROM Products
WHERE Price > (SELECT AVG(Price) FROM Products)

#Коррелирующие 
выполняются для каждой строки
SELECT   (SELECT ProductName FROM Products 
        WHERE Products.Id = Orders.ProductId) AS Product
FROM Orders


#ALL 
будет сравнивать со всеми записями которые вернет подзапрос и если везде условие true то where-true
SELECT * FROM Products WHERE Price < ALL(SELECT Price FROM Products WHERE Manufacturer='Apple')

#SOME #ANY
SOME тоже что и ANY
будет сравнивать со всеми записями которые вернет подзапрос и хоть где то условие true то where-true










#EXISTS 
не возвращает строк, проверяет существование и поэтому выполняется быстро

SELECT *
FROM Customers
WHERE [NOT] EXISTS (SELECT * FROM Orders 
                  WHERE Orders.CustomerId = Customers.Id)





#join без joina

соеденит 2 таблицы каждая строка с каждой

SELECT * FROM Orders, Customers

эквивалент #inner #join
SELECT * FROM Orders, Customers WHERE Orders.CustomerId = Customers.Id

SELECT C.FirstName, P.ProductName, O.*    --выбираем все с *
FROM Orders AS O, Customers AS C, Products AS P
WHERE O.CustomerId = C.Id AND O.ProductId=P.Id



join можно использовать с group by

#INNER #JOIN

SELECT столбцы
FROM таблица1
    [INNER] JOIN таблица2  --inner не обязательно и не на что не влияет
    ON условие1
    [[INNER] JOIN таблица3
    ON условие2]



#OUTER #JOIN
[OUTER]-- не обязательно и не влияет
SELECT столбцы
FROM таблица1
    {LEFT|RIGHT|FULL} [OUTER] JOIN таблица2 ON условие1
    [{LEFT|RIGHT|FULL} [OUTER] JOIN таблица3 ON условие2]

если что то не нашлось то столбцы в выборке будут null

#LEFT #JOIN
все из левой

#RIGHT #JOIN
все из правой


#FULL #JOIN
все 


#Cross #Join
каждая с каждой
	
SELECT * FROM Orders CROSS JOIN Customers







#UNION
если строки дублируются(полностью) то без ALL будет оставаться только 1 экземпляр
SELECT_выражение - обычный селект с for\where и тд
можно объединять таблицу с самой сабой но например по разным условиям 
и возвращать немного разные данные(но одинаковые типы и столбцы( имена можно задать через AS)


SELECT_выражение1
UNION [ALL] SELECT_выражение2
[UNION [ALL] SELECT_выражениеN]

SELECT FirstName, LastName 
FROM Customers
UNION SELECT FirstName, LastName FROM Employees
столбцы и тип должны сопадать для обех таблиц
будет 1 результирующая таблица в которую будут включены столбцы из 2х таблиц







#EXCEPT
 разность двух выборок, то есть те строки которые есть в первой выборке, но которых нет во второй

SELECT_выражение1
EXCEPT SELECT_выражение2


SELECT FirstName, LastName
FROM Customers
EXCEPT SELECT FirstName, LastName 
FROM Employees



#INTERSECT

общие строки для двух выборок, то есть данный оператор выполняет операцию пересечения множеств

SELECT_выражение1
INTERSECT SELECT_выражение2




#string #строки

#LEN: возвращает количество символов в строке. В качестве параметра в функцию передается строка, для которой надо найти длину:
SELECT LEN('Apple')  -- 5

#LTRIM: удаляет начальные пробелы из строки. В качестве параметра принимает строку:
SELECT LTRIM('  Apple')

#RTRIM: удаляет конечные пробелы из строки. В качестве параметра принимает строку:
SELECT RTRIM(' Apple    ')

#CHARINDEX: возвращает индекс, по которому находится первое вхождение подстроки в строке. В качестве первого параметра передается подстрока, а в качестве второго - строка, в которой надо вести поиск:
SELECT CHARINDEX('pl', 'Apple') -- 3

#PATINDEX: возвращает индекс, по которому находится первое вхождение определенного шаблона в строке:
SELECT PATINDEX('%p_e%', 'Apple')   -- 3

#LEFT: вырезает с начала строки определенное количество символов. Первый параметр функции - строка, а второй - количество символов, которые надо вырезать сначала строки:
SELECT LEFT('Apple', 3) -- App

#RIGHT: вырезает с конца строки определенное количество символов. Первый параметр функции - строка, а второй - количество символов, которые надо вырезать сначала строки:
SELECT RIGHT('Apple', 3)    -- ple

#SUBSTRING: вырезает из строки подстроку определенной длиной, начиная с определенного индекса. Певый параметр функции - строка, второй - начальный индекс для вырезки, и третий параметр - количество вырезаемых символов:
SELECT SUBSTRING('Galaxy S8 Plus', 8, 2)    -- S8

#REPLACE: заменяет одну подстроку другой в рамках строки. Первый параметр функции - строка, второй - подстрока, которую надо заменить, а третий - подстрока, на которую надо заменить:
SELECT REPLACE('Galaxy S8 Plus', 'S8 Plus', 'Note 8')   -- Galaxy Note 8

#REVERSE: переворачивает строку наоборот:
SELECT REVERSE('123456789') -- 987654321

#CONCAT: объединяет две строки в одну. В качестве параметра принимает от 2-х и более строк, которые надо соединить:
SELECT CONCAT('Tom', ' ', 'Smith')  -- Tom Smith

#LOWER: переводит строку в нижний регистр:
SELECT LOWER('Apple')   -- apple

#UPPER: переводит строку в верхний регистр
SELECT UPPER('Apple')   -- APPLE

#SPACE: возвращает строку, которая содержит определенное количество пробелов


SELECT UPPER(LEFT(Manufacturer,2)) AS Abbreviation,
       CONCAT(ProductName, ' - ',  Manufacturer) AS FullProdName
FROM Products
ORDER BY Abbreviation





#num #number #число

#ROUND 

SELECT ROUND(1342.345, 2)   -- 1342.350
SELECT ROUND(1342.345, -2)  -- 1300.000

#ABS
SELECT ABS(-123)    -- 123

#CEILING
возвращает наименьшее целое число, которое больше или равно текущему значению.
SELECT CEILING(-123.45)     -- -123
SELECT CEILING(123.45)      -- 124


#FLOOR: возвращает наибольшее целое число, которое меньше или равно текущему значению.

SELECT FLOOR(-123.45)       -- -124
SELECT FLOOR(123.45)        -- 123


#SQUARE: возводит число в квадрат.
SELECT SQUARE(5)        -- 25


#SQRT: получает квадратный корень числа.
SELECT SQRT(225)        -- 15


#RAND: генерирует случайное число с плавающей точкой в диапазоне от 0 до 1.
SELECT RAND()       -- 0.707365088352935


#COS: возвращает косинус угла, выраженного в радианах
SELECT COS(1.0472)  -- 0.5 - 60 градусов

#SIN: возвращает синус угла, выраженного в радианах
SELECT SIN(1.5708)  -- 1 - 90 градусов

#TAN: возвращает тангенс угла, выраженного в радианах
SELECT TAN(0.7854)  -- 1 - 45 градусов





#date #time





#GETDATE: возвращает текущую локальную дату и время на основе системных часов в виде объекта datetime
SELECT GETDATE()    -- 2017-07-28 21:34:55.830

#GETUTCDATE: возвращает текущую локальную дату и время по гринвичу (UTC/GMT) в виде объекта datetime
SELECT GETUTCDATE()     -- 2017-07-28 18:34:55.830


#SYSDATETIME: возвращает текущую локальную дату и время на основе системных часов, но отличие от GETDATE состоит в том, что дата и время возвращаются в виде объекта datetime2
SELECT SYSDATETIME()        -- 2017-07-28 21:02:22.7446744

#SYSUTCDATETIME: возвращает текущую локальную дату и время по гринвичу (UTC/GMT) в виде объекта datetime2
SELECT SYSUTCDATETIME()     -- 2017-07-28 18:20:27.5202777

SYSDATETIMEOFFSET: возвращает объект datetimeoffset(7), который содержит дату и время относительно GMT
SELECT SYSDATETIMEOFFSET()      -- 2017-07-28 21:02:22.7446744 +03:00

#DAY: возвращает день даты, который передается в качестве параметра
SELECT DAY(GETDATE())       -- 28

#MONTH: возвращает месяц даты
SELECT MONTH(GETDATE())     -- 7

#YEAR: возвращает год из даты
SELECT YEAR(GETDATE())      -- 2017

#DATENAME: возвращает часть даты в виде строки. Параметр выбора части даты передается в качестве первого параметра, а сама дата передается в качестве второго параметра:
SELECT DATENAME(month, GETDATE())       -- July
Для определения части даты можно использовать следующие параметры (в скобках указаны их сокращенные версии):
year (yy, yyyy): год
quarter (qq, q): квартал
month (mm, m): месяц
dayofyear (dy, y): день года
day (dd, d): день месяца
week (wk, ww): неделя
weekday (dw): день недели
hour (hh): час
minute (mi, n): минута
second (ss, s): секунда
millisecond (ms): миллисекунда
microsecond (mcs): микросекунда
nanosecond (ns): наносекунда
tzoffset (tz): смешение в минутах относительно гринвича (для объекта datetimeoffset)


#DATEPART: возвращает часть даты в виде числа. Параметр выбора части даты передается в качестве первого параметра (используются те же параметры, что и для DATENAME), а сама дата передается в качестве второго параметра:
SELECT DATEPART(month, GETDATE())       -- 7

#DATEADD: возвращает дату, которая является результатом сложения числа к определенному компоненту даты. Первый параметр представляет компонент даты, описанный выше для функции DATENAME. Второй параметр - добавляемое количество. Третий параметр - сама дата, к которой надо сделать прибавление:

SELECT DATEADD(month, 2, '2017-7-28')       -- 2017-09-28 00:00:00.000
SELECT DATEADD(day, 5, '2017-7-28')     -- 2017-08-02 00:00:00.000
SELECT DATEADD(day, -5, '2017-7-28')        -- 2017-07-23 00:00:00.000
Если добавляемое количество представляет отрицательное число, то фактически происходит уменьшение даты.


#DATEDIFF: возвращает разницу между двумя датами. Первый параметр - компонент даты, который указывает, в каких единицах стоит измерять разницу. Второй и третий параметры - сравниваемые даты:

SELECT DATEDIFF(year, '2017-7-28', '2018-9-28')     -- разница 1 год
SELECT DATEDIFF(month, '2017-7-28', '2018-9-28')    -- разница 14 месяцев
SELECT DATEDIFF(day, '2017-7-28', '2018-9-28')      -- разница 427 дней
SELECT * FROM Orders
WHERE DATEDIFF(day, CreatedAt, GETDATE()) = 16        -- заказы сделанные 16 дней назад


#TODATETIMEOFFSET: возвращает значение datetimeoffset, которое является результатом сложения временного смещения с другим объектом datetimeoffset
SELECT TODATETIMEOFFSET('2017-7-28 01:10:22', '+03:00')


#SWITCHOFFSET: возвращает значение datetimeoffset, которое является результатом сложения временного смещения с объектом datetime2
SELECT SWITCHOFFSET(SYSDATETIMEOFFSET(), '+02:30')


#EOMONTH: возвращает дату последнего дня для месяца, который используется в переданной в качестве параметра дате.
SELECT EOMONTH('2017-02-05')    -- 2017-02-28
SELECT EOMONTH('2017-02-05', 3) -- 2017-05-31

В качестве необязательного второго параметра можно передавать количество месяцев, которые необходимо прибавить к дате. Тогда последний день месяца будет вычисляться для новой даты.

#DATEFROMPARTS: по году, месяцу и дню создает дату
SELECT DATEFROMPARTS(2017, 7, 28)       -- 2017-07-28

#ISDATE: проверяет, является ли выражение датой. Если является, то возвращает 1, иначе возвращает 0.
SELECT ISDATE('2017-07-28')     -- 1
SELECT ISDATE('2017-28-07')     -- 0
SELECT ISDATE('28-07-2017')     -- 0
SELECT ISDATE('SQL')            -- 0




































